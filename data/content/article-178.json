{"Id":178,"Title":"介绍 Linux 的命名空间","Slug":"2015-03-10-1","Text":"### 背景\n\n从Linux 2.6.24版的内核开始，Linux 就支持6种不同类型的命名空间。它们的出现，使用户创建的进程能够与系统分离得更加彻底，从而不需要使用更多的底层虚拟化技术。\n\n+ `CLONE_NEWIPC`: 进程间通信(IPC)的命名空间，可以将 SystemV 的 IPC 和 POSIX 的消息队列独立出来。\n+ `CLONE_NEWPID`: 进程命名空间。空间内的PID 是独立分配的，意思就是命名空间内的虚拟 PID 可能会与命名空间外的 PID 相冲突，于是命名空间内的 PID 映射到命名空间外时会使用另外一个 PID。比如说，命名空间内第一个 PID 为1，而在命名空间外就是该 PID 已被 init 进程所使用。\n+ `CLONE_NEWNET`: 网络命名空间，用于隔离网络资源（/proc/net、IP 地址、网卡、路由等）。后台进程可以运行在不同命名空间内的相同端口上，用户还可以虚拟出一块网卡。\n+ `CLONE_NEWNS`: 挂载命名空间，进程运行时可以将挂载点与系统分离，使用这个功能时，我们可以达到 chroot 的功能，而在安全性方面比 chroot 更高。\n+ `CLONE_NEWUTS`: UTS 命名空间，主要目的是独立出主机名和网络信息服务（NIS）。\n+ `CLONE_NEWUSER`: 用户命名空间，同进程 ID 一样，用户 ID 和组 ID 在命名空间内外是不一样的，并且在不同命名空间内可以存在相同的 ID。\n\n下面我们介绍一下进程命名空间和网络命名空间。\n\n### 进程命名空间\n\n本文用 C 语言介绍上述概念，因为演示进程命名空间的时候需要用到 C 语言。下面的测试过程在 Debian 6 和 Debian 7 上执行。首先，在栈内分配一页内存空间，并将指针指向内存页的末尾。这里我们使用 `alloca()` 函数来分配内存，不要用 `malloc()` 函数，它会把内存分配在堆上。\n\n    void *mem = alloca(sysconf(_SC_PAGESIZE)) + sysconf(_SC_PAGESIZE);\n\n然后使用 `clone()` 函数创建子进程，传入我们的子栈空间地址 \"mem\"，并指定命名空间的标记。同时我们还指定“callee”作为子进程运行的函数。\n\n    mypid = clone(callee, mem, SIGCHLD | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | CLONE_FILES, NULL);\n\n`clone` 之后我们要在父进程中等待子进程先退出，否则的话，父进程会继续运行下去，并马上进程结束，留下子进程变成孤儿进程：\n\n    while (waitpid(mypid, \u0026r, 0) \u003c 0 \u0026\u0026 errno == EINTR)\n    {\n    continue;\n    }\n\n最后当子进程退出后，我们会回到 shell 界面，并返回子进程的退出码。\n\n    if (WIFEXITED(r))\n    {\n    return WEXITSTATUS(r);\n    }\n    return EXIT_FAILURE;\n\n上文介绍的 `callee` 函数功能如下：\n\n    static int callee()\n    {\n    int ret;\n    mount(\"proc\", \"/proc\", \"proc\", 0, \"\");\n    setgid(u);\n    setgroups(0, NULL);\n    setuid(u);\n    ret = execl(\"/bin/bash\", \"/bin/bash\", NULL);\n    return ret;\n    }\n\n程序挂载了 `/proc` 文件系统，设置用户 ID 和组 ID，值都为“u”，然后运行 `/bin/bash` 程序，LXC 是一个操作系统级的虚拟化工具，使用 cgroups 和命名空间来完成资源的分离。现在我们把所有代码放在一起，变量“u”的值设为65534，在 Debian 系统中，这是“nobody”和“nogroup”：\n\n    #define _GNU_SOURCE\n    #include \u003cunistd.h\u003e\n    #include \u003cstdio.h\u003e\n    #include \u003cstdlib.h\u003e\n    #include \u003csys/types.h\u003e\n    #include \u003csys/wait.h\u003e\n    #include \u003csys/mount.h\u003e\n    #include \u003cgrp.h\u003e\n    #include \u003calloca.h\u003e\n    #include \u003cerrno.h\u003e\n    #include \u003csched.h\u003e\n    static int callee();\n    const int u = 65534;\n    int main(int argc, char *argv[])\n    {\n    int r;\n    pid_t mypid;\n    void *mem = alloca(sysconf(_SC_PAGESIZE)) + sysconf(_SC_PAGESIZE);\n    mypid = clone(callee, mem, SIGCHLD | CLONE_NEWIPC | CLONE_NEWPID | CLONE_NEWNS | CLONE_FILES, NULL);\n    while (waitpid(mypid, \u0026r, 0) \u003c 0 \u0026\u0026 errno == EINTR)\n    {\n    continue;\n    }\n    if (WIFEXITED(r))\n    {\n    return WEXITSTATUS(r);\n    }\n    return EXIT_FAILURE;\n    }\n    static int callee()\n    {\n    int ret;\n    mount(\"proc\", \"/proc\", \"proc\", 0, \"\");\n    setgid(u);\n    setgroups(0, NULL);\n    setuid(u);\n    ret = execl(\"/bin/bash\", \"/bin/bash\", NULL);\n    return ret;\n    }\n\n执行以下命令来运行上面的代码：\n\n    root@w:~/pen/tmp# gcc -O -o ns.c -Wall -Werror -ansi -c89 ns.c\n    root@w:~/pen/tmp# ./ns\n    nobody@w:~/pen/tmp$ id\n    uid=65534(nobody) gid=65534(nogroup)\n    nobody@w:~/pen/tmp$ ps auxw\n    USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\n    nobody 1 0.0 0.0 4620 1816 pts/1 S 21:21 0:00 /bin/bash\n    nobody 5 0.0 0.0 2784 1064 pts/1 R+ 21:21 0:00 ps auxw\n    nobody@w:~/pen/tmp$ \n\n注意上面的结果，UID 和 GID 被设置成 nobody 和 nogroup 了，特别是 ps 工具只输出两个进程，它们的 ID 分别是1和5（LCTT注：这就是上文介绍 CLONE_NEWPID 时提到的功能，在线程所在的命名空间内，进程 ID 可以为1，映射到命名空间外是另外一个 PID；而命名空间外的 ID 为1的进程一直是 init）。\n\n### 网络命名空间\n\n接下来轮到使用 ip netns 来设置网络的命名空间。第一步先确定当前系统没有命名空间：\n\n    root@w:~# ip netns list\n    Object \"netns\" is unknown, try \"ip help\".\n\n如果报了上述错误，你需要更新你的系统内核，以及 ip 工具程序。这里假设你的内核版高于2.6.24，ip 工具版本也差不多，高于2.6.24（LCTT注：ip 工具由 iproute 安装包提供，此安装包版本与内核版本相近）。更新好后，`ip netns list` 在没有命名空间存在的情况下不会输出任务信息。加个名为“ns1”的命名空间看看：\n\n    root@w:~# ip netns add ns1\n    root@w:~# ip netns list\n    ns1\n\n列出网卡：\n\n    root@w:~# ip link list\n    1: lo: mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    2: eth0: mtu 1500 qdisc pfifo_fast state UNKNOWN mode DEFAULT qlen 1000\n    link/ether 00:0c:29:65:25:9e brd ff:ff:ff:ff:ff:ff\n\n创建新的虚拟网卡，并加到命名空间。虚拟网卡需要成对创建，互相关联——就像交叉电缆一样：\n\n    root@w:~# ip link add veth0 type veth peer name veth1\n    root@w:~# ip link list\n    1: lo: mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    2: eth0: mtu 1500 qdisc pfifo_fast state UNKNOWN mode DEFAULT qlen 1000\n    link/ether 00:0c:29:65:25:9e brd ff:ff:ff:ff:ff:ff\n    3: veth1: mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000\n    link/ether d2:e9:52:18:19:ab brd ff:ff:ff:ff:ff:ff\n    4: veth0: mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000\n    link/ether f2:f7:5e:e2:22:ac brd ff:ff:ff:ff:ff:ff\n\n这个时候 `ifconfig -a` 命令也能显示新添加的 veth0 和 veth1 两块网卡。\n\n很好，现在将这两份块网卡加到命名空间中去。注意一下，下面的 `ip netns exec` 命令用于将后面的命令在命名空间中执行（LCTT注：下面的结果显示了在 ns1 这个网络命名空间中，只存在 lo 和 veth1 两块网卡）：\n\n    root@w:~# ip link set veth1 netns ns1\n    root@w:~# ip netns exec ns1 ip link list\n    1: lo: mtu 65536 qdisc noop state DOWN mode DEFAULT\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    3: veth1: mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000\n    link/ether d2:e9:52:18:19:ab brd ff:ff:ff:ff:ff:ff\n\n这个时候 `ifconfig -a` 命令只能显示 veth0，不能显示 veth1，因为后者现在在 ns1 命名空间中。\n\n如果想删除 veth0/veth1，可以执行下面的命令：\n\n    ip netns exec ns1 ip link del veth1\n\n我们可以为 veth0 分配 IP 地址：\n\n    ifconfig veth0 192.168.5.5/24\n\n在命名空间内为 veth1 分配 IP 地址：\n\n    ip netns exec ns1 ifconfig veth1 192.168.5.10/24 up\n\n在命名空间内外执行 `ip addr list` 命令：\n\n    root@w:~# ip addr list\n    1: lo: mtu 65536 qdisc noqueue state UNKNOWN\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n    inet6 ::1/128 scope host\n    valid_lft forever preferred_lft forever\n    2: eth0: mtu 1500 qdisc pfifo_fast state UNKNOWN qlen 1000\n    link/ether 00:0c:29:65:25:9e brd ff:ff:ff:ff:ff:ff\n    inet 192.168.3.122/24 brd 192.168.3.255 scope global eth0\n    inet6 fe80::20c:29ff:fe65:259e/64 scope link\n    valid_lft forever preferred_lft forever\n    6: veth0: mtu 1500 qdisc pfifo_fast state UP qlen 1000\n    link/ether 86:b2:c7:bd:c9:11 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.5.5/24 brd 192.168.5.255 scope global veth0\n    inet6 fe80::84b2:c7ff:febd:c911/64 scope link\n    valid_lft forever preferred_lft forever\n    root@w:~# ip netns exec ns1 ip addr list\n    1: lo: mtu 65536 qdisc noop state DOWN\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    5: veth1: mtu 1500 qdisc pfifo_fast state UP qlen 1000\n    link/ether 12:bd:b6:76:a6:eb brd ff:ff:ff:ff:ff:ff\n    inet 192.168.5.10/24 brd 192.168.5.255 scope global veth1\n    inet6 fe80::10bd:b6ff:fe76:a6eb/64 scope link\n    valid_lft forever preferred_lft forever\n\n在命名空间内外查看路由表：\n\n    root@w:~# ip route list\n    default via 192.168.3.1 dev eth0 proto static\n    192.168.3.0/24 dev eth0 proto kernel scope link src 192.168.3.122\n    192.168.5.0/24 dev veth0 proto kernel scope link src 192.168.5.5\n    root@w:~# ip netns exec ns1 ip route list\n    192.168.5.0/24 dev veth1 proto kernel scope link src 192.168.5.10 \n\n最后，将虚拟网卡连到物理网卡上，我们需要用到桥接。这里做的是将 veth0 桥接到 eth0，而 ns1 命名空间内则使用 DHCP 自动获取 IP 地址：\n\n    root@w:~# brctl addbr br0\n    root@w:~# brctl addif br0 eth0\n    root@w:~# brctl addif br0 veth0\n    root@w:~# ifconfig eth0 0.0.0.0\n    root@w:~# ifconfig veth0 0.0.0.0\n    root@w:~# dhclient br0\n    root@w:~# ip addr list br0\n    7: br0: mtu 1500 qdisc noqueue state UP\n    link/ether 00:0c:29:65:25:9e brd ff:ff:ff:ff:ff:ff\n    inet 192.168.3.122/24 brd 192.168.3.255 scope global br0\n    inet6 fe80::20c:29ff:fe65:259e/64 scope link\n    valid_lft forever preferred_lft forever\n\n为网桥 br0 分配的 IP 地址为192.168.3.122/24。接下来为命名空间分配地址：\n\n    root@w:~# ip netns exec ns1 dhclient veth1\n    root@w:~# ip netns exec ns1 ip addr list\n    1: lo: mtu 65536 qdisc noop state DOWN\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    5: veth1: mtu 1500 qdisc pfifo_fast state UP qlen 1000\n    link/ether 12:bd:b6:76:a6:eb brd ff:ff:ff:ff:ff:ff\n    inet 192.168.3.248/24 brd 192.168.3.255 scope global veth1\n    inet6 fe80::10bd:b6ff:fe76:a6eb/64 scope link\n    valid_lft forever preferred_lft forever\n\n现在， veth1 的 IP 被设置成 192.168.3.248/24 了。\n\n------\n原文：http://www.howtoforge.com/linux-namespaces \n\n作者： aziods","Tags":["linux"],"CreateTime":1425955411,"EditTime":1425955466,"UpdateTime":1425955411,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":413}