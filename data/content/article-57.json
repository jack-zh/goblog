{"Id":57,"Title":"Simple-clojure macros","Slug":"2014-10-28-5","Text":"    \n    ;; 使用defmacro定义宏。宏应该输出一个可以作为clojure代码演算的列表。\n    ;;\n    ;; 以下宏的效果和直接写(reverse \"Hello World\")一致。\n    \n    (defmacro my-first-macro []\n      (list reverse \"Hello World\"))\n    \n    ;; 使用macroexpand或macroexpand-1查看宏的结果。\n    ;;\n    ;; 注意，调用需要引用。\n    (macroexpand '(my-first-macro))\n    ;; -\u003e (#\u003ccore$reverse clojure.core$reverse@xxxxxxxx\u003e \"Hello World\")\n    \n    ;; 你可以直接eval macroexpand的结果\n    (eval (macroexpand '(my-first-macro)))\n    ; -\u003e (\\d \\l \\o \\r \\W \\space \\o \\l \\l \\e \\H)\n    \n    ;; 不过一般使用以下形式，更简短，更像函数：\n    (my-first-macro)  ; -\u003e (\\d \\l \\o \\r \\W \\space \\o \\l \\l \\e \\H)\n    \n    ;; 创建宏的时候可以使用更简短的引用形式来创建列表\n    (defmacro my-first-quoted-macro []\n      '(reverse \"Hello World\"))\n    \n    (macroexpand '(my-first-quoted-macro))\n    ;; -\u003e (reverse \"Hello World\")\n    ;; 注意reverse不再是一个函数对象，而是一个符号。\n    \n    ;; 宏可以传入参数。\n    (defmacro inc2 [arg]\n      (list + 2 arg))\n    \n    (inc2 2) ; -\u003e 4\n    \n    ;; 不过，如果你尝试配合使用引用列表，会导致错误，\n    ;; 因为参数也会被引用。\n    ;; 为了避免这个问题，clojure提供了引用宏的另一种方式：`\n    ;; 在`之内，你可以使用~获得外圈作用域的变量。\n    (defmacro inc2-quoted [arg]\n      `(+ 2 ~arg))\n    \n    (inc2-quoted 2)\n    \n    ;; 你可以使用通常的析构参数。用~@展开列表中的变量。\n    (defmacro unless [arg \u0026 body]\n      `(if (not ~arg)\n         (do ~@body))) ; 别忘了 do!\n    \n    (macroexpand '(unless true (reverse \"Hello World\")))\n    \n    ;; -\u003e\n    ;; (if (clojure.core/not true) (do (reverse \"Hello World\")))\n    \n    ;; 当第一个参数为假时，(unless)会演算、返回主体。 \n    ;; 否则返回nil。\n    \n    (unless true \"Hello\") ; -\u003e nil\n    (unless false \"Hello\") ; -\u003e \"Hello\"\n    \n    ;; 需要小心，宏会搞乱你的变量\n    (defmacro define-x []\n      '(do\n         (def x 2)\n         (list x)))\n    \n    (def x 4)\n    (define-x) ; -\u003e (2)\n    (list x) ; -\u003e (2)\n    \n    ;; 使用gensym来获得独有的标识符\n    (gensym 'x) ; -\u003e x1281 (or some such thing)\n    \n    (defmacro define-x-safely []\n      (let [sym (gensym 'x)]\n        `(do\n           (def ~sym 2)\n           (list ~sym))))\n    \n    (def x 4)\n    (define-x-safely) ; -\u003e (2)\n    (list x) ; -\u003e (4)\n    \n    ;; 你可以在 ` 中使用 # 为每个符号自动生成gensym\n    (defmacro define-x-hygenically []\n      `(do\n         (def x# 2)\n         (list x#)))\n    \n    (def x 4)\n    (define-x-hygenically) ; -\u003e (2)\n    (list x) ; -\u003e (4)\n    \n    ;; 通常会配合宏使用帮助函数。\n    ;; 让我们创建一些帮助函数来支持（无聊的）算术语法：\n    \n    (declare inline-2-helper)\n    (defn clean-arg [arg]\n      (if (seq? arg)\n        (inline-2-helper arg)\n        arg))\n    \n    (defn apply-arg\n      \"Given args [x (+ y)], return (+ x y)\"\n      [val [op arg]]\n      (list op val (clean-arg arg)))\n    \n    (defn inline-2-helper\n      [[arg1 \u0026 ops-and-args]]\n      (let [ops (partition 2 ops-and-args)]\n        (reduce apply-arg (clean-arg arg1) ops)))\n    \n    ;; 在创建宏前，我们可以先测试\n    (inline-2-helper '(a + (b - 2) - (c * 5))) ; -\u003e (- (+ a (- b 2)) (* c 5))\n    \n    ; 然而，如果我们希望它在编译期执行，就需要创建宏\n    (defmacro inline-2 [form]\n      (inline-2-helper form)))\n    \n    (macroexpand '(inline-2 (1 + (3 / 2) - (1 / 2) + 1)))\n    ; -\u003e (+ (- (+ 1 (/ 3 2)) (/ 1 2)) 1)\n    \n    (inline-2 (1 + (3 / 2) - (1 / 2) + 1))\n    ; -\u003e 3 (事实上，结果是3N, 因为数字被转化为带/的有理分数）\n","Tags":["clojure macros"," learnxinyminutes"],"CreateTime":1414472255,"EditTime":1414472255,"UpdateTime":1414472255,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":47}