{"Id":235,"Title":"递归与尾递归的讲解","Slug":"2015-07-02-1","Text":"\u003e 这篇文章的目的比较那个啥，原因是这样的，一大牛自吹：写C++或者Java写一年，没超过三个BUG，递归随便写。然后就探讨了一下递归的问题，在C++中，还有在Java中堆栈的问题和办法，发现他根本不懂，然后我说了下何为尾递归，他听说之后，只有一句，不用递归就算了，全改成循环。你想打他吗？使劲打，我不会拉你的。\n\n\n## 1、递归\n\n关于递归的概念，我们都不陌生。简单的来说递归就是一个函数直接或间接地调用自身，是为直接或间接递归\n递归一般用于解决三类问题：\n\n+ (1)数据的定义是按递归定义的。（Fibonacci函数，n的阶乘）\n+ (2)问题解法按递归实现。（回溯）\n+ (3)数据的结构形式是按递归定义的。（二叉树的遍历，图的搜索）\n\n记住一点，递归有线性递归（普通的递归）和尾递归。尾递归包含于递归之中，但有特殊的地方，关于为什么叫尾递归，一会再说。\n\n我们现在就实现一个递归的算法，用线性递归实现Fibonacci函数，程序如下所示：\n\n    // a.c：\n\n    int FibonacciRecursive(int n)\n    {\n            if( n \u003c 2)\n                    return n;\n            return (FibonacciRecursive(n-1)+FibonacciRecursive(n-2));\n    }\n\n看不懂的请举手，拖出去斩了。\n\n\n## 2、尾递归\n\n对递归有些了解的朋友一定猜得到，如果上面的N足够大，那么上面这个方法就可能会遇到栈溢出，也就是抛出StackOverflowError。这是由于每个线程在执行代码时，都会分配一定尺寸的栈空间（Windows系统中为8K-1M，Linux为8M，可以改变，后面附录会说），每次方法调用时都会在栈里储存一定信息（如参数、局部变量、返回地址等等），这些信息再少也会占用一定空间，成千上万个此类空间累积起来，自然就超过线程的栈空间了。不过这个问题并非无解，这就是我们的尾递归该出场了。\n\n顾名思义，尾递归就是从最后开始计算, 每递归一次就算出相应的结果, 也就是说, 函数调用出现在调用者函数的尾部, 因为是尾部, 所以根本没有必要去保存任何局部变量. 直接让被调用的函数返回时越过调用者, 返回到调用者的调用者去。尾递归就是把当前的运算结果（或路径）放在参数里传给下层函数，深层函数所面对的不是越来越简单的问题，而是越来越复杂的问题，因为参数里带有前面若干步的运算路径。\n\n如果你还看不懂我上面说的是什么意思，那我就搬出来尾调用来说话。\n\n##### 尾调用\n\n原因很多人的都知道，让我们先回顾一下函数调用的大概过程：\n\n+ 1）调用开始前，调用方（或函数本身）会往栈上压相关的数据，参数，返回地址，局部变量等。\n+ 2）执行函数。\n+ 3）清理栈上相关的数据，返回。\n\n尾调用的概念非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。记住啊，上面的 (FibonacciRecursive(n-1)+FibonacciRecursive(n-2))可不是偶，\n\n尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。\n\n好的，我们就用尾递归来实现一下上面的东西：\n\n    // b.c\n    int FibonacciTailRecursive(int n,int ret1,int ret2)\n    {\n            if(n==0)\n                    return ret1;\n            return FibonacciTailRecursive(n-1,ret2,ret1+ret2);\n    }\n\n## 3、对比与解释\n\n我知道你不信我上面说的，我们还是代码说话，汇编一下普通递归：\n\n            .file   \"a.c\"\n            .text\n            .globl  FibonacciRecursive\n            .type   FibonacciRecursive, @function\n    FibonacciRecursive:\n    .LFB0:\n            .cfi_startproc\n            pushq   %rbp\n            .cfi_def_cfa_offset 16\n            .cfi_offset 6, -16\n            movq    %rsp, %rbp\n            .cfi_def_cfa_register 6\n            pushq   %rbx\n            subq    $24, %rsp\n            .cfi_offset 3, -24\n            movl    %edi, -20(%rbp)\n            cmpl    $1, -20(%rbp)\n            jg      .L2\n            movl    -20(%rbp), %eax\n            jmp     .L3\n    .L2:\n            movl    -20(%rbp), %eax\n            subl    $1, %eax\n            movl    %eax, %edi\n            call    FibonacciRecursive\n            movl    %eax, %ebx\n            movl    -20(%rbp), %eax\n            subl    $2, %eax\n            movl    %eax, %edi\n            call    FibonacciRecursive\n            addl    %ebx, %eax\n    .L3:\n            addq    $24, %rsp\n            popq    %rbx\n            popq    %rbp\n            .cfi_def_cfa 7, 8\n            ret\n            .cfi_endproc\n    .LFE0:\n            .size   FibonacciRecursive, .-FibonacciRecursive\n            .ident  \"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04) 4.8.4\"\n            .section        .note.GNU-stack,\"\",@progbits\n\n再看一下优化过的尾递归：\n\n\n            .file   \"b.c\"\n            .text\n            .globl  FibonacciTailRecursive\n            .type   FibonacciTailRecursive, @function\n    FibonacciTailRecursive:\n    .LFB0:\n            .cfi_startproc\n            pushq   %rbp\n            .cfi_def_cfa_offset 16\n            .cfi_offset 6, -16\n            movq    %rsp, %rbp\n            .cfi_def_cfa_register 6\n            subq    $16, %rsp\n            movl    %edi, -4(%rbp)\n            movl    %esi, -8(%rbp)\n            movl    %edx, -12(%rbp)\n            cmpl    $0, -4(%rbp)\n            jne     .L2\n            movl    -8(%rbp), %eax\n            jmp     .L3\n    .L2:\n            movl    -12(%rbp), %eax\n            movl    -8(%rbp), %edx\n            addl    %eax, %edx\n            movl    -4(%rbp), %eax\n            leal    -1(%rax), %ecx\n            movl    -12(%rbp), %eax\n            movl    %eax, %esi\n            movl    %ecx, %edi\n            call    FibonacciTailRecursive\n    .L3:\n            leave\n            .cfi_def_cfa 7, 8\n            ret\n            .cfi_endproc\n    .LFE0:\n            .size   FibonacciTailRecursive, .-FibonacciTailRecursive\n            .ident  \"GCC: (Ubuntu 4.8.4-2ubuntu1~14.04) 4.8.4\"\n            .section        .note.GNU-stack,\"\",@progbits\n\n\n看见差别没有，** 调用栈 **\n\n而尾递归在某些语言的实现上，能避免上述所说的问题，注意是某些语言上，尾递归本身并不能消除函数调用栈过长的问题，那什么是尾递归呢？在上面写的一般递归函数 FibonacciRecursive() 中，我们可以看到，FibonacciRecursive(n)  是依赖于 FibonacciRecursive(n-1) 的，FibonacciRecursive(n) 只有在得到 FibonacciRecursive(n-1) 的结果之后，才能计算它自己的返回值，因此理论上，在 FibonacciRecursive(n-1) 返回之前，FibonacciRecursive(n)，不能结束返回。因此FibonacciRecursive(n)就必须保留它在栈上的数据，直到FibonacciRecursive(n-1)先返回，而尾递归的实现则可以在编译器的帮助下，消除这个限制\n\n\n## 4、然并卵\n\n通过上面的解释，我知道你认为你明白了我所说的，但是我不能确定你是不是意识到了我所表达的并不是你认为的意思。这句话的埋伏在这里：注意是某些语言上，尾递归本身并不能消除函数调用栈过长的问题。\n\n在Java Python JS等语言里面，普通的尾递归是没用的，为什么呢？这个你自己去探寻去吧，讲这个就没完没了了，可我们一般有自己的魔法，OK，一个一个的来。\n\n##### Python\n\n来个尾递归：\n\n    def Fib(n,b1=1,b2=1,c=3):\n        if n\u003c3:\n            return 1\n        else:\n            if n==c:\n                return b1+b2\n            else:\n                return Fib(n,b1=b2,b2=b1+b2,c=c+1)\n    Fib(10000)\n\n我猜你一定会遇到类似这样的东西：\n\n        return Fib(n,b1=b2,b2=b1+b2,c=c+1)\n      File \"1.py\", line 40, in Fib\n        return Fib(n,b1=b2,b2=b1+b2,c=c+1)\n      File \"1.py\", line 40, in Fib\n        return Fib(n,b1=b2,b2=b1+b2,c=c+1)\n      File \"1.py\", line 40, in Fib\n        return Fib(n,b1=b2,b2=b1+b2,c=c+1)\n      File \"1.py\", line 40, in Fib\n        return Fib(n,b1=b2,b2=b1+b2,c=c+1)\n      File \"1.py\", line 40, in Fib\n        return Fib(n,b1=b2,b2=b1+b2,c=c+1)\n      File \"1.py\", line 40, in Fib\n        return Fib(n,b1=b2,b2=b1+b2,c=c+1)\n      File \"1.py\", line 40, in Fib\n        return Fib(n,b1=b2,b2=b1+b2,c=c+1)\n      File \"1.py\", line 40, in Fib\n        return Fib(n,b1=b2,b2=b1+b2,c=c+1)\n    RuntimeError: maximum recursion depth exceeded\n\n来点黑魔法：\n\n    @tail_call_optimized\n    def Fib(n,b1=1,b2=1,c=3):\n        if n\u003c3:\n            return 1\n        else:\n            if n==c:\n                return b1+b2\n            else:\n                return Fib(n,b1=b2,b2=b1+b2,c=c+1)\n\n    Fib(10000)\n\n哈哈，海阔天空了，没问题。当然，为了探究这个装饰器干嘛了，查看一下他的源码：\n\n\n    import sys  \n\n    class TailRecurseException:  \n      def __init__(self, args, kwargs):  \n        self.args = args  \n        self.kwargs = kwargs  \n      \n    def tail_call_optimized(g):  \n      \"\"\"  \n      This function decorates a function with tail call  \n      optimization. It does this by throwing an exception  \n      if it is it's own grandparent, and catching such  \n      exceptions to fake the tail call optimization.  \n        \n      This function fails if the decorated  \n      function recurses in a non-tail context.  \n      \"\"\"  \n      def func(*args, **kwargs):  \n        f = sys._getframe()  \n        if f.f_back and f.f_back.f_back and f.f_back.f_back.f_code == f.f_code:  \n          raise TailRecurseException(args, kwargs)  \n        else:  \n          while 1:  \n            try:  \n              return g(*args, **kwargs)  \n            except TailRecurseException, e:  \n              args = e.args  \n              kwargs = e.kwargs  \n      func.__doc__ = g.__doc__  \n      return func\n\n我说，你是上帝派来玩我的吗？你家的内存不花钱？好吧，没有银弹。\n\n其他语言也有相对应的办法来解决，我这里就不搬过来了，我这里列举了几个相对熟悉一点的语言解决方案\n\n##### Java\n\n+ [Java 8 Lambda表达式对递归的优化-上 - 使用尾递归](http://blog.csdn.net/dm_vincent/article/details/40581859)\n+ [Java 8 Lambda表达式对递归的优化-下 - 使用备忘录模式(Memoization Pattern)](http://blog.csdn.net/dm_vincent/article/details/40615011)\n+ [关于Java中尾递归的优化](http://www.deepinmind.com/jvm/2014/04/16/tail-call-optimization-and-java.html)\n\n\n##### Clojure\n\n+ [详解Clojure的递归(上）—— 直接递归及优化](http://www.blogjava.net/killme2008/archive/2010/07/14/326129.html)\n+ [详解Clojure的递归（下）——相互递归和trampoline](http://www.blogjava.net/killme2008/archive/2010/08/22/329576.html)\n+ [Clojure的recur尾递归优化探秘](http://www.blogjava.net/killme2008/archive/2010/07/11/325766.html)\n\n## 5、附录\n\n##### C实现的一个尾递归实现\n\n    #include \u003cstdio.h\u003e\n    #include \u003cstdlib.h\u003e\n\n    typedef struct node\n    {\n      int data;\n      struct node* next;\n    }node,*linklist;\n\n    void InitLinklist(linklist* head)\n    {\n         if(*head != NULL)\n            free(*head);\n         *head = (node*)malloc(sizeof(node));\n         (*head)-\u003enext = NULL;\n    }\n\n    void InsertNode(linklist* head,int d)\n    {\n         node* newNode = (node*)malloc(sizeof(node));\n         newNode-\u003edata = d;\n         newNode-\u003enext = (*head)-\u003enext;\n         (*head)-\u003enext = newNode;\n    }\n\n    //直接递归求链表的长度 \n    int GetLengthRecursive(linklist head)\n    {\n        if(head-\u003enext == NULL)\n           return 0;\n        return (GetLengthRecursive(head-\u003enext) + 1);\n    }\n    //采用尾递归求链表的长度，借助变量acc保存当前链表的长度，不断的累加 \n    int GetLengthTailRecursive(linklist head,int *acc)\n    {\n        if(head-\u003enext == NULL)\n          return *acc;\n        *acc = *acc+1;\n        return GetLengthTailRecursive(head-\u003enext,acc);\n    }\n\n    void PrintLinklist(linklist head)\n    {\n         node* pnode = head-\u003enext;\n         while(pnode)\n         {\n            printf(\"%d-\u003e\",pnode-\u003edata);\n            pnode = pnode-\u003enext;\n         }\n         printf(\"-\u003eNULL\\n\");\n    }\n\n    int main()\n    {\n        linklist head = NULL;\n        int len = 0;\n        InitLinklist(\u0026head);\n        InsertNode(\u0026head,10);\n        InsertNode(\u0026head,21);\n        InsertNode(\u0026head,14);\n        InsertNode(\u0026head,19);\n        InsertNode(\u0026head,132);\n        InsertNode(\u0026head,192);\n        PrintLinklist(head);\n        printf(\"The length of linklist is: %d\\n\",GetLengthRecursive(head));\n        GetLengthTailRecursive(head,\u0026len);\n        printf(\"The length of linklist is: %d\\n\",len);\n        system(\"pause\");\n    }\n\n\n\n##### Linux下改变线程堆栈大小\n\nlinux查看修改线程默认栈空间大小 ulimit -s\n\n+ 1、通过命令 ulimit -s 查看linux的默认栈空间大小，默认情况下 为10240 即10M\n+ 2、通过命令 ulimit -s 设置大小值 临时改变栈空间大小：ulimit -s 102400， 即修改为100M\n+ 3、可以在/etc/rc.local 内 加入 ulimit -s 102400 则可以开机就设置栈空间大小\n+ 4、在/etc/security/limits.conf 中也可以改变栈空间大小\n\n重新登录，执行ulimit -s 即可看到改为102400 即100M\n\n##### 阮一峰的尾递归的讲解\n\nhttp://www.ruanyifeng.com/blog/2015/04/tail-call.html\n\n## 最后\n少用递归多用其他办法的确为最好的解决办法。这个是银弹。","Tags":[""],"CreateTime":1435828524,"EditTime":1437544138,"UpdateTime":1435828524,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":1631}