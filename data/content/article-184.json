{"Id":184,"Title":"Golang Internals, Part 3: The Linker, Object Files, and Relocations ","Slug":"2015-03-19-3","Text":"![](/static/upload/201503201741489.png)\n\nToday, I will speak about the Go linker, Go object files, and relocations.\n\nWhy should we care about these things? Well, if you want to learn the internals of any large project, the first thing you need to do is split it into components or modules. Second, you need to understand what interface these modules provide to each other. In Go, these high-level modules are the compiler, linker, and runtime. The interface that the compiler provides and the linker consumes is an object file and that’s where we will start our investigation today.\n \n ### Generating a Go object file\n\nLet’s do a practical experiment—write a super simple program, compile it, and see what object file will be produced. In my case, the program was as follows:\n\n    package main\n\n    func main() {\n\t    print(1)\n    }\n\n \nReally straightforward, isn’t it? Now we need to compile it:\n\n    go tool 6g test.go\n\n \nThis command produces the test.6 object file. To investigate its internal structure, we are going to use the [goobj](https://github.com/golang/go/tree/master/src/cmd/internal/goobj) library. It is employed internally in Go source code, mainly for implementing a set of unit tests that verifies whether object files are generated correctly in different situations. For this blog post, I wrote a very simple program that prints the output generated from the googj library to the console. You can take a look at the sources of this program [here](https://github.com/s-matyukevich/goobj_explorer).\n\nFirst of all, you need to download and install my program:\n\n    go get github.com/s-matyukevich/goobj_explorer\n\n \nThen execute the following command:\n\n    goobj_explorer -o test.6\n\n \nNow you should be able to see the goob.Package structure in your console.\n\nInvestigating the object file\n\nThe most interesting part of our object file is the Syms array. This is actually a symbol table. Everything that you define in your program—functions, global variables, types, constants, etc.—is written to this table. Let’s look at the entry that corresponds to the main function. (Note that I have cut the Reloc and Func fields from the output for now. We will discuss them later.)\n\n    \u0026goobj.Sym{\n                SymID: goobj.SymID{Name:\"main.main\", Version:0},\n                Kind:  1,\n                DupOK: false,\n                Size:  48,\n                Type:  goobj.SymID{},\n                Data:  goobj.Data{Offset:137, Size:44},\n                Reloc: ...,\n                Func:  ...,\n    }\n\nThe names of the fields in the goobj.Sum structure are pretty self-explanatory:\n\n|Field |Description|\n|:-|:-|\n|SumID| \tThe unique symbol ID that consists of the symbol’s name and version. Versions help to differentiate symbols with identical names.|\n|Kind |\tIndicates to what kind the symbol belongs (more details later).|\n|DupOK |\tThis field indicates whether duplicates (symbols with the same name) are allowed.|\n|Size |\tThe size of symbol data.|\n|Type |\tA reference to another symbol that represents a symbol type, if any.|\n|Data |\tContains binary data. This field has different meanings for symbols of different kinds, e.g., assembly code for functions, raw string content for string symbols, etc.|\n|Reloc |\tThe list of relocations (more details will be provided later)|\n|Func |\tContains special function metadata for function symbols (see more details below).|\n\nNow, let’s look at different kinds of symbols. All possible kinds of symbols are defined as constants in the goobj package (you can find them [here](https://github.com/golang/go/blob/master/src/cmd/internal/goobj/read.go#L30)). Below, I copied the first part of these constants:\n\n    const (\n      _ SymKind = iota\n\n      // readonly, executable\n      STEXT\n      SELFRXSECT\n\n      // readonly, non-executable\n      STYPE\n      SSTRING\n      SGOSTRING\n      SGOFUNC\n      SRODATA\n      SFUNCTAB\n      STYPELINK\n      SSYMTAB // TODO: move to unmapped section\n      SPCLNTAB\n      SELFROSECT\n      ...\n\nAs we can see, the main.main symbol belongs to kind 1 that corresponds to the STEXT constant. STEXT is a symbol that contains executable code. Now, let’s look at the Reloc array. It consists of the following structs:\n\n    type Reloc struct {\n      Offset int\n      Size   int\n      Sym    SymID\n      Add    int\n      Type int\n    }\n\nEach relocation implies that the bytes situated at the [Offset, Offset+Size] interval should be replaced with a specified address. This address is calculated by summing up the location of the Sym symbol with the Add number of bytes.\n\nUnderstanding relocations\n\nNow let’s use an example and see how relocations work. To do this, we need to compile our program using the -S switch that will print the generated assembly code:\n\n    go tool 6g -S test.go\n \nLet’s look through the assembler and try to find the main function.\n\n    \"\".main t=1 size=48 value=0 args=0x0 locals=0x8\n      0x0000 00000 (test.go:3)  TEXT  \"\".main+0(SB),$8-0\n      0x0000 00000 (test.go:3)  MOVQ  (TLS),CX\n      0x0009 00009 (test.go:3)  CMPQ  SP,16(CX)\n      0x000d 00013 (test.go:3)  JHI ,22\n      0x000f 00015 (test.go:3)  CALL  ,runtime.morestack_noctxt(SB)\n      0x0014 00020 (test.go:3)  JMP ,0\n      0x0016 00022 (test.go:3)  SUBQ  $8,SP\n      0x001a 00026 (test.go:3)  FUNCDATA  $0,gclocals·3280bececceccd33cb74587feedb1f9f+0(SB)\n      0x001a 00026 (test.go:3)  FUNCDATA  $1,gclocals·3280bececceccd33cb74587feedb1f9f+0(SB)\n      0x001a 00026 (test.go:4)  MOVQ  $1,(SP)\n      0x0022 00034 (test.go:4)  PCDATA  $0,$0\n      0x0022 00034 (test.go:4)  CALL  ,runtime.printint(SB)\n      0x0027 00039 (test.go:5)  ADDQ  $8,SP\n      0x002b 00043 (test.go:5)  RET ,\n\n     \nIn later blog posts, we’ll have a closer look at this code and try to understand how the Go runtime works. For now, we are interested in the following line:\n\n    0x0022 00034 (test.go:4)\tCALL\t,runtime.printint(SB)\n \nThis command is located at an offset of 0×0022 (in hex) or 00034 (decimal) within the function data. This line is actually responsible for calling the runtime.printint function. The issue is that the compiler does not know the exact address of the runtime.printint function during compilation. This function is located in a different object file the compiler knows nothing about. In such cases, it uses relocations. Below is the exact relocation that corresponds to this method call (I copied it from the first output of the goobj_explorer utility):\n\n    {\n                        Offset: 35,\n                        Size:   4,\n                        Sym:    goobj.SymID{Name:\"runtime.printint\", Version:0},\n                        Add:    0,\n                        Type:   3,\n                    },\n\n### How the linker operates\n\nNow that we understand this, we can figure out how the linker works. The following schema is very simplified, but it reflects the main idea:\n\n+ The linker gathers all the symbols from all the packages that are referenced from the main package and loads them into one big byte array (or a binary image).\n+ For each symbol, the linker calculates an address in this image.\n+ Then it applies the relocations defined for every symbol. It is easy now, since the linker knows the exact addresses of all other symbols referenced from those relocations.\n+ The linker prepares all the headers necessary for the [Executable and Linkable (ELF)](http://en.wikipedia.org/wiki/Executable_and_Linkable_Format) format (on Linux) or the [Portable Executable (PE)](http://en.wikipedia.org/wiki/Portable_Executable) format (on Windows). Then, it generates an executable file with the results.\n\n### Understanding TLS\n\nA careful reader will notice a strange relocation in the output of the goobj_explorer utility for the main method. It doesn’t correspond to any method call and even points to an empty symbol:\n\n    {\n                        Offset: 5,\n                        Size:   4,\n                        Sym:    goobj.SymID{},\n                        Add:    0,\n                        Type:   9,\n                    },\n\n \nSo, what does this relocation do? We can see that it has an offset of 5 bytes and its size is 4 bytes. At this offset, there is a command:\n\n    0x0000 00000 (test.go:3)\tMOVQ\t(TLS),CX\n\n \nIt starts at an offset of 0 and occupies 9 bytes (since the next command starts at an offset of 9 bytes). We can guess that this relocation replaces the strange (TLS) statement with some address, but what is TLS and what address does it use?\n \nTLS is an abbreviation for Thread Local Storage. This technology is used in many programming languages (more details [here](http://en.wikipedia.org/wiki/Thread-local_storage)). In short, it enables us to have a variable that points to different memory locations when used by different threads.\n \nIn Go, TLS is used to store a pointer to the G structure that contains internal details of a particular Go routine (more details on this in later blog posts). So, there is a variable that—when accessed from different Go routines—always points to a structure with internal details of this Go routine. The location of this variable is known to the linker and this variable is exactly what was moved to the CX register in the previous command. TLS can be implemented differently for different architectures. For AMD64, TLS is implemented via the FS register, so our previous command is translated into MOVQ FS, CX.\n \nTo end our discussion on relocations, I am going to show you the enumerated type (enum) that contains all the different types of relocations:\n\n    // Reloc.type\n    enum\n    {\n      R_ADDR = 1,\n      R_SIZE,\n      R_CALL, // relocation for direct PC-relative call\n      R_CALLARM, // relocation for ARM direct call\n      R_CALLIND, // marker for indirect call (no actual relocating necessary)\n      R_CONST,\n      R_PCREL,\n      R_TLS,\n      R_TLS_LE, // TLS local exec offset from TLS segment register\n      R_TLS_IE, // TLS initial exec offset from TLS base pointer\n      R_GOTOFF,\n      R_PLT0,\n      R_PLT1,\n      R_PLT2,\n      R_USEFIELD,\n    };\n\nAs you can see from this enum, relocation type 3 is R_CALL and relocation type 9 is R_TLS. These enum names perfectly explain the behaviour that we discussed previously.\n \n### More on Go object files\n\nIn the next post, we’ll continue our discussion on object files. I will also provide more information necessary for you to move forward and understand how the Go runtime works. If you have any questions, feel free to ask them in the comments.\n\n**About the author: **Sergey Matyukevich is a Cloud Engineer and Go Developer at Altoros. With 6+ years in software engineering, he is an expert in cloud automation and designing architectures for complex cloud-based systems. An active member of the Go community, Sergey is a frequent contributor to open-source projects, such as Ubuntu and Juju Charms.\n\nThe original address：http://blog.altoros.com/golang-internals-part-3-the-linker-and-object-files.html","Tags":["golang"],"CreateTime":1426740400,"EditTime":1426844576,"UpdateTime":1426740400,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":29}