{"Id":243,"Title":"Elixir入门教程\u003c中\u003e","Slug":"2015-10-09-1","Text":"\u003cdiv id=\"ztoc\"\u003e\u003c/div\u003e\n\n## 7-键值列表-图-字典\n\n\n到目前还没有讲到任何关联性数据结构，即那种可以将一个或几个值关联到一个key上。\n不同语言有不同的叫法，如字典，哈希，关联数组，图，等等。\n\nElixir中有两种主要的关联性结构：键值列表（keyword list）和图（map）。\n\n### 7.1-键值列表\n在很多函数式语言中，常用二元元组的列表来表示关联性数据结构。\n在Elixir中也是这样。当我们有了一个元组（不一定仅有两个元素的元组）的列表，并且每个元组的第一个元素是个**原子**，\n那就称之为键值列表：\n```\niex\u003e list = [{:a, 1}, {:b, 2}]\n[a: 1, b: 2]\niex\u003e list == [a: 1, b: 2]\ntrue\niex\u003e list[:a]\n1\n```\n\u003e当原子key和关联的值之间没有逗号分隔时，可以把原子的冒号拿到字母的后面。这时，原子与后面的数值之间要有一个空格。\n\n如你所见，Elixir使用比较特殊的语法来定义这样的列表，但实际上它们会映射到一个元组列表。\n因为它们是简单的列表而已，所有针对列表的操作，键值列表也可以用。\n\n比如，可以用++运算符为列表添加元素：\n```\niex\u003e list ++ [c: 3]\n[a: 1, b: 2, c: 3]\niex\u003e [a: 0] ++ list\n[a: 0, a: 1, b: 2]\n```\n上面例子中重复出现了```:a```这个key，这是允许的。\n以这个key取值时，取回来的是第一个找到的（因为有序）：\n```\niex\u003e new_list = [a: 0] ++ list\n[a: 0, a: 1, b: 2]\niex\u003e new_list[:a]\n0\n```\n\n键值列表十分重要，它有两大特点：\n- 有序\n- key可以重复（！仔细看上面两个示例）\n\n例如，[Ecto库](https://github.com/elixir-lang/ecto)使用这两个特点写出了精巧的DSL（用来写数据库query）：\n```\nquery = from w in Weather,\n          where: w.prcp \u003e 0,\n          where: w.temp \u003c 20,\n        select: w\n```\n\n这些特性使得键值列表成了Elixir中为函数提供额外选项的默认手段。\n在第5章我们讨论了```if/2```宏，提到了下方的语法：\n```\niex\u003e if false, do: :this, else: :that\n:that\n```\n\ndo: \u003cblock\u003e和else: \u003cblock\u003e 就是键值列表！事实上代码等同于：\n```\niex\u003e if(false, [do: :this, else: :that])\n:that\n```\n\n当键值列表是函数最后一个参数时，方括号就成了可选的。\n\n为了操作关键字列表，Elixir提供了[键值（keyword）模块](http://elixir-lang.org/docs/stable/elixir/Keyword.html)。\n记住，键值列表就是简单的列表，和列表一样提供了线性的性能。列表越长，获取长度或找到一个键值的速度越慢。\n因此，关键字列表在Elixir中一般就作为函数调用的可选项。\n如果你要存储大量数据，并且保证一个键只对应最多一个值，那就使用图。\n\n对键值列表做模式匹配：\n```elixir\niex\u003e [a: a] = [a: 1]\n[a: 1]\niex\u003e a\n1\niex\u003e [a: a] = [a: 1, b: 2]\n** (MatchError) no match of right hand side value: [a: 1, b: 2]\niex\u003e [b: b, a: a] = [a: 1, b: 2]\n** (MatchError) no match of right hand side value: [a: 1, b: 2]\n```\n尽管如此，对列表使用模式匹配很少用到。因为不但要元素个数相等，顺序还要匹配。\n\n### 7.2-图（maps）\n无论何时想用键-值结构，图都应该是你的第一选择。Elixir中，用```%{}```定义图：\n```elixir\niex\u003e map = %{:a =\u003e 1, 2 =\u003e :b}\n%{2 =\u003e :b, :a =\u003e 1}\niex\u003e map[:a]\n1\niex\u003e map[2]\n:b\n```\n\n和键值列表对比，图有两主要区别：\n- 图允许任何类型值作为键\n- 图的键没有顺序\n\n如果你向图添加一个已有的键，将会覆盖之前的键-值对：\n```elixir\niex\u003e %{1 =\u003e 1, 1 =\u003e 2}\n%{1 =\u003e 2}\n```\n\n如果图中的键都是原子，那么你也可以用键值列表中的一些语法：\n```elixir\niex\u003e map = %{a: 1, b: 2}\n%{a: 1, b: 2}\n```\n\n对比键值列表，图的模式匹配很是有用：\n```elixir\niex\u003e %{} = %{:a =\u003e 1, 2 =\u003e :b}\n%{:a =\u003e 1, 2 =\u003e :b}\niex\u003e %{:a =\u003e a} = %{:a =\u003e 1, 2 =\u003e :b}\n%{:a =\u003e 1, 2 =\u003e :b}\niex\u003e a\n1\niex\u003e %{:c =\u003e c} = %{:a =\u003e 1, 2 =\u003e :b}\n** (MatchError) no match of right hand side value: %{2 =\u003e :b, :a =\u003e 1}\n```\n如上所示，图A与另一个图B做匹配。图B中只要包含有图A的键，那么两个图就能匹配上。若图A是个空的，那么任意图B都能匹配上。\n但是如果图B里不包含图A的键，那就匹配失败了。\n\n图还有个有趣的功能：它提供了特殊的语法来修改和访问原子键：\n```\niex\u003e map = %{:a =\u003e 1, 2 =\u003e :b}\n%{:a =\u003e 1, 2 =\u003e :b}\niex\u003e map.a\n1\niex\u003e %{map | :a =\u003e 2}\n%{:a =\u003e 2, 2 =\u003e :b}\niex\u003e %{map | :c =\u003e 3}\n** (ArgumentError) argument error\n```\n\n使用上面两种语法要求的前提是所给的键是切实存在的。最后一条语句错误的原因就是键```:c```不存在。\n\n未来几章中我们还将讨论结构体（structs）。结构体提供了编译时的保证，它是Elixir多态的基础。\n结构体是基于图的，上面例子提到的修改键值的前提就变得十分重要。\n\n[图模块](http://elixir-lang.org/docs/stable/elixir/Map.html)提供了许多关于图的操作。它提供了与键值列表许多相似的API，因为这两个数据结构都实现了字典的行为。\n\n\u003e图是最近连同[EEP 43](http://www.erlang.org/eeps/eep-0043.html)被引入Erlang虚拟机的。\nErlang 17提供了EEP的部分实现，只支持_一小部分_图功能。\n这意味着图仅在存储不多的键时，图的性能还行。为了解决这个问题，Elixir还提供了[HashDict模块](http://elixir-lang.org/docs/stable/elixir/HashDict.html)该模块提供了一个字典来支持大量的键，并且性能不错。\n\n### 7.3-字典（Dicts）\nElixir中，键值列表和图都被称作字典。换句话说，一个字典就像一个接口（在Elixir中称之为行为behaviour）。\n键值列表和图模块实现了该接口。\n\n这个接口定义于[Dict模块](http://elixir-lang.org/docs/stable/elixir/Dict.html)，该模块还提供了底层实现的一个API：\n```\niex\u003e keyword = []\n[]\niex\u003e map = %{}\n%{}\niex\u003e Dict.put(keyword, :a, 1)\n[a: 1]\niex\u003e Dict.put(map, :a, 1)\n%{a: 1}\n```\n\n字典模块允许开发者实现他们自己的字典形式，提供一些特殊的功能，然后联系到现存的的Elixir代码中去。\n字典模块还提供了所有字典类型都可以使用的函数。如，```Dicr.equal?/2```可以比较两个字典类型（可以是不同的实现）。\n\n你会疑惑些程序时用keyword，Map还是Dict模块呢？答案是：看情况。\n\n如果你的代码期望接受一个关键字作为参数，那么使用简直列表模块。如果你想操作一个图，那就使用图模块。\n如果你想你的API对所有字典类型的实现都有用，那就使用字典模块（确保以不同的实现作为参数测试一下）。\n\n## 8-模块\n\n\nElixir中我们把许多函数组织成一个模块。我们在前几章已经提到了许多模块，如[String模块](http://elixir-lang.org/docs/stable/elixir/String.html)：\n```\niex\u003e String.length \"hello\"\n5\n```\n\n创建自己的模块，用```defmodule```宏。用```def```宏在其中定义函数：\n```\niex\u003e defmodule Math do\n...\u003e   def sum(a, b) do\n...\u003e     a + b\n...\u003e   end\n...\u003e end\n\niex\u003e Math.sum(1, 2)\n3\n```\n\u003e像ruby一样，模块名大写起头\n\n### 8.1-编译\n通常把模块写进文件，这样可以编译和重用。假如文件```math.ex```有如下内容：\n```\ndefmodule Math do\n  def sum(a, b) do\n    a + b\n  end\nend\n```\n\n这个文件可以用```elixirc```进行编译：\n```\n$ elixirc math.ex\n```\n\n这将生成名为```Elixir.Math.beam```的bytecode文件。\n如果这时再启动iex，那么这个模块就已经可以用了（假如在含有该编译文件的目录启动iex）：\n```\niex\u003e Math.sum(1, 2)\n3\n```\n\nElixir工程通常组织在三个文件夹里：\n- ebin，包括编译后的字节码\n- lib，包括Elixir代码（.ex文件）\n- test，测试代码（.exs文件）\n\u003cbr/\u003e\n\n实际项目中，构建工具Mix会负责编译，并且设置好正确的路径。\n而为了学习方便，Elixir也提供了脚本模式，可以更灵活而不用编译。\n\n### 8.2-脚本模式\n除了.ex文件，Elixir还支持.exs脚本文件。Elixir对两种文件一视同仁，唯一区别是.ex文件有待编译，\n而.exs文件用来作脚本执行，不需要编译。例如，如下创建名为math.exs的文件：\n```\ndefmodule Math do\n  def sum(a, b) do\n    a + b\n  end\nend\n\nIO.puts Math.sum(1, 2)\n```\n执行之：\n```\n$ elixir math.exs\n```\n这中情况，文件将在内存中编译和执行，打印出“3”作为结果。没有比特码文件生成。\n后文中（为了学习和练习方便），推荐使用脚本模式执行学到的代码。\n\n### 8.3-命名函数\n在某模块中，我们可以用```def/2```宏定义函数，用```defp/2```定义私有函数。\n用```def/2```定义的函数可以被其它模块中的代码使用，而私有函数仅在定义它的模块内使用。\n```\ndefmodule Math do\n  def sum(a, b) do\n    do_sum(a, b)\n  end\n\n  defp do_sum(a, b) do\n    a + b\n  end\nend\n\nMath.sum(1, 2)    #=\u003e 3\nMath.do_sum(1, 2) #=\u003e ** (UndefinedFunctionError)\n```\n\n函数声明也支持使用卫兵或多个子句。\n如果一个函数有好多子句，Elixir会匹配每一个子句直到找到一个匹配的。\n下面例子检查参数是否是数字：\n```\ndefmodule Math do\n  def zero?(0) do\n    true\n  end\n\n  def zero?(x) when is_number(x) do\n    false\n  end\nend\n\nMath.zero?(0)  #=\u003e true\nMath.zero?(1)  #=\u003e false\n\nMath.zero?([1,2,3])\n#=\u003e ** (FunctionClauseError)\n```\n如果没有一个子句能匹配参数，会报错。\n\n### 8.4-函数捕捉\n本教程中提到函数，都是用```name/arity```的形式描述。这种表示方法可以被用来获取一个命名函数（赋给一个函数型变量）。\n下面用iex执行一下上文定义的math.exs文件：\n```\n$ iex math.exs\n```\n\n```\niex\u003e Math.zero?(0)\ntrue\niex\u003e fun = \u0026Math.zero?/1\n\u0026Math.zero?/1\niex\u003e is_function fun\ntrue\niex\u003e fun.(0)\ntrue\n```\n用```\u0026\u003cfunction notation\u003e```从函数名捕捉一个函数，它本身代表该函数值（函数类型的值）。\n它可以不必赋给一个变量，直接用括号来使用该函数。\n本地定义的，或者已导入的函数，比如is_function/1，可以不前缀模块名：\n```\niex\u003e \u0026is_function/1\n\u0026:erlang.is_function/1\niex\u003e (\u0026is_function/1).(fun)\ntrue\n```\n\n这种语法还可以作为快捷方式使用与创建函数：\n```\niex\u003e fun = \u0026(\u00261 + 1)\n#Function\u003c6.71889879/1 in :erl_eval.expr/5\u003e\niex\u003e fun.(1)\n2\n```\n\n`\u00261` 表示传给该函数的第一个参数。上面例子中，`\u0026(\u00261+1)`其实等同于`n x-\u003ex+1 end`。\n在创建短小函数时，这个很方便。想要了解更多关于`\u0026`捕捉操作符，参考[Kernel.SpecialForms文档](http://elixir-lang.org/docs/stable/elixir/Kernel.SpecialForms.html)。\n\n### 8.5-默认参数\n\nElixir中，命名函数也支持默认参数：\n\n```\ndefmodule Concat do\n  def join(a, b, sep \\\\ \" \") do\n    a \u003c\u003e sep \u003c\u003e b\n  end\nend\n\nIO.puts Concat.join(\"Hello\", \"world\")      #=\u003e Hello world\nIO.puts Concat.join(\"Hello\", \"world\", \"_\") #=\u003e Hello_world\n```\n\n任何表达式都可以作为默认参数，但是只在函数调用时**用到了**才被执行（函数定义时，那些表达式只是存在那儿，不执行；函数调用时，没有用到默认值，也不执行）。\n```\ndefmodule DefaultTest do\n  def dowork(x \\\\ IO.puts \"hello\") do\n    x\n  end\nend\n```\n\n```\niex\u003e DefaultTest.dowork 123\n123\niex\u003e DefaultTest.dowork\nhello\n:ok\n```\n\n如果有默认参数值的函数有了多条子句，推荐先定义一个函数头（无具体函数体）仅为了声明这些默认值：\n```\ndefmodule Concat do\n  def join(a, b \\\\ nil, sep \\\\ \" \")\n\n  def join(a, b, _sep) when nil?(b) do\n    a\n  end\n\n  def join(a, b, sep) do\n    a \u003c\u003e sep \u003c\u003e b\n  end\nend\n\nIO.puts Concat.join(\"Hello\", \"world\")      #=\u003e Hello world\nIO.puts Concat.join(\"Hello\", \"world\", \"_\") #=\u003e Hello_world\nIO.puts Concat.join(\"Hello\")               #=\u003e Hello\n```\n\n使用默认值时，注意对函数重载会有一定影响。考虑下面例子：\n```\ndefmodule Concat do\n  def join(a, b) do\n    IO.puts \"***First join\"\n    a \u003c\u003e b\n  end\n\n  def join(a, b, sep \\\\ \" \") do\n    IO.puts \"***Second join\"\n    a \u003c\u003e sep \u003c\u003e b\n  end\nend\n```\n\n如果将以上代码保存在文件“concat.ex”中并编译，Elixir会报出以下警告：\n```\nconcat.ex:7: this clause cannot match because a previous clause at line 2 always matches\n```\n\n编译器是在警告我们，在使用两个参数调用```join```函数时，总使用第一个函数定义。\n只有使用三个参数调用时，才会使用第二个定义：\n\n```\n$ iex concat.exs\n```\n\n```\niex\u003e Concat.join \"Hello\", \"world\"\n***First join\n\"Helloworld\"\niex\u003e Concat.join \"Hello\", \"world\", \"_\"\n***Second join\n\"Hello_world\"\n```\n\n后面几章将介绍使用命名函数来做循环，如何从别的模块中导入函数，以及模块的属性等。\n\n## 9-递归\n\n因为在Elixir中（或所有函数式语言中），数据有不变性（immutability），因此在写循环时与传统的命令式（imperative）语言有所不同。\n例如某命令式语言的循环可以这么写：\n```\nfor(i = 0; i \u003c array.length; i++) {\n  array[i] = array[i] * 2\n}\n```\n\n上面例子中，我们改变了```array```，以及辅助变量```i```的值。这在Elixir中是不可能的。\n尽管如此，函数式语言却依赖于某种形式的循环---递归：一个函数可以不断地被递归调用，直到某条件满足才停止。\n考虑下面的例子：打印一个字符串若干次：\n```\ndefmodule Recursion do\n  def print_multiple_times(msg, n) when n \u003c= 1 do\n    IO.puts msg\n  end\n\n  def print_multiple_times(msg, n) do\n    IO.puts msg\n    print_multiple_times(msg, n - 1)\n  end\nend\n\nRecursion.print_multiple_times(\"Hello!\", 3)\n# Hello!\n# Hello!\n# Hello!\n```\n\n一个函数可以有许多子句（上面看起来定义了两个函数，但卫兵条件不同，可以看作同一个函数的两个子句）。\n当参数匹配该子句的模式，且该子句的卫兵表达式返回true，才会执行该子句内容。\n上面例子中，当```print_multiple_times/2```第一次调用时，n的值是3。\n\n第一个子句有卫兵表达式要求n必须小于等于1。因为不满足此条件，代码找该函数的下一条子句。\n\n参数匹配第二个子句，且该子句也没有卫兵表达式，因此得以执行。\n首先打印```msg```，然后调用自身并传递第二个参数```n-1```(=2)。\n这样```msg```又被打印一次，之后调用自身并传递参数```n-1```(=1)。\n\n这个时候，n满足第一个函数子句条件。遂执行该子句，打印```msg```，然后就此结束。\n\n我们称例子中第一个函数子句这种子句为“基本情形”。\n基本情形总是最后被执行，因为起初通常都不匹配执行条件，程序而转去执行其它子句。\n但是，每执行一次其它子句，条件都向这基本情形靠拢一点，直到最终回到基本情形处执行代码。\n\n下面我们使用递归的威力来计算列表元素求和：\n```\ndefmodule Math do\n  def sum_list([head|tail], accumulator) do\n    sum_list(tail, head + accumulator)\n  end\n\n  def sum_list([], accumulator) do\n    accumulator\n  end\nend\n\nMath.sum_list([1, 2, 3], 0) #=\u003e 6\n```\n\n我们首先用列表[1,2,3]和初值0作为参数调用函数，程序将逐个匹配各子句的条件，执行第一个符合要求的子句。\n于是，参数首先满足例子中定义的第一个子句。参数匹配使得head = 1，tail = [2,3]，accumulator = 0。\n\n然后执行该字据内容，把head + accumulator作为第二个参数，连带去掉了head的列表做第一个参数，再次调用函数本身。\n如此循环，每次都把新传入的列表的head加到accumulator上，传递去掉了head的列表。\n最终传递的列表为空，符合第二个子句的条件，执行该子句，返回accumulator的值6。\n\n几次函数调用情况如下：\n```\nsum_list [1, 2, 3], 0\nsum_list [2, 3], 1\nsum_list [3], 3\nsum_list [], 6\n```\n\n这种使用列表做参数，每次削减一点列表的递归方式，称为“递减”算法，是函数式编程的核心。\n\u003cbr/\u003e\n如果我们想给每个列表元素加倍呢？：\n```\ndefmodule Math do\n  def double_each([head|tail]) do\n    [head * 2| double_each(tail)]\n  end\n\n  def double_each([]) do\n    []\n  end\nend\n\nMath.double_each([1, 2, 3]) #=\u003e [2, 4, 6]\n```\n\n此处使用了递归来遍历列表元素，使它们加倍，然后返回新的列表。\n这样以列表为参数，递归处理其每个元素的方式，称为“映射（map）”算法。\n\u003cbr/\u003e\n\n递归和列尾调用优化（tail call optimization）是Elixir中重要的部分，通常用来创建循环。\n尽管如此，在Elixir中你很少会使用以上方式来递归地处理列表。\n\n下一章要介绍的[Enum模块](http://elixir-lang.org/docs/stable/elixir/Enum.html)为操作列表提供了诸多方便。\n比如，下面例子：\n```\niex\u003e Enum.reduce([1, 2, 3], 0, fn(x, acc) -\u003e x + acc end)\n6\niex\u003e Enum.map([1, 2, 3], fn(x) -\u003e x * 2 end)\n[2, 4, 6]\n```\n\n或者，使用捕捉的语法：\n```\niex\u003e Enum.reduce([1, 2, 3], 0, \u0026+/2)\n6\niex\u003e Enum.map([1, 2, 3], \u0026(\u00261 * 2))\n[2, 4, 6]\n```\n\n## 10-枚举类型和流\n\n\n### 10.1-枚举类型\nElixir提供了枚举类型（enumerables）的概念，使用[Enum模块]()操作它们。我们已经介绍过两种枚举类型：列表和图。\n```\niex\u003e Enum.map([1, 2, 3], fn x -\u003e x * 2 end)\n[2, 4, 6]\niex\u003e Enum.map(%{1 =\u003e 2, 3 =\u003e 4}, fn {k, v} -\u003e k * v end)\n[2, 12]\n```\n\nEnum模块为枚举类型提供了大量函数来变化，排序，分组，过滤和读取元素。\nEnum模块是开发者最常用的模块之一。\n\u003cbr/\u003e\n\nElixir还提供了范围（range）：\n```\niex\u003e Enum.map(1..3, fn x -\u003e x * 2 end)\n[2, 4, 6]\niex\u003e Enum.reduce(1..3, 0, \u0026+/2)\n6\n```\n\n因为Enum模块在设计时为了适用于不同的数据类型，所以它的API被限制为多数据类型适用的函数。\n为了实现某些操作，你可能需要针对某类型使用某特定的模块。\n比如，如果你要在列表中某特定位置插入一个元素，要用[List模块](http://elixir-lang.org/docs/stable/elixir/List.html)中的List.insert_at/3函数。而向某些类型内插入数据是没意义的，比如范围。\n\nEnum中的函数是多态的，因为它们能处理不同的数据类型。\n尤其是，模块中可以适用于不同数据类型的函数，它们是遵循了[Enumerable协议](http://elixir-lang.org/docs/stable/elixir/Enumerable.html)。\n我们在后面章节中将讨论这个协议。下面将介绍一种特殊的枚举类型：流。\n\n### 10.2-积极vs懒惰\nEnum模块中的所有函数都是**积极**的。多数函数接受一个枚举类型，并返回一个列表：\n```\niex\u003e odd? = \u0026(rem(\u00261, 2) != 0)\n#Function\u003c6.80484245/1 in :erl_eval.expr/5\u003e\niex\u003e Enum.filter(1..3, odd?)\n[1, 3]\n```\n\n这意味着当使用Enum进行多种操作时，每次操作都生成一个中间列表，直到得出最终结果：\n```\niex\u003e 1..100_000 |\u003e Enum.map(\u0026(\u00261 * 3)) |\u003e Enum.filter(odd?) |\u003e Enum.sum\n7500000000\n```\n\n上面例子是一个含有多个操作的管道。从一个范围开始，然后给每个元素乘以3。\n该操作将会生成的中间结果是含有100000个元素的列表。\n然后我们过滤掉所有偶数，产生又一个新中间结果：一个50000元素的列表。\n最后求和，返回结果。\n\u003e这个符号的用法似乎和F#中的不一样啊...\n\n作为一个替代，[流模块](http://elixir-lang.org/docs/stable/elixir/Stream.html)提供了懒惰的实现：\n```\niex\u003e 1..100_000 |\u003e Stream.map(\u0026(\u00261 * 3)) |\u003e Stream.filter(odd?) |\u003e Enum.sum\n7500000000\n```\n\n与之前Enum的处理不同，流先创建了一系列的计算操作。然后仅当我们把它传递给Enum模块，它才会被调用。流这种方式适用于处理大量的（甚至是无限的）数据集合。\n\n### 10.3-流\n流是懒惰的，比起Enum来说。\n分步分析一下上面的例子，你会发现流与Enum的区别：\n```\niex\u003e 1..100_000 |\u003e Stream.map(\u0026(\u00261 * 3))\n#Stream\u003c[enum: 1..100000, funs: [#Function\u003c34.16982430/1 in Stream.map/2\u003e]]\u003e\n```\n流操作返回的不是结果列表，而是一个数据类型---流，一个表示要对范围1..100000使用map操作的动作。\n\n另外，当我们用管道连接多个流操作时：\n```\niex\u003e 1..100_000 |\u003e Stream.map(\u0026(\u00261 * 3)) |\u003e Stream.filter(odd?)\n#Stream\u003c[enum: 1..100000, funs: [...]]\u003e\n```\n\n流模块中的函数接受任何枚举类型为参数，返回一个流。\n流模块还提供了创建流（甚至是无限操作的流）的函数。\n例如，```Stream.cycle/1```可以用来创建一个流，它能无限周期性枚举所提供的参数（小心使用）：\n```\niex\u003e stream = Stream.cycle([1, 2, 3])\n#Function\u003c15.16982430/2 in Stream.cycle/1\u003e\niex\u003e Enum.take(stream, 10)\n[1, 2, 3, 1, 2, 3, 1, 2, 3, 1]\n```\n\n另一方面，```Stream.unfold/2```函数可以生成给定的有限值：\n```\niex\u003e stream = Stream.unfold(\"hełło\", \u0026String.next_codepoint/1)\n#Function\u003c39.75994740/2 in Stream.unfold/2\u003e\niex\u003e Enum.take(stream, 3)\n[\"h\", \"e\", \"ł\"]\n```\n\n另一个有趣的函数是```Stream.resource/3```，它可以用来包裹某资源，确保该资源在使用前打开，在用完后关闭（即使中途出现错误）。--类似C#中的use{}关键字。\n比如，我们可以stream一个文件：\n```\niex\u003e stream = File.stream!(\"path/to/file\")\n#Function\u003c18.16982430/2 in Stream.resource/3\u003e\niex\u003e Enum.take(stream, 10)\n```\n\n这个例子读取了文件的前10行内容。流在处理大文件，或者慢速资源（如网络）时非常有用。\n\u003cbr/\u003e\n\n一开始Enum和流模块中函数的数量多到让人气馁。但你会慢慢地熟悉它们。\n建议先熟悉Enum模块，然后因为应用而转去流模块中那些相应的，懒惰版的函数。\n\n\n## 11-进程\n\nElixir中，所有代码都在进程中执行。进程彼此独立，一个接一个并发执行，彼此通过消息传递来沟通。\n进程不仅仅是Elixir中最基本的并发单位，它们还是Elixir创建分布式和高容错程序的基础。\n\nElixir的进程和操作系统中的进程不可混为一谈。\nElixir的进程非常非常地轻量级（在使用CPU和内存角度上说。但是它又不同于其它语言中的线程）。\n因此，同时运行着数万个进程也并不是罕见的事。\n\n本章将讲解派生新进程的基本知识，以进程间如何发送和接受消息。\n\n### 11.1-进程派生\n派生（spawning）一个新进程的方法是使用自动导入（kernel函数）的```spawn/1```函数：\n```elixir\niex\u003e spawn fn -\u003e 1 + 2 end\n#PID\u003c0.43.0\u003e\n```\n\n函数```spawn/1```接收一个_函数_作为参数，在其派生出的进程中执行这个函数。\n\n注意spawn/1返回一个PID（进程标识）。在这个时候，这个派生的进程很可能已经结束。\n派生的进程执行完函数后便会结束：\n```elixir\niex\u003e pid = spawn fn -\u003e 1 + 2 end\n#PID\u003c0.44.0\u003e\niex\u003e Process.alive?(pid)\nfalse\n```\n\n\u003e你可能会得到与例子中不一样的PID\n\n用```self/0```函数获取当前进程的PID：\n```elixir\niex\u003e self()\n#PID\u003c0.41.0\u003e\niex\u003e Process.alive?(self())\ntrue\n```\n\n而可以发送和接收消息，让进程变得越来越有趣。\n\n### 11.2-发送和接收\n使用```send/2```函数发送消息，用```receive/1```接收消息：\n```elixir\niex\u003e send self(), {:hello, \"world\"}\n{:hello, \"world\"}\niex\u003e receive do\n...\u003e   {:hello, msg}  -\u003e msg\n...\u003e   {:world, msg} -\u003e \"won't match\"\n...\u003e end\n\"world\"\n```\n\n当有消息被发给某进程，该消息就被存储在该进程的邮箱里。```receive/1```语句块检查当前进程的邮箱，寻找匹配给定模式的消息。\n函数```receive/1```支持分支子句，如```case/2```。\n当然也可以给子句加上卫兵表达式。\n\n如果找不到匹配的消息，当前进程将一直等待，知道下一条信息到达。但是可以设置一个超时时间：\n```elixir\niex\u003e receive do\n...\u003e   {:hello, msg}  -\u003e msg\n...\u003e after\n...\u003e   1_000 -\u003e \"nothing after 1s\"\n...\u003e end\n\"nothing after 1s\"\n```\n\n超时时间设为0表示你知道当前邮箱内肯定有邮件存在，很自信，因此设了这个极短的超时时间。\n\n把以上概念综合起来，演示进程间发送消息：\n```elixir\niex\u003e parent = self()\n#PID\u003c0.41.0\u003e\niex\u003e spawn fn -\u003e send(parent, {:hello, self()}) end\n#PID\u003c0.48.0\u003e\niex\u003e receive do\n...\u003e   {:hello, pid} -\u003e \"Got hello from #{inspect pid}\"\n...\u003e end\n\"Got hello from #PID\u003c0.48.0\u003e\"\n```\n\n在shell中执行程序时，辅助函数```flush/0```很有用。它清空缓冲区，打印进程邮箱中的所有消息：\n```elixir\niex\u003e send self(), :hello\n:hello\niex\u003e flush()\n:hello\n:ok\n```\n\n### 11.3-链接\nElixir中最常用的进程派生方式是通过函数```spawn_link/1```。\n在举例子讲解```spawn_link/1```之前，来看看如果一个进程失败了会发生什么：\n```\niex\u003e spawn fn -\u003e raise \"oops\" end\n#PID\u003c0.58.0\u003e\n```\n\n。。。啥也没发生。这时因为进程都是互不干扰的。如果我们希望一个进程中发生失败可以被另一个进程知道，我们需要链接它们。\n使用```spawn_link/1```函数，例子：\n```\niex\u003e spawn_link fn -\u003e raise \"oops\" end\n#PID\u003c0.60.0\u003e\n** (EXIT from #PID\u003c0.41.0\u003e) an exception was raised:\n    ** (RuntimeError) oops\n        :erlang.apply/2\n```\n\n当失败发生在shell中，shell会自动终止执行，并显示失败信息。这导致我们没法看清背后过程。\n要弄明白链接的进程在失败时发生了什么，我们在一个脚本文件使用```spawn_link/1```并且执行和观察它：\n```\n# spawn.exs\nspawn_link fn -\u003e raise \"oops\" end\n\nreceive do\n  :hello -\u003e \"let's wait until the process fails\"\nend\n```\n\n这次，该进程在失败时把它的父进程也弄停止了，因为它们是链接的。\u003cbr/\u003e\n手动链接进程：```Process.link/1```。\n建议可以多看看[Process模块](http://elixir-lang.org/docs/stable/elixir/Process.html)，里面包含很多常用的进程操作函数。\n\n进程和链接在创建能高容错系统时扮演重要角色。在Elixir程序中，我们经常把进程链接到某“管理者”上。\n由这个角色负责检测失败进程，并且创建新进程取代之。因为进程间独立，默认情况下不共享任何东西。\n而且当一个进程失败了，也不会影响其它进程。\n因此这种形式（进程链接到“管理者”角色）是唯一的实现方法。\n\u003cbr/\u003e\n\n其它语言通常需要我们来try-catch异常，而在Elixir中我们对此无所谓，放手任进程挂掉。\n因为我们希望“管理者”会以更合适的方式重启系统。\n“要死你就快一点”是Elixir软件开发的通用哲学。\n\u003cbr/\u003e\n\n在讲下一章之前，让我们来看一个Elixir中常见的创建进程的情形。\n\n### 11.4-状态\n目前为止我们还没有怎么谈到状态。但是，只要你创建程序，就需要状态。\n例如，保存程序的配置信息，或者分析一个文件先把它保存在内存里。\n你怎么存储状态？\n\n\n进程就是（最常见的）答案。我们可以写无限循环的进程，保存一个状态，然后通过收发信息来告知或改变该状态。\n例如，写一个模块文件，用来创建一个提供k-v仓储服务的进程：\n```\ndefmodule KV do\n  def start do\n    {:ok, spawn_link(fn -\u003e loop(%{}) end)}\n  end\n\n  defp loop(map) do\n    receive do\n      {:get, key, caller} -\u003e\n        send caller, Map.get(map, key)\n        loop(map)\n      {:put, key, value} -\u003e\n        loop(Map.put(map, key, value))\n    end\n  end\nend\n```\n\n注意```start```函数简单地派生一个新进程，这个进程以一个空的图为参数，执行```loop/1```函数。\n这个```loop/1```函数等待消息，并且针对每个消息执行合适的操作。\n加入受到一个```:get```消息，它把消息发回给调用者，然后再次调用自身```loop/1```，等待新消息。\n当受到```:put```消息，它便用一个新版本的图变量（里面的k-v更新了）再次调用自身。\n\n执行一下试试：\n```\niex\u003e {:ok, pid} = KV.start\n#PID\u003c0.62.0\u003e\niex\u003e send pid, {:get, :hello, self()}\n{:get, :hello, #PID\u003c0.41.0\u003e}\niex\u003e flush\nnil\n```\n\n一开始进程内的图变量是没有键值的，所以发送一个```:get```消息并且刷新当前进程的收件箱，返回nil。\n下面再试试发送一个```:put```消息：\n```\niex\u003e send pid, {:put, :hello, :world}\n#PID\u003c0.62.0\u003e\niex\u003e send pid, {:get, :hello, self()}\n{:get, :hello, #PID\u003c0.41.0\u003e}\niex\u003e flush\n:world\n```\n\n注意进程是怎么保持一个状态的：我们通过同该进程收发消息来获取和更新这个状态。\n事实上，任何进程只要知道该进程的PID，都能读取和修改状态。\n\n还可以注册这个PID，给它一个名称。这使得人人都知道它的名字，并通过名字来向它发送消息：\n```\niex\u003e Process.register(pid, :kv)\ntrue\niex\u003e send :kv, {:get, :hello, self()}\n{:get, :hello, #PID\u003c0.41.0\u003e}\niex\u003e flush\n:world\n```\n\n使用进程维护状态，以及注册进程都是Elixir程序非常常用的方式。\n但是大多数时间我们不会自己实现，而是使用Elixir提供的抽象实现。\n例如，Elixir提供的[agent](http://elixir-lang.org/docs/stable/elixir/Agent.html)就是一种维护状态的简单的抽象实现：\n```\niex\u003e {:ok, pid} = Agent.start_link(fn -\u003e %{} end)\n{:ok, #PID\u003c0.72.0\u003e}\niex\u003e Agent.update(pid, fn map -\u003e Map.put(map, :hello, :world) end)\n:ok\niex\u003e Agent.get(pid, fn map -\u003e Map.get(map, :hello) end)\n:world\n```\n\n给```Agent.start/2```方法加一个一个```:name```选项可以自动为其注册一个名字。\n除了agents，Elixir还提供了创建通用服务器（generic servers，称作GenServer）、\n通用时间管理器以及事件处理器（又称GenEvent）的API。\n这些，连同“管理者”树，都可以在Mix和OTP手册里找到详细说明。\n\n## 12-I/O\n\n本章简单介绍Elixir的输入、输出机制，以及相关的模块，如[IO](http://elixir-lang.org/docs/stable/elixir/IO.html)，[文件](http://elixir-lang.org/docs/stable/elixir/File.html)和[路径](http://elixir-lang.org/docs/stable/elixir/Path.html)。\n\n现在介绍I/O似乎有点早，但是I/O系统可以让我们一窥Elixir哲学，满足我们对该语言以及VM的好奇心。\n\n### 12.1-IO模块\nIO模块是Elixir语言中读写标准输入、输出、标准错误、文件、设备的主要机制。\n使用该模块的方法颇为直接：\n```\niex\u003e IO.puts \"hello world\"\n\"hello world\"\n:ok\niex\u003e IO.gets \"yes or no? \"\nyes or no? yes\n\"yes\\n\"\n```\n\nIO模块中的函数默认使用标准输入输出。\n我们也可以传递```:stderr```来指示将错误信息写到标准错误设备上：\n```\niex\u003e IO.puts :stderr, \"hello world\"\n\"hello world\"\n:ok\n```\n\n### 12.2-文件模块\n文件模块包含了可以让我们读写文件的函数。\n默认情况下文件是以二进制模式打开，它要求程序员使用特殊的```IO.binread/2```和```IO.binwrite/2```函数来读写文件：\n```\niex\u003e {:ok, file} = File.open \"hello\", [:write]\n{:ok, #PID\u003c0.47.0\u003e}\niex\u003e IO.binwrite file, \"world\"\n:ok\niex\u003e File.close file\n:ok\niex\u003e File.read \"hello\"\n{:ok, \"world\"}\n```\n\n文件可以使用```:utf8```编码打开，然后就可以被IO模块中其他函数使用了：\n```\niex\u003e {:ok, file} = File.open \"another\", [:write, :utf8]\n{:ok, #PID\u003c0.48.0\u003e}\n```\n\n除了打开、读写文件的函数，文件模块还有许多函数来操作文件系统。这些函数根据Unix功能相对应的命令命名。\n如```File.rm/1```用来删除文件；```File.mkdir/1```用来创建目录；```File.mkdir_p/1```创建目录并保证其父目录一并创建；\n还有```File.cp_r/2```和```File.rm_rf/2```用来递归地复制和删除整个目录。\n\n\n你还会注意到文件模块中，函数一般有一个名称类似的版本。区别是名称上一个有!(bang)一个没有。\n例如，上面的例子我们在读取“hello”文件时，用的是不带!号的版本。\n下面用例子演示下它们的区别：\n```\niex\u003e File.read \"hello\"\n{:ok, \"world\"}\niex\u003e File.read! \"hello\"\n\"world\"\niex\u003e File.read \"unknown\"\n{:error, :enoent}\niex\u003e File.read! \"unknown\"\n** (File.Error) could not read file unknown: no such file or directory\n```\n\n注意看，当文件不存在时，带!号的版本会报错。就是说不带!号的版本能照顾到模式匹配出来的不同的情况。\n但有的时候，你就是希望文件在那儿，!使得它能报出有意义的错误。\n因此，不要写：\n```\n{:ok, body} = File.read(file)\n```\n\n相反地，应该这么写：\n```\ncase File.read(file) do\n  {:ok, body} -\u003e # handle ok\n  {:error, r} -\u003e # handle error\nend\n```\n或者\n```\nFile.read!(file)\n```\n\n###  12.3-路径模块\n文件模块中绝大多数函数都以路径作为参数。通常这些路径都是二进制，可以被路径模块提供的函数操作：\n```\niex\u003e Path.join(\"foo\", \"bar\")\n\"foo/bar\"\niex\u003e Path.expand(\"~/hello\")\n\"/Users/jose/hello\"\n```\n\n\u003cbr/\u003e\n\n有了以上介绍的几个模块和函数，我们已经能对文件系统进行基本的IO操作。\n下面将讨论IO令人好奇的高级话题。这部分不是写Elixir程序必须掌握的，可以跳过不看。\n但是如果你大概地看看，可以了解一下IO是如何在VM上实现以及其它一些有趣的内容。\n\n###  12.4-进程和组长\n你可能已经发现，```File.open/2```函数返回了一个包含PID的元祖：\n```\niex\u003e {:ok, file} = File.open \"hello\", [:write]\n{:ok, #PID\u003c0.47.0\u003e}\n```\n这是因为IO模块实际上是同进程协同工作的。当你调用```IO.write(pid, binary)```时，IO模块将发送一条消息给执行操作的进程。\n让我们用自己的代码表述下这个过程：\n```\niex\u003e pid = spawn fn -\u003e\n...\u003e  receive do: (msg -\u003e IO.inspect msg)\n...\u003e end\n#PID\u003c0.57.0\u003e\niex\u003e IO.write(pid, \"hello\")\n{:io_request, #PID\u003c0.41.0\u003e, #PID\u003c0.57.0\u003e, {:put_chars, :unicode, \"hello\"}}\n** (ErlangError) erlang error: :terminated\n```\n\n调用```IO.write/2```之后，可以看见打印出了发给IO模块的请求。然而因为我们没有提供某些东西，这个请求失败了。\n\n[StringIO模块](http://elixir-lang.org/docs/stable/elixir/StringIO.html)提供了一个基于字符串的IO实现：\n```\niex\u003e {:ok, pid} = StringIO.open(\"hello\")\n{:ok, #PID\u003c0.43.0\u003e}\niex\u003e IO.read(pid, 2)\n\"he\"\n```\n\nErlang虚拟机用进程给IO设备建模，允许同一个网络中的不同节点通过交换文件进程，实现节点间的文件读写。\n在所有IO设备之中，有一个特殊的进程，称作组长（group leader）。\n\n当你写东西到标准输出，实际上是发送了一条消息给组长，它把内容写给*STDIO文件表述者*：\n```\niex\u003e IO.puts :stdio, \"hello\"\nhello\n:ok\niex\u003e IO.puts Process.group_leader, \"hello\"\nhello\n:ok\n```\n\n组长可为每个进程做相应配置，用于处理不同的情况。\n例如，当在远程终端执行代码时，它能保证远程机器的消息可以被重定向到发起操作的终端上。\n\n###  12.5-*iodata*和*chardata*\n在以上所有例子中，我们都用的是二进制/字符串方式读写文件。\n在“二进制、字符串和字符列表”那章里，我们注意到字符串就是普通的bytes，而字符列表是code points的列表。\n\n\nIO模块和文件模块中的函数接受列表作为参数。这也就算了，其实还可以接受混合类型的列表，里面是整形、二进制都行：\n```\niex\u003e IO.puts 'hello world'\nhello world\n:ok\niex\u003e IO.puts ['hello', ?\\s, \"world\"]\nhello world\n:ok\n```\n\n尽管如此，有些地方还是要注意。一个列表可能表示一串byte，或者一串字符。用哪一种看IO设备是怎么编码的。\n如果不指明编码，文件就以raw模式打开，这时候只能用文件模块里bin*开头（二进制版）的函数对其进行操作。\n这些函数接受*iodata*作为参数，即，它们期待一个整数值的列表，用来表示byte或二进制。\n\n尽管只是细微的差别，但你只需要考虑那些细节，如果你打算传递列表给那些函数。\n底层的bytes已经可以表示二进制，这种表示就是raw的。\n\n\n## 13-别名和代码引用\n\n为了实现软件重用，Elixir提供了三种指令（directives）。之所以称之为“指令”是因为它们的作用域是词法作用域（lexicla scope）。\n\n### 13.1-别名\n宏```alias```可以为任何模块名设置别名。想象一下Math模块，它针对特殊的数学运算使用了特殊的列表实现：\n```\ndefmodule Math do\n  alias Math.List, as: List\nend\n```\n现在，任何对```List```的引用将被自动变成对```Math.List```的引用。\n如果还想访问原来的```List```，需要前缀'Elixir'：\n```\nList.flatten             #=\u003e uses Math.List.flatten\nElixir.List.flatten      #=\u003e uses List.flatten\nElixir.Math.List.flatten #=\u003e uses Math.List.flatten\n```\n\n\u003eElixir中定义的所有模块都在一个主Elixir命名空间。但是为方便起见，我们平时都不再前面加‘Elixir’。\n\n别名常被使用与定义快捷方式中。实际上不带```as```选项去调用```alias```会自动将这个别名设置为模块名的最后一部分：\n```\nalias Math.List\n```\n就相当于：\n```\nalias Math.List, as: List\n```\n\n注意，别名是**词法作用域**。即，允许你在某个函数中设置别名：\n```\ndefmodule Math do\n  def plus(a, b) do\n    alias Math.List\n    # ...\n  end\n\n  def minus(a, b) do\n    # ...\n  end\nend\n```\n上面例子中，```alias```指令只在函数```plus/2```中有用，```minus/2```不受影响。\n\n### 13.2-require\nElixir提供了许多宏，用于元编程（写能生成代码的代码）。\n\n宏就是一堆代码，只是它是在编译时被展开和执行。就是说，为了使用一个宏，你需要确保它的模块和实现在编译时可用。\n这使用```require```指令：\n```\niex\u003e Integer.odd?(3)\n** (CompileError) iex:1: you must require Integer before invoking the macro Integer.odd?/1\niex\u003e require Integer\nnil\niex\u003e Integer.odd?(3)\ntrue\n```\n\nElixir中，```Integer.odd?/1```函数被定义为一个宏，因此他可以被当作卫兵表达式（guards）使用。\n为了调用这个宏，你首先得确保用```require```引用了_Integer_模块。\n\n总的来说，一个模块在被用到之前不需要被require引用，除非我们想让这个宏在整个模块中可用。\n尝试调用一个没有引入的宏会导致报错。注意，像```alias```指令一样，```require```也是词法作用域的。\n下文中我们会进一步讨论宏。\n\n### 13.3-import\n当我们想轻松地访问别的模块中的函数和宏时，我们使用```import```指令加上那个模块完整的名字。\n例如，如果我们想多次使用List模块中的```duplicate```函数，我们可以简单地import它：\n```\niex\u003e import List, only: [duplicate: 2]\nnil\niex\u003e duplicate :ok, 3\n[:ok, :ok, :ok]\n```\n\n这个例子中，我们只从List模块导入了函数```duplicate/2```。尽管```only:```选项是可选的，但是推荐使用。\n除了```only:```选项，还有```except:```选项。\n使用选项```only:```还可以传递给它```:macros```或```:functions```。如下面例子，程序仅导入Integer模块中所有的宏：\n```\nimport Integer, only: :macros\n```\n或者，仅导入所有的函数：\n```\nimport Integer, only: :functions\n```\n\n注意，```import```也是**词法作用域**，意味着我们可以在某特定函数中导入宏或方法：\n```\ndefmodule Math do\n  def some_function do\n    import List, only: [duplicate: 2]\n    # call duplicate\n  end\nend\n```\n在此例子中，导入的函数```List.duplicate/2```只在那个函数中可见。这个模块中其它函数都不可用（自然，别的模块也不受影响）。\n\n注意，若import一个模块，将自动require它。\n\n### 13.4-别名机制\n讲到这里你会问，Elixir的别名到底是什么，它是怎么实现的？\n\nElixir中的别名是以大写字母开头的标识符（像String, Keyword等等），在编译时会被转换为原子。\n例如，别名‘String’会被转换为```:\"Elixir.String\"```：\n```\niex\u003e is_atom(String)\ntrue\niex\u003e to_string(String)\n\"Elixir.String\"\niex\u003e :\"Elixir.String\"\nString\n```\n\n使用```alias/2```指令，其实只是简单地改变了这个别名将要转换的结果。\n\n别名如此工作，是因为在Erlang虚拟机中（以及后来的Elixir），模块是被表述成原子的。例如，我们调用一个Erlang模块的机制是：\n```\niex\u003e :lists.flatten([1,[2],3])\n[1, 2, 3]\n```\n\n这也是允许我们动态调用某模块内给定函数的机制：\n```\niex\u003e mod = :lists\n:lists\niex\u003e mod.flatten([1,[2],3])\n[1,2,3]\n```\n一句话，我们只是简单地在原子```:lists```上调用了函数```flatten```。\n\n### 13.5-嵌套\n介绍了别名，现在可以讲讲嵌套（nesting）以及它在Elixir中是如何工作的。\n\n考虑下面的例子：\n```\ndefmodule Foo do\n  defmodule Bar do\n  end\nend\n```\n该例子定义了两个模块_Foo_和_Foo.Bar_。后者在_Foo_中可以用_Bar_为名来访问，因为它们在同一个词法作用域中。\n如果之后开发者决定把Bar模块挪到另一个文件中，那它就需要以全名（Foo.Bar）或者别名来指代。\n\n换句话说，上面的代码等同于：\n```\ndefmodule Elixir.Foo do\n  defmodule Elixir.Foo.Bar do\n  end\n  alias Elixir.Foo.Bar, as: Bar\nend\n```\n\n在以后章节我们可以看到，别名在宏机制中扮演了很重要的角色，来保证宏是干净的（hygienic）。\n\n讨论到这里，模块基本上讲得差不多了。之后会讲解模块的属性。\n\n\n## 14-模块属性\n\n\n在Elixir中，模块属性（attributes）主要服务于三个目的：\n  1. 作为一个模块的注释，通常附加上用户或虚拟机用到的信息\n  2. 作为常量\n  3. 在编译时作为一个临时的模块存储\n\n让我们一个一个讲解。\n\n### 14.1-作为注释\nElixir从Erlang带来了模块属性的概念。例子：\n```\ndefmodule MyServer do\n  @vsn 2\nend\n```\n这个例子中，我们显式地为该模块设置了版本这个属性。\n属性标识```@vsn```会被Erlang虚拟机的代码装载机制用到，读取并检查该模块是否在某处被更新了。\n如果不注明版本号，会设置为这个模块函数的md5 checksum。\n\nElixir有个好多系统保留属性。这里只列举一些最常用的：\n  - @moduledoc\n    为当前模块提供文档\n  - @doc\n    为该属性后面的函数或宏提供文档\n  - @behaviour\n    （注意这个单词是英式拼法）用来注明一个OTP或用户自定义行为\n  - @before_compile\n    提供一个每当模块被编译之前执行的钩子。这使得我们可以在模块被编译之前往里面注入函数。\n\n@moduledoc和@doc是很常用的属性，推荐经常使用（写文档）。\n\nElixir视文档为一等公民，提供了很多方法来访问文档。\n\n让我们回到上几章定义的Math模块，为它添加文档，然后依然保存在math.ex文件中：\n```\ndefmodule Math do\n  @moduledoc \"\"\"\n  Provides math-related functions.\n\n  ### Examples\n\n      iex\u003e Math.sum(1, 2)\n      3\n\n  \"\"\"\n\n  @doc \"\"\"\n  Calculates the sum of two numbers.\n  \"\"\"\n  def sum(a, b), do: a + b\nend\n```\n\n上面例子使用了heredocs注释。heredocs是多行的文本，用三个引号包裹，保持里面内容的格式。\n下面例子演示在iex中，用h命令读取模块的注释：\n```\n$ elixirc math.ex\n$ iex\niex\u003e h Math # Access the docs for the module Math\n...\niex\u003e h Math.sum # Access the docs for the sum function\n...\n```\n\nElixir还提供了[ExDoc工具](https://github.com/elixir-lang/ex_doc)，利用注释文档生成HTNL页。\n\n你可以看看[模块](http://elixir-lang.org/docs/stable/elixir/Module.html)里面列出的模块属性列表，\n看看Elixir还支持那些模块属性。\n\nElixir还是用这些属性来定义[typespecs](http://elixir-lang.org/docs/stable/elixir/Kernel.Typespec.html)：\n  - @spec\n    为一个函数提供specification\n  - @callback\n    为行为回调函数提供spec\n  - @type\n    定义一个@spec中用到的类型\n  - @typep\n    定义一个私有类型，用于@spec\n  - @opaque\n    定义一个opaque类型用于@spec\n\n本节讲了一些内置的属性。当然，属性可以被开发者、或者被类库扩展来支持自定义的行为。\n\n### 14.2-作为常量\nElixir开发者经常会模块属性当作常量使用：\n```\ndefmodule MyServer do\n  @initial_state %{host: \"147.0.0.1\", port: 3456}\n  IO.inspect @initial_state\nend\n```\n\n\u003e不同于Erlang，默认情况下用户定义的属性不被存储在模块里。属性值仅在编译时存在。\n开发者可以通过调用```Module.register_attribute/3```来使属性的行为更接近Erlang。\n\n访问一个未定义的属性会报警告：\n```\ndefmodule MyServer do\n  @unknown\nend\nwarning: undefined module attribute @unknown, please remove access to @unknown or explicitly set it to nil before access\n```\n\n最后，属性也可以在函数中被读取：\n```\ndefmodule MyServer do\n  @my_data 14\n  def first_data, do: @my_data\n  @my_data 13\n  def second_data, do: @my_data\nend\n\nMyServer.first_data #=\u003e 14\nMyServer.second_data #=\u003e 13\n```\n\n注意在函数内读取某属性读取的是该属性当前值的快照。换句话说，读取的是编译时的值，而非运行时。\n我们即将看到，这点使得属性可以作为模块在编译时的临时存储。\n\n### 14.3-作为临时存储\nElixir组织中有一个项目，叫做[Plug](https://github.com/elixir-lang/plug)。这个项目的目标是创建一个Web的库和框架。\n\n\u003e类似于rack？\n\nPlug库允许开发者定义它们自己的plug，可以在一个web服务器上运行：\n```\ndefmodule MyPlug do\n  use Plug.Builder\n\n  plug :set_header\n  plug :send_ok\n\n  def set_header(conn, _opts) do\n    put_resp_header(conn, \"x-header\", \"set\")\n  end\n\n  def send_ok(conn, _opts) do\n    send(conn, 200, \"ok\")\n  end\nend\n\nIO.puts \"Running MyPlug with Cowboy on http://localhost:4000\"\nPlug.Adapters.Cowboy.http MyPlug, []\n```\n\n上面例子我们用了```plug/1```宏来连接各个在处理请求时会被调用的函数。\n在内部，每当你调用```plug/1```时，Plug库把参数存储在@plug属性里。\n在模块被编译之前，Plug执行一个回调函数，这个函数定义了处理http请求的方法。\n这个方法将顺序执行所有保存在@plug属性里的plugs。\n\n为了理解底层的代码，我们需要宏。因此我们将回顾一下元编程手册里这种模式。\n但是这里的焦点是怎样使用属性来存储数据，让开发者得以创建DSL。\n\n另一个例子来自ExUnit框架，它使用模块属性作为注释和存储：\n```\ndefmodule MyTest do\n  use ExUnit.Case\n\n  @tag :external\n  test \"contacts external service\" do\n    # ...\n  end\nend\n```\n\nExUnit中，@tag标签被用来注释该测试用例。之后，这些标签可以作为过滤测试用例之用。\n例如，你可以避免执行那些被标记成```:external```的测试，因为它们执行起来很慢。\n\n\n本章带你一窥Elixir元编程的冰山一角，讲解了模块属性在开发中是如何扮演关键角色的。\n\n下一章将讲解结构体和协议。\n\n## 15-结构体\n\n在之前的几章中，我们谈到过图：\n```\niex\u003e map = %{a: 1, b: 2}\n%{a: 1, b: 2}\niex\u003e map[:a]\n1\niex\u003e %{map | a: 3}\n%{a: 3, b: 2}\n```\n\n结构体是基于图的一个扩展。它将默认值，编译时保证和多态性带入Elixir。\n\n定义一个结构体，你只需在某模块中调用```defstruct/1```：\n```\niex\u003e defmodule User do\n...\u003e   defstruct name: \"john\", age: 27\n...\u003e end\n{:module, User,\n \u003c\u003c70, 79, 82, ...\u003e\u003e, {:__struct__, 0}}\n ```\n \n 现在可以用```%User()```语法创建这个结构体的“实例”了：\n ```\niex\u003e %User{}\n%User{name: \"john\", age: 27}\niex\u003e %User{name: \"meg\"}\n%User{name: \"meg\", age: 27}\niex\u003e is_map(%User{})\ntrue\n```\n\n结构体的编译时保证指的是编译时会检查结构体的字段存不存在：\n```\niex\u003e %User{oops: :field}\n** (CompileError) iex:3: unknown key :oops for struct User\n```\n\n当讨论图的时候，我们演示了如何访问和修改图现有的字段。结构体也是一样的：\n```\niex\u003e john = %User{}\n%User{name: \"john\", age: 27}\niex\u003e john.name\n\"john\"\niex\u003e meg = %{john | name: \"meg\"}\n%User{name: \"meg\", age: 27}\niex\u003e %{meg | oops: :field}\n** (ArgumentError) argument error\n```\n\n通过使用这种修改的语法，虚拟机知道没有新的键增加到图/结构体中，使得图可以在内存中共享它们的结构。\n在上面例子中，john和meg共享了相同的键结构。\n\n结构体也能用在模式匹配中，它们保证结构体有相同的类型：\n```\niex\u003e %User{name: name} = john\n%User{name: \"john\", age: 27}\niex\u003e name\n\"john\"\niex\u003e %User{} = %{}\n** (MatchError) no match of right hand side value: %{}\n```\n\n匹配能工作，是由于结构体再底层图中有个字段叫```__struct__```：\n```\niex\u003e john.__struct__\nUser\n```\n\n总之，结构体就是个光秃秃的图外加一个默认字段。我们这里说的光秃秃的图指的是，为图实现的协议都不能用于结构体。\n例如，你不能枚举也不能访问一个结构体：\n```\niex\u003e user = %User{}\n%User{name: \"john\", age: 27}\niex\u003e user[:name]\n** (Protocol.UndefinedError) protocol Access not implemented for %User{age: 27, name: \"john\"}\n```\n\n结构体也不是字典，因为也不适用字典模块的函数：\n```\niex\u003e Dict.get(%User{}, :name)\n** (ArgumentError) unsupported dict: %User{name: \"john\", age: 27}\n```\n\n下一章我们将介绍结构体是如何同协议进行交互的。\n\n## 16-协议\n\n\n协议是实现Elixir多态性的重要机制。任何数据类型只要实现了某协议，那么该协议的分发就是可用的。\n让我们看个例子。\n\n在Elixir中，只有false和nil被认为是false。其它的值都被认为是true。\n根据程序需要，有时需要一个```blank?```协议，返回一个布尔值，以说明该参数是否为空。\n举例来说，一个空列表或者空二进制可以被认为是空的。\n\n我们可以如下定义协议：\n```\ndefprotocol Blank do\n  @doc \"Returns true if data is considered blank/empty\"\n  def blank?(data)\nend\n```\n\n这个协议期待一个函数```blank?```，它接受一个待实现的参数。\n我们为不同的数据类型实现这个协议：\n```\n# Integers are never blank\ndefimpl Blank, for: Integer do\n  def blank?(_), do: false\nend\n\n# Just empty list is blank\ndefimpl Blank, for: List do\n  def blank?([]), do: true\n  def blank?(_),  do: false\nend\n\n# Just empty map is blank\ndefimpl Blank, for: Map do\n  # Keep in mind we could not pattern match on %{} because\n  # it matches on all maps. We can however check if the size\n  # is zero (and size is a fast operation).\n  def blank?(map), do: map_size(map) == 0\nend\n\n# Just the atoms false and nil are blank\ndefimpl Blank, for: Atom do\n  def blank?(false), do: true\n  def blank?(nil),   do: true\n  def blank?(_),     do: false\nend\n```\n\n我们可以为所有内建数据类型实现协议：\n  - 原子\n  - BitString\n  - 浮点型\n  - 函数\n  - 整型\n  - 列表\n  - 图\n  - PID\n  - Port\n  - 引用\n  - 元祖\n\n现在手边有了一个定义并被实现的协议，如此使用之：\n```\niex\u003e Blank.blank?(0)\nfalse\niex\u003e Blank.blank?([])\ntrue\niex\u003e Blank.blank?([1, 2, 3])\nfalse\n```\n\n给它传递一个并没有实现该协议的数据类型，会导致报错：\n```\niex\u003e Blank.blank?(\"hello\")\n** (Protocol.UndefinedError) protocol Blank not implemented for \"hello\"\n```\n\n### 16.1-协议和结构体\n协议和结构体一起使用能够大大加强Elixir的可扩展性。\u003cbr/\u003e\n\n在前面几章中我们知道，尽管结构体就是图，但是它们和图并不共享各自协议的实现。\n像前几章一样，我们先定义一个名为```User```的结构体：\n```\niex\u003e defmodule User do\n...\u003e   defstruct name: \"john\", age: 27\n...\u003e end\n{:module, User,\n \u003c\u003c70, 79, 82, ...\u003e\u003e, {:__struct__, 0}}\n ```\n 然后看看：\n ```\niex\u003e Blank.blank?(%{})\ntrue\niex\u003e Blank.blank?(%User{})\n** (Protocol.UndefinedError) protocol Blank not implemented for %User{age: 27, name: \"john\"}\n```\n\n结构体没有使用协议针对图的实现，而是使用它自己的协议实现：\n```\ndefimpl Blank, for: User do\n  def blank?(_), do: false\nend\n```\n\n如果愿意，你可以定义你自己的语法来检查一个user为不为空。\n不光如此，你还可以使用结构体创建更强健的数据类型，比如队列，然后实现所有相关的协议，比如枚举（Enumerable）或检查是否为空。\n\n有些时候，程序员们希望给结构体提供某些默认的协议实现。因为显式给所有结构体都实现某些协议实在是太枯燥了。\n这引出了下一节“回归大众”（falling back to any）的说法。\n\n### 16.2-回归大众\n能够给所有类型提供默认的协议实现肯定是很方便的。在定义协议时，把```@fallback_to_any```设置为```true```即可：\n```\ndefprotocol Blank do\n  @fallback_to_any true\n  def blank?(data)\nend\n```\n现在这个协议可以被这么实现：\n```\ndefimpl Blank, for: Any do\n  def blank?(_), do: false\nend\n```\n\n现在，那些我们还没有实现```Blank```协议的数据类型（包括结构体）也可以来判断是否为空了。\n\n### 16.3-内建协议\nElixir自带了一些内建协议。在前面几章中我们讨论过枚举模块，它提供了许多方法。\n只要任何一种数据结构它实现了Enumerable协议，就能使用这些方法：\n\n```\niex\u003e Enum.map [1, 2, 3], fn(x) -\u003e x * 2 end\n[2,4,6]\niex\u003e Enum.reduce 1..3, 0, fn(x, acc) -\u003e x + acc end\n6\n```\n\n另一个例子是```String.Chars```协议，它规定了如何将包含字符的数据结构转换为字符串类型。\n它暴露为函数```to_string```：\n```\niex\u003e to_string :hello\n\"hello\"\n```\n\n注意，在Elixir中，字符串插值操作调用的是```to_string```函数：\n```\niex\u003e \"age: #{25}\"\n\"age: 25\"\n```\n上面代码能工作是因为数字类型实现了```String.Chars```协议。如果传进去的是元组就会报错：\n```\niex\u003e tuple = {1, 2, 3}\n{1, 2, 3}\niex\u003e \"tuple: #{tuple}\"\n** (Protocol.UndefinedError) protocol String.Chars not implemented for {1, 2, 3}\n```\n\n当想要打印一个比较复杂的数据结构时，可以使用```inspect```函数。该函数基于协议```Inspect```：\n```\niex\u003e \"tuple: #{inspect tuple}\"\n\"tuple: {1, 2, 3}\"\n```\n\n_Inspect_协议用来将任意数据类型转换为可读的文字表述。IEx用来打印表达式结果用的就是它：\n```\niex\u003e {1, 2, 3}\n{1,2,3}\niex\u003e %User{}\n%User{name: \"john\", age: 27}\n```\n\n记住，习惯上来说，无论何时，头顶#号被插的值，会被表现成一个不合语法的字符串。\n在转换为可读的字符串时丢失了信息，因此别指望还能从该字符串取回原来的那个对象：\n```\niex\u003e inspect \u0026(\u00261+2)\n\"#Function\u003c6.71889879/1 in :erl_eval.expr/5\u003e\"\n```\n\nElixir中还有些其它协议，但本章就讲这几个比较常用的。下一章将讲讲Elixir中的错误捕捉以及异常。\n","Tags":["Elixir"],"CreateTime":1444404091,"EditTime":1444404263,"UpdateTime":1444404091,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":581}