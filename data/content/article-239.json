{"Id":239,"Title":"探寻Rust ownership系统","Slug":"2015-08-25-1","Text":"## (Explore the ownership system in Rust)\n\n\u003e 原作者：Nercury\n\u003e 原文[链接](http://nercury.github.io/rust/guide/2015/01/19/ownership.html#memory-allocation)\n\u003e 探寻Rust ownership系统\n\u003e Jan 19, 2015\n\n这篇将由两部分组成的指南主要面向已了解**Rust**的基本语法和构建单元但是尚未领会**ownership**和**borrowing**的工作原理的读者.\n\n首先我们会从简单的概念开始，随后慢慢了解更深入复杂的概念，直至深入理解完整的细节概念。这份指南假设读者对`let`, `fn`, `struct`, `trait`和`impl`有基本的了解。\n\n我们的目标是在使用Rust进行开发时不会被ownership和borrowing所困扰。\n\n\n首先从Ownership开始:\n\n+ [简介](http://nercury.github.io/rust/guide/2015/01/19/ownership.html#prerequisites---what-you-already-know) \n+ [Copy Traits](http://nercury.github.io/rust/guide/2015/01/19/ownership.html#copy-trait)\n+ 了解不可变量([Immutable](http://nercury.github.io/rust/guide/2015/01/19/ownership.html#ownership))Ownership规则\n+ 了解可变量([Mutable](http://nercury.github.io/rust/guide/2015/01/19/ownership.html#mutable-ownership))Ownership 规则.\n+ [强大的Ownership系统](http://nercury.github.io/rust/guide/2015/01/19/ownership.html#memory-allocation)\n+ [内存管理](http://nercury.github.io/rust/guide/2015/01/19/ownership.html#memory-allocation)\n+ 垃圾回收([Reference counting](http://nercury.github.io/rust/guide/2015/01/19/ownership.html#reference-counting))\n+ [并发](http://nercury.github.io/rust/guide/2015/01/19/ownership.html#concurrency)\n\n### 简介\n\n和大家通常熟悉的语言类似，Rust基于Scope/stack的内存管理是非常直观的。\n\n当下面的代码中的i在main函数返回时会发生什么？\n\n    fn main() {     \n        let i = 5; \n    }\n\n它离开了他的生存范围进而被释放。\n\n如果我把这个`i`传递给其它的函数例如`foo`，那么它会被释放多少次呢？\n\n    fn foo(i: i64) { \n        // another function foo\n        // something \n    }  \n    fn main() {\n        let i = 5;\n        foo(i);\n        // call function foo \n    }\n\n对，它会被释放两次。第一次释放发生在函数`foo`结束的时候，另外一次发生在`main`函数结束的时候。如果你在`foo`函数中对它的值进行了修改，这个修改不会被反映到`main`函数中的值。\n\n因为这个值在调用`foo`函数的过程中进行了一次拷贝。\n\n与C++（以及一些其它的语言）相似，除了integer这样内置的类型，Rust还可以使用用户自定义的类型。这些类型的值可以在当前的stack上进行分配并且在函数返回离开其生命范围后得到释放（如果类型有destructor，那么destructor也会被调用）。\n\n然而对于没有实现[`Copy` Traits](http://doc.rust-lang.org/std/marker/trait.Copy.html)的类型来说，Rust编译器则会选择一个不同的基于ownership的规则来处理对象的生命周期。所以我们先来讨论一下`Copy` trait。\n\n### Copy Trait\n\n实现[`Copy` Traits](http://doc.rust-lang.org/std/marker/trait.Copy.html)可以使得用户自定义类型按照内置的integer类型一样来工作，每当发生拷贝赋值或者以值方式进行函数调用的时候，它的数据会被直接进行字节级别的拷贝复制来产生一个新的对象。\n\n于很多其它的类型一样，内置类型i64(一种integer)也实现了这个Copy trait。\n\n同样如果我们有一个自定义类型Info，我们也可以实现Copy使得我们的类型拥有可拷贝的语义：\n\n    struct Info {\n        value: i64, \n    }\n    impl Copy for Info {}\n\n或者与上面功能上等同，我们也可以使用 #[derive(Copy)] 注解来达到一样的目的。\n\n    #[derive(Copy)]\n    struct Info {\n        value: i64, \n    }\n\n没有实现`Copy` trait的类型在需要的时候则会遵循ownership原则来转移到其它的地方。\n\n### Ownership\n\nOwnership规则确保不可拷贝的对象在任何一个时间只有一个拥有者并且只有这个拥有者可以对它进行修改。\n\n所以如果一个函数负责释放某一个对象，那么它可以确定不会有任何一个其它的所有者会同时或者以后对同一个对象进行访问、修改或者删除。\n\n现在我们已经有足够的基本了解了，让我们来开始动手试验吧。\n\n#### Bob你好\n\n为了演示对象的ownership是如何被转移的，我们来创建一个新的不实现Copy trait的类型`Bob`。\n\n    struct Bob {\n        name: String,\n    }\n\n我们会在Bob的构造函数`new`中打印出它被构造的信息：\n\n    impl Bob {\n        fn new(name: \u0026str) -\u003e Bob {\n            println!(\"new bob {:?}\", name); // announce\n            Bob { name: name.to_string() }\n        }\n    }\n\n通过实现`Drop::drop` trait，我们在Bob被释放时打印出Bob的名称；\n\n    impl Drop for Bob {\n        fn drop(\u0026mut self) {\n            println!(\"del bob {:?}\", self.name);\n        }\n    }\n\n除此之外我们为Bob类型实现了内置的`Debug::fmt` trait来方便打印Bob对象的内容：\n\n    use std::fmt;\n\n    impl fmt::Debug for Bob {\n        fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n            write!(f, \"bob {:?}\", self.name)\n        }\n    }\n\n#### 开始测试吧!\n\n当我们在main函数中创建一个Bob对象时，我们得到了预期的结果：\n\n    fn main() {\n        Bob::new(\"A\");\n    }\n\n    new bob \"A\"\n    del bob \"A\"\n\n好了对象被释放了，但是它是在什么时候被释放的呢？\n\n让我们在函数退出之前打印一行信息：\n\n    fn main() {\n        Bob::new(\"A\");\n        println!(\"end is near\");\n    }\n\n    new bob \"A\"\n    del bob \"A\"\n    end is near\n\n原来对象是在函数返回之前被释放的。原因是返回值没有被赋予给任何局部变量，所以编译器在返回的Bob对象上直接调用了drop方法并释放了对象。\n\n那么如果我们把返回值绑定到某一个局部变量上呢？\n\n    fn main() {\n        let bob = Bob::new(\"A\");\n        println!(\"end is near\");\n    }\n    new bob \"A\"\n    end is near\n    del bob \"A\"\n\n当我们使用`let`来将返回值绑定到一个变量后，新创建的Bob对象在离开这个变量的范围，也就是函数退出的时候被释放。所以编译器的做法是在离开某一个范围后将所有属于这个范围的绑定变量进行释放。\n\n#### 要么释放要么转移\n\n注意：一个对象可以被转移给其它的owner，一旦它被转移了它就不会被被转移前的作用域所有也不会被其释放。\n\n那么怎么才能转移一个对象呢? 其实很简单，只要把对象以值的方式传递给其它函数。\n\n现在让我们来试试把我们新建的Bob对象传递给`black_hole`函数吧：\n\n    fn black_hole(bob: Bob) {\n        println!(\"imminent shrinkage {:?}\", bob);\n    }\n\n    fn main() {\n        let bob = Bob::new(\"A\");\n        black_hole(bob);\n        println!(\"end is near\");\n    }\n    new bob \"A\"\n    imminent shrinkage bob \"A\"\n    del bob \"A\"\n    end is near \n\n[Try it yourself!](http://is.gd/fQ1Bzy)\n\n现在bob不再是在main函数退出的时候被释放了，它在black_hole函数返回的时候就已经被释放了!\n\n但是让我们再想想，如果我们使用同样的Bob对象来调用black_hole函数两次会怎么样？\n\n    fn main() {\n        let bob = Bob::new(\"A\");\n        black_hole(bob);\n        black_hole(bob);\n    }\n    \u003canon\u003e:35:16: 35:19 error: use of moved value: `bob`\n    \u003canon\u003e:35     black_hole(bob);\n                             ^~~\n    \u003canon\u003e:34:16: 34:19 note: `bob` moved here because it has type `Bob`, which is non-copyable\n    \u003canon\u003e:34     black_hole(bob);\n                             ^~~\n\n非常简单，编译器不允许我们使用一个已经被转移的对象，并且在出错的时候给出了非常明确而友好的错误信息。\n\n#### 没有魔法只有规则\n\n与垃圾回收的情况下编译器需要在代码里到处跟踪对象的使用情况不同，Rust实现内存安全的方式不依赖于垃圾回收。Rust可以从当前函数范围内对对象的使用情况得出对象是否已经被释放的结论。\n\n当你明白规则后，一切就很清晰了。到目前为止我们已经了解到了下面几个规则：\n\n+ 不被使用的返回值会被立即释放\n+ 所有使用let绑定的值如果不在中间被转移给其它所有者，这些值会在函数退出对象离开它们的存活范围时得到释放。\n\n所以到目前为止我们了解的内存安全的基础是在一个时刻一个值只能有一个所有者。\n\n然而我们之前所讨论的是只读绑定，当一个值可能被修改的情况下规则需要进行加强。\n\n### 可变值的Ownership\n\n一个值的拥有者可以对值进行修改，只要我们在使用let绑定变量是增加mut指令。比如我们可以对bob的name部分进行修改：\n\n    fn main() {\n        let mut bob = Bob::new(\"A\");\n        bob.name = String::from_str(\"mutant\");\n    }\n    new bob \"A\"\n    del bob \"mutant\"\n\n我们先创建了一个name为“A”的对象，但是当释放它的时候它已经变成了“mutant”了。\n如果我们把这个值传递给另外的函数`mutate`，我们同样可以将其标记为`mut`：\n\n    fn mutate(value: Bob) {\n        let mut bob = value;\n        bob.name = String::from_str(\"mutant\");\n    }\n\n    fn main() {\n        mutate(Bob::new(\"A\"));\n    }\n    new bob \"A\"\n    del bob \"mutant\"\n\n由上可见在任何时候我们都可以将一个自己所有的对象变成可变的。\n\n除了以`let`方式获得一个可变的绑定，我们还可以直接将函数的参数标记为可变的，它们的工作方式是一样的。所以之前的试验代码可以写的更短一些：\n\n    fn mutate(mut value: Bob) { // use mut directly before the arg name\n        value.name = String::from_str(\"mutant\");\n    }\n\n修改一个可变绑定\n\n当我们修改一个可变绑定的时候会发生什么呢？\n\n    fn main() {\n        let mut bob = Bob::new(\"A\");\n        println!(\"\");\n        for \u0026name in [\"B\", \"C\"].iter() {\n            println!(\"before overwrite\");\n            bob = Bob::new(name);\n            println!(\"after overwrite\");\n            println!(\"\");\n        }\n    }\n    new bob \"A\"\n\n    before overwrite\n    new bob \"B\"\n    del bob \"A\"\n    after overwrite\n\n    before overwrite\n    new bob \"C\"\n    del bob \"B\"\n    after overwrite\n\n    del bob \"C\"\n\n老的值被释放，如果没有被重新赋值或者转移ownership，新赋值的值会在离开绑定变量的生命范围后时被释放。\n\n#### 可变变量的Ownership规则\n\n下面是可变变量的Ownership规则:\n\n+ 不被使用的返回值会被立即释放\n+ 所有使用let绑定的值如果不在中间被转移给其它所有者，这些值会在函数退出对象离开它们的存活范围时得到释放。\n+ 被替换的值会被释放\n\n所以Rust是通过确保只有一个owner拥有一个对象来满足上面的规则的。\n\n### Ownership系统的威力\n\n最初一看这些ownership规则好像限制很多，其实只是因为我们已经习惯于其它的规则了。这些规则实际上并没有限制我们可以做什么事情，它们只是给我们了一个不同的基础来构建更高层的结构。\n\n在其它语言中这些高层的结构可能会更难做到像Rust一样的安全，如果想要做到Rust一样的编译期的安全检查则更加难。\n\n现在让我们来看一看标准库所提供的这些高层结构。\n\n#### 内存分配\n\n前面我们讨论了像integer一样的可以在stack上分配的值类型。我们的测试类型`Bob`就是这样的一个类型。虽然很多流行的语言也可以将对象保存在stack中（例如C#中的`struct`，或者不使用`new`构造的c++对象），还有很多语言做不到这一点。\n\n通常来说，一个新创建的对象实例所需要的内存（在很多语言中使用new operator创建的实例）是在heap中进行分配的。\n\n基于heap的内存分配有很多有点。首先它不受stack尺寸的限制。在stack上分配一个巨大的对象可能会导致stack overflow。另外一旦内存分配完成，对象的地址不再发生变化。相反在stack上分配的对象在移动或者发生复制的时候地址会发生变化，对象的内容需要从stack的一个地方拷贝到另外的地方。 虽然在对象尺寸很小的时候这种拷贝是有效率的，但是当对象的尺寸变大的时候拷贝就会明显的降低性能。\n\nRust使用Box来解决这个问题。当对象的内存从heap中被分配并构建完成后，对象的指针会被包裹在Box中，而Box则作为一个智能指针存在于stack中。\n\n例如我们可以这样在heap中创建`Bob`对象：\n\n    fn main() {\n        let bob = Box::new(Bob::new(\"A\"));\n    }\n    new bob A\n    del bob A\n\n从Box::new返回的对象类型是Box，这个generic类型对Bob对象的生命周期进行管理，并且确保在Box被释放时一并释放Bob对象。\n\n因为Box类型是不可拷贝的，因此它遵循前面所讨论的同样的ownership规则。当它在stack上离开了作用域后会被释放，而它的`drop`方法会在这时被调用，而drop方法会进一步将分配在heap上的`Bob`对象释放。\n\n其它语言通常要求开发者手动显式的释放内存（通过容易忘记或者因错误被调用多次的`delete`语句），或者使用Garbage Collector来跟踪内存中所有的指针并且在指针不存在活引用的时候释放它们。跟这些语言比起来Rust这个简单安全并且有效的内存释放机制对用户来说非常易用。\n\n当这个简单的做法不能满足需求的时候，我们还有其它的工具来处理更复杂的场景。\n\n#### 垃圾回收\n\nRust提供了足够的底层工具以外部库的方式实现垃圾回收。目前Rust直接内置的垃圾回收库是基于引用计数的。\n\n例如我们可以这样来把bob对象交给Rc管理：\n\n    use std::rc::Rc;  fn main() {\n        let bob = Rc::new(Bob::new(\"A\"));\n        println!(\"{:?}\", bob);\n    }\n    new bob A\n    Rc(bob A)\n    del bob A \n\n[Try it here!](http://is.gd/5PGJCq)\n\n接着我们可以修改`black_hole`函数以`Rc`为参数类型，然后我们可以检查对象是否被`black_hole`函数释放。实际上我们可以把这个函数写的更通用，让它接受任意实现了Show trait的类型作为参数，让我们顺便把它改成gereric的吧：\n\n    fn black_hole\u003cT\u003e(value: T) where T: fmt::Show {\n        println!(\"imminent shrinkage {:?}\", value);\n    }\n\n新版本和以前的使用方法一致，并且以后我们不再因为类型变更给对其进行调整了。\n\n现在我们用` Rc` 作为参数来调用 `black_hole`函数!\n\n    fn main() {\n        let bob = Rc::new(Bob::new(\"A\"));\n        black_hole(bob.clone()); // clone call\n        println!(\"{:?}\", bob);\n    }\n    new bob A\n    imminent shrinkage Rc(bob A)\n    Rc(bob A)\n    del bob A\n\n[Try it here](http://is.gd/swTG3e)\n\n太好了，bob从black_hole中存活下来了！那么它是怎么做到的呢？\n\n在bob对象被保存在`Rc`中后，只要任何地点拥有一个活的Rc副本存在，bob就不会被释放。在`Rc`内部使用了 Box来保存heap中分配的bob对象的指针同时维持了对这个对象的引用计数。\n\n每当一个新的副本被创建时（调用Rc的`clone`方法）引用计数会被增加，而当副本离开生命域后会减少引用计数。当引用计数到达0的时候Rc所维持的对象会被释放将内存返回给heap。\n\n注意，前面介绍的Rc是不可变的，如果需要对其包装的Bob对象进行修改，我们可以将其进一步封装于一个RefCell类型中。RefCell类型允许`borrow`一个对象的可变引用 。在下面的示例中它会被`mutate`函数修改。\n\n    fn mutate(bob: Rc\u003cRefCell\u003cBob\u003e\u003e) {\n        bob.borrow_mut().name = String::from_str(\"mutant\");\n    }\n\n    fn main() {\n        let bob = Rc::new(RefCell::new(Bob::new(\"A\")));\n        mutate(bob.clone());\n        println!(\"{:?}\", bob);\n    }\n    new bob A\n    Rc(RefCell { value: bob mutant })\n    del bob mutant\n\n这个例子很好的演示了如何组合底层工具在最小的代价下来达到需要的目的。\n\n同样，虽然Rc只能在一个线程中使用，但是我们可以使用Arc类型来在多个线程中实现Atomic的引用计数。如果多个对象互相引用，那么一个可变的Rc可能产生循环引用。但是我们可以把Rc复制为Weak引用，因为Weak引用不参与引用计数，从而解决循环引用问题。我们可以从官方文档得到更详细的介绍。\n\n更重要的是，更高级的垃圾回收机制可以并一定会在将来以附加库的方式来实现。\n\n### 并发\n\n与我们常见的模式不同，Rust中使用的线程方式非常有趣。在默认情况下线程之间不会发生任何数据访问竞争(data races)。这并不是因为在线程之间存在特殊的隔离体来避免竞争访问的发生，实际上因为ownership模型自身是线程安全的，用户甚至可以开发自己的线程库并提供相似的安全特征。\n\n现在思考一下当我们把两个值，一个可移动的Bob和一个可拷贝的integer，发送给新的Rust线程时会发生什么：\n\n    use std::thread;\n\n    fn main() {\n        let bob = Bob::new(\"A\");\n        let i : i64 = 12;\n\n        let child = thread::spawn(move || {\n            println!(\"From thread, {:?} and {:?}!\", bob, i);\n        });\n\n        println!(\"waiting for thread to end\");\n        child.join();\n    }\n\n    new bob \"A\"\n    waiting for thread to end\n    From thread, bob \"A\" and 12!\n    del bob \"A\"\n\n[Try it here!](http://is.gd/gOba5R)\n\nWhat is happening there? First, we create two values: bob and i. Then we create a new thread with thread::spawn and pass a closure for it to execute. This closure is going to capture our variables bob as i.\n\nCapturing means different things for Bob and i. Because the Bob is non-Copy, it will be moved to the new thread. The i will be copied there. When the theead is running, we can modify original copy of i (if needed). It does not influence the copy that was passed to the thread.\n\nBob, however, is now owned by this new thread, and can not be modified unless the thread returns it back somehow. If we wanted, we could return it to the main thread over child.join() (the join waits for the thread to finish).\n\n    fn main() {\n        let mut bob = Bob::new(\"A\");\n\n        let child = thread::spawn(move || {\n            mutate(\u0026mut bob);\n            bob\n        });\n\n        println!(\"waiting for thread to end\");\n\n        if let Ok(bob) = child.join() {\n            println!(\"{:?}\", bob);\n        }\n    }\n\n    fn mutate(bob: \u0026mut Bob) {\n        bob.name = \"mutant\".to_string();\n    }\n    new bob \"A\"\n    waiting for thread to end\n    bob \"mutant\"\n    del bob \"mutant\"\n\n[Experiment more here!](http://is.gd/6EG4JL)\n\nOne could say that this does not change much the way we used to work with threads - we know not to share same memory location between threads without some kind of synchronisation. The difference here is that Rust can enforce these rules at compile-time.\n\nOf course, more things are possible in Rust, for example, the channels can be used for sending and receiving data between threads in more efficient ways. More is available in [official threading documentation](http://doc.rust-lang.org/std/thread/), [channel documentation](http://doc.rust-lang.org/std/sync/mpsc/), and [the book](http://doc.rust-lang.org/1.0.0-beta.5/book/concurrency.html).\n### 还有什么?\n\n通过这部分我们熟悉了Rust的ownership系统，应该可以开始阅读文档开发安全的应用程序了。\n\n但是到目前为止我们还完全没有讨论Rust的borrowing系统，在这个指南的第二部分我们会学习到为什么我们需要borrowing以及怎么更好的利用borrowing。\n","Tags":["Rust"],"CreateTime":1440475447,"EditTime":1440475447,"UpdateTime":1440475447,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":72}