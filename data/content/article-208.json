{"Id":208,"Title":"Golang编程经验总结","Slug":"2015-05-05-1","Text":"## 如何选择web框架：\n\n首先Golang语言开发web项目不一定非要框架，本身已经提供了Web开发需要的一切必要技术。当然如果想要ruby里面Rail那种高层次全栈式的MVC框架，\n Golang里面暂时没有，但是不是所有人都喜欢这种复杂的框架。Golang里面一些应用层面的技术需要自己去组装，比如session，cache, log等等. 可选择的web框架有martini， goji等，都是轻量级的。\n\n## Golang的web项目中的keepalive\n\n关于keepalive, 是比较复杂的， 注意以下几点：\n\n1. `http1.1` 默认支持keepalive， 但是不同浏览器对keepalive都有个超时时间， 比如firefox,默认超时时间115秒， 不同浏览器不一样；\n2. `Nginx`默认超时时间75秒；\n3. `golang`默认超时时间是无限的\n \n\n要控制golang中的keepalive可以设置读写超时， 举例如下：\n \n\n    server := \u0026http.Server{\n        Addr:           \":9999\",\n        Handler:        framework,\n        ReadTimeout:    32 * time.Second,\n        WriteTimeout:   32 * time.Second,\n        MaxHeaderBytes: 1 \u003c\u003c 20,\n    }\n    server.ListenAndServe()\n\n## github.com/go-sql-driver/mysql使用主意事项:\n\n这是使用率极高的一个库\n\n在用它进行事务处理的情况下， 要注意一个问题， 由于它内部使用了连接池， 使用事务的时候如果没有Rollback或者Commit， 这个取出的连接就不会放回到池子里面， 导致的后果就是连接数过多， 所以使用事务的时候要注意正确地使用。\n\n## github.com/garyburd/redigo/redis使用注意事项：\n\n这也是一个使用率极高的库\n\n同样需要注意，它是支持连接池的， 所以最好使用连接池， 正确的用法是这样的：\n\n\tfunc initRedis(host string) *redis.Pool {\n\t\treturn \u0026redis.Pool{\n\t\t\tMaxIdle: 64,\t\n\t\t\tIdleTimeout: 60 * time.Second,\n\t\t\tTestOnBorrow: func(c redis.Conn, t time.Time) error {\n\t\t\t\t_, err := c.Do(\"PING\")\n\n\t\t\t\treturn err\n\t\t\t},\n\t\t\tDial: func() (redis.Conn, error) {\n\t\t\t\tc, err := redis.Dial(\"tcp\", host)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\t_, err = c.Do(\"SELECT\", config.RedisDb)\n\n\t\t\t\treturn c, err\n\t\t\t},\n\t\t}\n\t}\n\n另外使用的时候也要把连接放回到池子里面, 否则也会导致连接数居高不下。用完之后调用rd.Close()， 这个Close并不是真的关闭连接，而是放回到池子里面。\n\n## 如何全局捕获panic级别错误:\n\n\tserver := \u0026http.Server{\n\t\tAddr:           \":9999\",\n\t\tHandler:        framework,\n\t\tReadTimeout:    32 * time.Second,\n\t\tWriteTimeout:   32 * time.Second,\n\t\tMaxHeaderBytes: 1 \u003c\u003c 20,\n\t}\n\tserver.ListenAndServe()\n\n+ 需要注意的是捕获到pannic之后， 程序的执行点不会回到触发pannic的地方，需要程序再次执行， 一些框架支持这一点，比如martini里面有c.Next()。\n+ 如果程序main里启动了多个goroutine， 每个goroutine里面都应该捕获pannic级别错误， 否则某个goroutine触发panic级别错误之后，整个程序退出， 这是非常不合理的。\n\n## 最容易出错的地方：\n\n使用指针，但是没有判断指针是否为nil， Golang中array， struct是值语义， slice，map， chanel是引用传递。\n\n## 如何获取程序执行栈:\n    defer func() {\n\t\tif err := recover(); err != nil {\n\t\t\tvar st = func(all bool) string {\n\t\t\t\t// Reserve 1K buffer at first\n\t\t\t\tbuf := make([]byte, 512)\n\n\t\t\t\tfor {\n\t\t\t\t\tsize := runtime.Stack(buf, all)\n\t\t\t\t\t// The size of the buffer may be not enough to hold the stacktrace,\n\t\t\t\t\t// so double the buffer size\n\t\t\t\t\tif size == len(buf) {\n\t\t\t\t\t\tbuf = make([]byte, len(buf)\u003c\u003c1)\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\t\t\t\t}\n\n\t\t\t\treturn string(buf)\n\t\t\t}\n\t\t\tlib.Log4e(\"panic:\" + toString(err) + \"\\nstack:\" + st(false))\n\t\t}\n\t}()\n\n具体方法就是调用\n \n     runtime.Stack\n\n## 如何执行异步任务：\n\n比如用户提交email:\n\n给用户发邮件， 发邮件的步骤是比较耗时的， 这个场景适合可以使用异步任务：\n\n\tresult := global.ResponseResult{ErrorCode: 0, ErrorMsg: \"GetInviteCode success!\"}\n\trender.JSON(200, \u0026result)\n\tgo func() {\n\t\ttype data struct {\n\t\t\tUrl string\n\t\t}\n\t\tname := \"beta_test\"\n\t\tsubject := \"We would like to invite you to the private beta of Screenshot.\"\n\t\turl := config.HttpProto + r.Host + \"/user/register/\" + *uniqid\n\t\thtml := ParseMailTpl(\u0026name, \u0026beta_test_mail_content, data{url})\n\t\te := this.SendMail(mail, subject, html.String())\n\t\tif e != nil {\n\t\t\tlib.Log4w(\"GetInviteCode, SendMail faild\", mail, uniqid, e)\n\t\t} else {\n\t\t\tlib.Log4w(\"GetInviteCode, SendMail success\", mail, uniqid)\n\t\t}\n\t}()\n\n思路是启动一个goroutine执行异步的操作\n\n当前goroutine继续向下执行。特别需要注意的是新启动的个goroutine如果对全局变量有读写操作的话，需要注意避免发生竞态条件， 可能需要加锁。\n\n## 如何使用定时器：\n\n通常情况下, 写一些定时任务需要用到crontab， 在Golang里面是不需要的， 提供了非常好用的定时器。举例如下：\n\n\tfunc Init() {\n\t\tticker := time.NewTicker(30 * time.Minute)\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase c := \u003c-global.TaskCmdChannel:\n\t\t\t\tswitch *c {\n\t\t\t\tcase \"a\":\n\t\t\t\t\t//todo\n\t\t\t\t}\n\t\t\tcase c := \u003c-global.TaskImageMessageChannel:\n\t\t\t\tm := new(model.TaskModel)\n\t\t\t\tm.Init()\n\t\t\t\tm.CreateImageMessage(c)\n\t\t\t\tm = nil\n\t\t\tcase \u003c-ticker.C:\n\t\t\t\tm := new(model.TaskModel)\n\t\t\t\tm.Init()\n\t\t\t\tm.CleanUserExpiredSessionKey()\n\t\t\t\tm = nil\n\t\t\t}\n\t\t}\n\t}\n\n## 多goroutine执行如果避免发生竞态条件：\nData races are among the most common and hardest to debug types of bugs in concurrent systems. A data race occurs when two goroutines access the same variable concurrently and at least one of the accesses is a write. See the The Go Memory Model for details.\n\n官方相关说明：\n\n+ http://blog.golang.org/race-detector\n+ http://golang.org/ref/mem\n\n多goroutine执行，访问全局的变量，比如map，可能会发生竞态条件，如何检查呢？首先在编译的时候指定 -race参数，指定这个参数之后，编译出来的程序体积大一倍以上， 另外cpu，内存消耗比较高，适合测试环境， 但是发生竞态条件的时候会panic，有详细的错误信息。go内置的数据结构array，slice，map都不是线程安全的。\n\n## 没有设置runtime.GOMAXPROCS会有竞态条件的问题吗？\n\n答案是没有\n\n因为没有设置runtime.GOMAXPROCS的情况下， 所有的goroutine都是在一个原生的系统thread里面执行， 自然不会有竞态条件。\n\n## 如何充分利用CPU多核：\n\n    runtime.GOMAXPROCS(runtime.NumCPU() * 2)\n\n以上是根据经验得出的比较合理的设置。\n\n## 解决并发情况下的竞态条件的方法：\n1.  channel， 但是channel并不能解决所有的情况，channel的底层实现里面也有用到锁， 某些情况下channel还不一定有锁高效， 另外channel是Golang里面最强大也最难掌握的一个东西， 如果发生阻塞不好调试。\n2.  加锁， 需要注意高并发情况下，锁竞争也是影响性能的一个重要因素， 使用读写锁，在很多情况下更高效， 举例如下：\n\n  code:\n\n\t    var mu sync.RWMutex\n\n\t    ...\n\n\t\tmu.RLock()\n\t\tdefer mu.RUnlock()\n\t\tconns := h.all_connections[img_id]\n\n\t\tfor _, c := range conns {\n\t\t\tif c == nil /*|| c.uid == uid */ {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tselect {\n\t\t\tcase c.send \u003c- []byte(message):\n\t\t\tdefault:\n\t\t\t\th.conn_unregister(c)\n\t\t\t}\n\t\t}\n\n  使用锁有个主意的地方是避免死锁，比如循环加锁。\n\n3. 原子操作（CAS）, Golang的atomic包对原子操作提供支持，Golang里面锁的实现也是用的原子操作。\n\n\n## 获取程序绝对路径：\n\nGolang编译出来之后是独立的可执行程序,不过很多时候需要读取配置，由于执行目录有时候不在程序所在目录，路径的问题经常让人头疼，正确获取绝对路径非常重要， 方法如下：\n\n\tfunc GetCurrPath() string {\n\t\tfile, _ := exec.LookPath(os.Args[0])\n\t\tpath, _ := filepath.Abs(file)\n\t\tindex := strings.LastIndex(path, string(os.PathSeparator))\n\t\tret := path[:index]\n\t\treturn ret\n\t}\n\n## Golang函数默认参数：\n\n大家都知道Golang是一门简洁的语言，不支持函数默认参数. 这个特性有些情况下确实是有用的，如果不支持，往往需要重写函数，或者多写一个函数。其实这个问题非常好解决， 举例如下：\n\n\tfunc (this *ImageModel) GetImageListCount(project_id int64,  paramter_optional ...int) int {\n\t\tvar t int\n\n\t\texpire_time := 600\n\t\tif len(paramter_optional) \u003e 0 {\n\t\t\texpire_time = paramter_optional[0]\n\t\t}\n\t\t...\n\t}\n\n\n## 性能监控：\n\n\tgo func() {\n\t\tprofServeMux := http.NewServeMux()\n\t\tprofServeMux.HandleFunc(\"/debug/pprof/\", pprof.Index)\n\t\tprofServeMux.HandleFunc(\"/debug/pprof/cmdline\", pprof.Cmdline)\n\t\tprofServeMux.HandleFunc(\"/debug/pprof/profile\", pprof.Profile)\n\t\tprofServeMux.HandleFunc(\"/debug/pprof/symbol\", pprof.Symbol)\n\t\terr := http.ListenAndServe(\":7789\", profServeMux)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\n接下来就可以使用go tool pprof分析。\n\n## 如何进行程序调试：\n\n对于调试，每个人理解不一样，\n\n如果要调试程序功能， 重新编译即可， Golang的编译速度极快。如果在开发的时候调试程序逻辑， 一般用log即可， Golang里面最好用的log库是log4go， 支持log级别。如果要进行断点调试， GoEclipse之类的是支持的， 依赖Mingw和GDB， 我个人不习惯这种调试方法。\n\n## 守护进程（daemon）\n\n下面给出完整的真正可用的例子：\n\n\tpackage main\n\t \n\timport (\n\t    \"fmt\"\n\t    \"log\"\n\t    \"os\"\n\t    \"runtime\"\n\t    \"syscall\"\n\t    \"time\"\n\t)\n\t \n\tfunc daemon(nochdir, noclose int) int {\n\t    var ret, ret2 uintptr\n\t    var err syscall.Errno\n\t \n\t    darwin := runtime.GOOS == \"darwin\"\n\t \n\t    // already a daemon\n\t    if syscall.Getppid() == 1 {\n\t        return 0\n\t    }\n\t \n\t    // fork off the parent process\n\t    ret, ret2, err = syscall.RawSyscall(syscall.SYS_FORK, 0, 0, 0)\n\t    if err != 0 {\n\t        return -1\n\t    }\n\t \n\t    // failure\n\t    if ret2 \u003c 0 {\n\t        os.Exit(-1)\n\t    }\n\t \n\t    // handle exception for darwin\n\t    if darwin \u0026\u0026 ret2 == 1 {\n\t        ret = 0\n\t    }\n\t \n\t    // if we got a good PID, then we call exit the parent process.\n\t    if ret \u003e 0 {\n\t        os.Exit(0)\n\t    }\n\t \n\t    /* Change the file mode mask */\n\t    _ = syscall.Umask(0)\n\t \n\t    // create a new SID for the child process\n\t    s_ret, s_errno := syscall.Setsid()\n\t    if s_errno != nil {\n\t        log.Printf(\"Error: syscall.Setsid errno: %d\", s_errno)\n\t    }\n\t    if s_ret \u003c 0 {\n\t        return -1\n\t    }\n\t \n\t    if nochdir == 0 {\n\t        os.Chdir(\"/\")\n\t    }\n\t \n\t    if noclose == 0 {\n\t        f, e := os.OpenFile(\"/dev/null\", os.O_RDWR, 0)\n\t        if e == nil {\n\t            fd := f.Fd()\n\t            syscall.Dup2(int(fd), int(os.Stdin.Fd()))\n\t            syscall.Dup2(int(fd), int(os.Stdout.Fd()))\n\t            syscall.Dup2(int(fd), int(os.Stderr.Fd()))\n\t        }\n\t    }\n\t \n\t    return 0\n\t}\n\t \n\tfunc main() {\n\t    daemon(0, 1)\n\t    for {\n\t        fmt.Println(\"hello\")\n\t        time.Sleep(1 * time.Second)\n\t    }\n\t \n\t}\n\n## 进程管理：\n\n个人比较喜欢用supervisord来进行进程管理，支持进程自动重启，supervisord是一个python开发的工具，用pip安装即可。\n\n## 代码热更新：\n\n代码热更新一直是解释型语言比较擅长的，Golang里面不是做不到，只是稍微麻烦一些，就看必要性有多大。如果是线上在线人数很多， 业务非常重要的场景， 还是有必要， 一般情况下没有必要。\n\n1. 更新配置.\n  因为配置文件一般是个json或者ini格式的文件，是不需要编译的，\n  在线更新配置还是相对比较容易的， 思路就是使用信号， 比如SIGUSER2， 程序在信号处理函数中重新加载配置即可。\n\n2. 热更新代码.\n 目前网上有多种第三方库， 实现方法大同小异。先编译代码(这一步可以使用fsnotify做到监控代码变化，自动编译)，关键是下一步graceful restart进程，实现方法可参考：http://grisha.org/blog/2014/06/03/graceful-restart-in-golang/ 也是创建子进程，杀死父进程的方法。\n\n## 条件编译:\n\n条件编译时一个非常有用的特性，一般一个项目编译出一个可执行文件，但是有些情况需要编译成多个可执行文件，执行不同的逻辑，这比通过命令行参数执行不同的逻辑更清晰.比如这样一个场景，一个web项目，是常驻进程的， 但是有时候需要执行一些程序步骤初始化数据库，导入数据，执行一个特定的一次性的任务等。假如项目中有一个main.go, 里面定义了一个main函数，同目录下有一个task.go函数，里面也定义了一个main函数，正常情况下这是无法编译通过的， 会提示“main redeclared”。解决办法是使用go build 的-tags参数。步骤如下(以windows为例说明)：\n\n1. 在main.go头部加上 `// +build main`\n2. 在task.go头部加上`// +build task`\n3. 编译住程序：`go build -tags 'main'`\n4. 编译task：`go build -tags 'task' -o task.exe`\n\n## 将项目有关资源文件打包进主程序：\n使用`go generate`命令，参考`godoc`的实现。\n\n## 与C/C++ 交互\n1. Cgo,Cgo支持Golang和C/C++混编， 在Golang里面使用pthread，libuv之类的都不难，github上也有相关开源代码；\n2. Swig,很多库都用Swig实现了Golang的绑定，Swig也可以反向回调Golang代码。\n3. syscall包， 该包让你以Golang的方式进行系统编程，不需要再使用C/C++，syscall提供了很多系统接口，比如epoll，原始socket套接字编程接口等。\n\n## 其他：\n\n近几年最热门的技术之一Docker是用Golang开发的,已经有相关的书出版， 对系统运维，云计算感兴趣的可以了解。\n\n转自[yxw的专栏](http://blog.csdn.net/yxw2014/article/details/43451625)","Tags":["golang"],"CreateTime":1430792477,"EditTime":1430792548,"UpdateTime":1430792477,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":279}