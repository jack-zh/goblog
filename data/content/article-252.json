{"Id":252,"Title":"Python发送邮件处理","Slug":"2016-02-28-1","Text":"\u003e 今天要说的是Python发送邮件，其实发送邮件的代码都差不多，但是使用其他的邮件服务器，还是有很多的限制，这里就简要说明一下使用其他的邮件服务器发送邮件和自己建立邮件服务器发送邮件，主要是贴代码。\n\n\u003e 系统 Ubuntu 14.04.3\n\n\n## 用163服务器发送邮件\n\n优点：少量邮件需要发送的时候还是可以的，不用自建服务器，减少了服务器的开销\n\n缺点：频繁发送会有问题，网络延迟严重，异步IO回调慢等\n\n\u003e 不要吐槽我用`start_new_thread`\n\n \n    # -*- coding: UTF-8 -*-\n    '''\n    jack.zh sen mail test.\n    '''\n    import thread        \n    import smtplib\n    from email.mime.text import MIMEText\n\n    from log import logger\n\n\tFrom_email = {\n\t    \"mail_host\" :\"smtp.163.com\",  #设置服务器\n\t    \"mail_user\" :\"user_name\",    #用户名\n\t    \"mail_pass\" :\"xxxxxxxx\",   #口令 \n\t    \"mail_postfix\" :\"163.com\"  #发件箱的后缀 \n\t}\n\t\n    def send_mail(to_list, sub, content):\n        me=\"my_name\"+\"\u003c\"+From_email[\"mail_user\"]+\"@\"+From_email[\"mail_postfix\"]+\"\u003e\"\n        msg = MIMEText(content,_subtype='html',_charset='utf-8')\n        msg['Subject'] = sub\n        msg['From'] = me\n        msg['To'] = \";\".join(to_list)\n        try:\n            server = smtplib.SMTP()\n            server.connect(From_email[\"mail_host\"])\n            server.login(From_email[\"mail_user\"],From_email[\"mail_pass\"])\n            server.sendmail(me, to_list, msg.as_string())\n            server.close()\n            return True\n        except Exception, e:\n            logger.error(str(e))\n            logger.error(str(to_list))\n            logger.error(str(sub))\n            logger.error(str(content))\n\n\n    def send_mail_thread(mailto_list, subject, msg):\n        if send_mail(mailto_list, subject, msg):\n            logger.info(\"send mail success.\") \n        else:\n            logger.error(\"send mail fail.\")\n            logger.error(subject)\n            logger.error(msg)\n\n\n    def util_send_email(msg, subject, emails):\n        thread.start_new_thread(send_mail_thread, (emails, subject, msg))\n\n\n    if __name__ == '__main__':\n        msg = \"msg\"\n\n        mailto_list=[\"zzh.coder@qq.com\"]\n        if send_mail(mailto_list,\"hello\", msg):\n            logger.error(\"yes\")\n        else:\n            logger.error(\"no\")\n    \n\n## 使用自建邮箱服务器发送`sendmail`\n\n安装邮件服务：\n\n    apt-get install sendmail sendmail-cf squirrelmail spamassassin mailman mailutils sharutils\n\n贴发送邮件代码：\n\n    #!/usr/bin/env python\n    #@author : zzh.coder@qq.com\n    #@desc: for mail sending.\n\n    import smtplib\n    import getopt\n    import sys\n    import os\n\n    from email.MIMEMultipart import MIMEMultipart\n    from email.MIMEBase import MIMEBase\n\n    from email.MIMEText import MIMEText\n    import email.Encoders as encoders\n\n\n    def send_mail(mail_from, mail_to, subject, msg_txt, files=[]):\n        # Create message container - the correct MIME type is multipart/alternative.\n        msg = MIMEMultipart('alternative')\n        msg['Subject'] = subject\n        msg['From'] = mail_from\n        msg['To'] = mail_to\n\n        # Create the body of the message (a plain-text and an HTML version).\n        #text = msg\n        html = msg_txt\n\n        # Record the MIME types of both parts - text/plain and text/html.\n        #part1 = MIMEText(text, 'plain')\n        part2 = MIMEText(html, 'html')\n\n        # Attach parts into message container.\n        # According to RFC 2046, the last part of a multipart message, in this case\n        # the HTML message, is best and preferred.\n        #msg.attach(part1)\n        msg.attach(part2)\n\n        #attachment\n        for f in files:\n            #octet-stream:binary data\n            part = MIMEBase('application', 'octet-stream')\n            part.set_payload(open(f, 'rb').read())\n            encoders.encode_base64(part)\n            part.add_header('Content-Disposition', 'attachment; filename=\"%s\"' % os.path.basename(f))\n            msg.attach(part)\n\n        # Send the message via local SMTP server.\n        s = smtplib.SMTP('localhost')\n        # sendmail function takes 3 arguments: sender's address, recipient's address\n        # and message to send - here it is sent as one string.\n\n        mailto_list = mail_to.strip().split(\",\")\n        if len(mailto_list) \u003e 1:\n            for mailtoi in mailto_list:\n                s.sendmail(mail_from, mailtoi.strip(), msg.as_string())\n        else:\n            s.sendmail(mail_from, mail_to, msg.as_string())\n\n        s.quit()\n        return True\n\n\n    def main():\n        files = []\n        try:\n            opts, args = getopt.getopt(sys.argv[1:], \"f:t:s:m:a:\")\n            for op, value in opts:\n                if op == \"-f\":\n                    mail_from = value\n                elif op == \"-t\":\n                    mail_to = value\n                elif op == \"-s\":\n                    subject = value\n                elif op == \"-m\":\n                    msg_txt = value\n                elif op == \"-a\":\n                    files = value.split(\",\")\n        except getopt.GetoptError:\n            print(sys.argv[0] + \" : params are not defined well!\")\n\n        print mail_from, mail_to, subject, msg_txt\n        if files:\n            send_mail(mail_from, mail_to, subject, msg_txt, files)\n        else:\n            send_mail(mail_from, mail_to, subject, msg_txt)\n\n    if __name__ == \"__main__\":\n        main()\n\n\nDemo over。\n\n后面的说明：\n\n+ 服务器需要接收邮件并处理等操作此处不说，那是一个比较庞大的问题了\n+ 自建服务器也有失败的可能，在配置senmail的时候有很多配置需要了解，这里不做详解，只提供思路\n+ 方法2完全可以指定发件箱的地址，在此发件箱去接收那边的回复邮件，手动处理\n+ 方法一和二都可以完整的使用邮件基本的所有功能，比如模版，附件等等","Tags":["Python"],"CreateTime":1455789529,"EditTime":1455789572,"UpdateTime":1455789529,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":111}