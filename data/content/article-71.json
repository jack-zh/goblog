{"Id":71,"Title":"C语言基础(2)-C语言简介","Slug":"2014-11-04-1","Text":"### C语言简介\n\n#### C语言的演化\n+ C语言的第一次发展在1969年到1973年之间。C之所以被称为C是因为C语言的很多特性是由一种更早的被称为B语言的编程语言中发展而来的，而B语言的前身是BCPL。\n+ BCPL语言由Martin Richards开发；B语言是Ken Thompson为第一个UNIX系统而于1970年在DEC PDP-7计算机上开发的。\n+ BCPL和B语言都是“无类型”的语言，而C语言提供了很多的数据类型。\n+ 到了1973年，C语言已经可以用来编写Unix操作系统的内核。这是第一次用C语言来编写操作系统的内核。丹尼斯·里奇（Dennis M.Ritchie 和Brian Kernighan在1978年出版了《C程序设计语言》（The C Programming Language，经常简称为“白皮书”或“K\u0026R”）。\n+ 1980年以后，贝尔实验室使得C变得更为广泛的流行，使得C一度成为了操作系统和应用程序编程的首选.\n\n#### C语言的版本\n+ K\u0026R C： 1978年Kernighan和Dennis M.Ritchie的《C程序设计语言》第一版出版。它介绍了下面的有关C语言版本的特性：\n  + `struct`数据类型\n  + `long int`数据类型去！\n  + `unsigned int`数据类型\n  * 把运算符=+改为+=，依次类推。因为=+使得编译器混淆。\n  * *K\u0026R C通常被作为C编译器所支持的最基本的C语言部分。虽然现在的编译器并不一定都完全遵循ANSI标准，但K\u0026R C作为C语言的最低要求仍然要编程人员掌握。但是无论怎样，现在使用广泛的C语言版本都已经与K\u0026R C相距甚远了，因为这些编译器都使用ANSI C标准。*\n+ ANSI C和ISO C：1989年，C语言被ANSI标准化。（ANSI X3.159-1989）。标准化的一个目的是扩展K\u0026R C。这个标准包括了一些新的特性。在K\u0026R出版后，一些新的特征被“非官方”的加到C语言中。\n  * void函数\n  * 函数返回`struct`或`union`类型\n  * `void *`数据类型\n  * *在ANSI标准化自己的过程中，一些新的特征被加了进去。ANSI也标准了函数库。ANSI C标准被ISO（国际标准化组织）采纳成为ISO 9899。ISO的第一个版本文件在1990年出版。《The Programming Language》第二版是基于ANSI C写的。*\n+ C99：在ANSI标准化后，C语言的标准在一段相当的时间内都保持不变，尽管C++继续在改进。（实际上，Normative Amendment1在1995年已经开发了一个新的C语言版本。但是这个版本很少为人所知。）标准在90年代才经历了改进，这就是ISO9899: 1999（1999年出版）。这个版本就是通常提及的C99。它被ANSI于2000年三月采用。在C99中包括的特性有：\n  * 对编译器限制增加了，比如源程序每行要求至少支持到 4095 字节，变量名函数名的要求支持到 63 字节 (extern 要求支持到 31)\n  * 预处理增强了。例如：\n    + 宏支持取参数 `#define Macro(...)`` __VA_ARGS__`\n    + 使用宏的时候，参数如果不写，宏里用 #,## 这样的东西会扩展成空串。(以前会出错的)\n    + 支持 // 行注释（这个特性实际上在C89的很多编译器上已经被支持了）\n  * 增加了新关键字 `restric`t, `inline`, `_Complex`, `_Imaginary`, `_Bool`\n    + 支持 `long long`, `long double _Complex`, `float _Complex` 这样的类型\n  * 支持 `\u003c: :\u003e \u003c% %\u003e %: %:%:` ，等等奇怪的符号替代，D\u0026E 里提过这个\n  * 支持了不定长的数组。数组的长度就可以用变量了。声明类型的时候呢,就用 `int a[*]` 这样的写法。不过考虑到效率和实现，这玩意并不是一个新类型。所以就不能用在全局里，或者 `struct union` 里面，如果你用了这样的东西，`goto` 语句就受限制了。\n  * 变量声明不必放在语句块的开头，`for` 语句提倡这么写 `for(int i=0;i\u003c100;++i)` 就是说，`int i` 的声明放在里面，`i` 只在 `for` 里面有效。\n  * 当一个类似结构的东西需要临时构造的时候，可以用 `(type_name){xx,xx,xx}` 这有点像 C++ 的构造函数\n  * 初始化结构的时候现在可以这样写:\n        struct {int a[3], b;} hehe[] =  { [0].a = {1}, [1].a = 2 };\n        struct {int a, b, c, d;} hehe =  { .a = 1, .c = 3, 4, .b = 5}  // 3,4 是对 .c,.d 赋值的\n  * 字符串里面，`/u` 支持 `unicode` 的字符\n  * 支持 16 进制的浮点数的描述\n  * 所以 `printf` `scanf` 的格式化串多支持了 `ll / LL` (VC6 里用的 I64) 对应新的 `long long` 类型。\n  * 浮点数的内部数据描述支持了新标准，这个可以用 `#pragma` 编译器指定\n  * 除了已经有的 `__line__` `__file__` 以外，又支持了一个 `__func__` 可以得到当前的函数名\n  * 对于非常数的表达式，也允许编译器做化简\n  * 修改了对于 `/` `%` 处理负数上的定义，比如老的标准里 `-22 / 7 = -3, -22 % 7 = -1` 而现在 `-22 / 7 = -4, -22 % 7 = 6`\n  * 取消了不写函数返回类型默认就是 `int` 的规定\n  * 允许 `struct` 定义的最后一个数组写做 `[]` 不指定其长度描述\n  * `const const int i`; 将被当作 `const int i`; 处理\n  * 增加和修改了一些标准头文件, 比如定义 `bool` 的 `\u003cstdbool.h\u003e` 定义一些标准长度的 `int` 的 `\u003cinttypes.h\u003e` 定义复数的 `\u003ccomplex.h\u003e` 定义宽字符的 `\u003cwctype.h\u003e` 有点泛型味道的数学函数 `\u003ctgmath.h\u003e` 跟浮点数有关的 `\u003cfenv.h\u003e`。`\u003cstdarg.h\u003e` 里多了一个 `va_copy` 可以复制 `...` 的参数。`\u003ctime.h\u003e` 里多了个 `struct tmx` 对 `struct tm` 做了扩展\n  * 输入输出对宽字符还有长整数等做了相应的支持\n  * *但是各个公司对C99的支持所表现出来的兴趣不同。当GCC和其它一些商业编译器支持C99的大部分特性的时候，微软和Borland却似乎对此不感兴趣。*\n \n\n#### C语言哲学  \n  + 相信程序员(Trust the programmer)\n  + 不妨碍程序员行需行之事(Don't prevent the programmer from doing what needs to be done)\n  + 保持语言简洁精炼干(Keep the language small and simple)\n  + 为操作提供唯一方式(Provide only one way to do an operation)\n  + 速度优于可移植性(Make it fast, even if it is not guaranteed to be portable)","Tags":["C"],"CreateTime":1415089418,"EditTime":1415094556,"UpdateTime":1415089418,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":40}