{"Id":202,"Title":"C基础-理解c语言的sizeof","Slug":"2015-04-24-1","Text":"一起看看sizeof。c语言通过类型长度来达到指针的灵活性，我觉得，某种意义上讲，是sizeof功能成就了c指针。\n\n![](/static/upload/201504241633078.jpg)\n\n## 基础知识\n\n首先，要知道**`sizeof` 是关键字不是函数**。也就是说，用到sizeof的地方其实在编译阶段就已经计算出结果了，**不是（也不能）在程序运行时动态地计算**。换句话说，代码中同一个sizeof的调用只能输出一个值，而不可能有其它别的值（后文会看到，其实变长数组是颠覆了这个规律的）。再换句话说，就是反汇编就能看到`sizeof`调用的结果！\n\n其次，`sizeof`的计算结果跟编译器的字节对齐方式有关。在默认情况下，c编译器为每一个变量按其类型大小分配空间，这种默认方式是可以修改的，通过`#pragma pack (n)`或者`__attribute((aligned (n)))`。\n\n最后，要知道对齐是个性能要求，不是必须的。我们这里仅考虑gcc编译器，不考虑vc编译器。比如ia32下，gcc对`double`、`long long`这样的8字节变量，仍然是按4字节对齐，即使设置`#pragma pack(8)`的情况下。到了x64_64下，开始统一了，全部真的都是按照类型大小对齐的了。至于为何跟性能相关，我们以后讲到`cpu cache`时再重新考虑这个问题，现在我们只要知道，因为地址总线放地址时肯定都是对齐的，所以不对齐的话会增加读取周期就行了。\n\n下文全部以`gcc+x86_64+`结构体，来求解`sizeof`。\n\n## 计算原理\n\n对于每个数据类型都有一个`align_size`，其实就是类型大小：`char`是1，`short`是2，`int`是4，`long`是8，`double`是8，`long double`是16。\n\n一个基本原则就是结构体里的每个成员都能按照自己类型的`align_size`去对齐。计算过程如下：\n\n + 计算出该结构体里面成员中最大的`align_size`，此也即该结构体的`align_size`。\n + 该结构体中得每个成员都按照自己的`align_size`去对齐，空余部分会做填充处理，成员是数组的话，其`align_size`就是数组元素的`align_size`。成员又是另一个结构体的话，用此计算方法先求出另一个结构体的`align_size`。\n + 整个结构体是首尾都按照该结构体的`align_size`对齐的，即手部和尾部的空余部分会做填充处理\n\n很显然，编译器在计算过程中会自动填充空余部分。否则，想想一个结构体，内部空间都不是连续填充的，会让编译器分配空间时疯掉的。\n\n## 代码示例\n\n我们举例看看，long double的类型大小是16字节。\n\n\tstruct S{\n\t\tchar a;\n\t\tlong double b[1];\n\t};\n\tstruct S sample;\n\tprintf(\"%ld，%ld\\n\", sizeof(struct S), sizeof(sample.b));\n\n打印结果是`32，16`。因为结构体成员中最大的`align_size`（数组的话，看数组里面的单个元素的`align_size`）是16字节，所以整个结构体就是16字节对齐的，这样char也自动填充到16字节了。故，总的结构体大小就是32字节了。\n\n那么，将结构体的`b[1]`改为`b[0]`呢？也就是说，结构体内部引入**零数组成员**。\n\n此时结果是`16，0`。也就是说该结构体还是16字节对齐，说明零数组元素还是参与了计算结构体的`align_size`，但是没有占用空间。\n\n那么，还是维持为`b[0]`，我们利用零数组的特性来放点数据呢？改为：\n\n\tstruct S *sample =(struct S*)malloc(sizeof(long double) * 1234 +sizeof(struct S));\n\n结果还是`16，0`。也就是说跟零数组的数据大小没有关系，`sizeof`是感知不到的。\n\n那么，如果不用`malloc`，直接初始化赋值呢？因为我们知道字符串数组是可以这么做的，但是作为结构体成员呢？改为`struct s sample={'1',{1,2,3}}`这种方式：\n\n\t#include \u003cstdio.h\u003e\n\tstruct S{\n\t\tchar a;\n\t\tlong double b[];\n\t};\n\tstruct S sample={'1',{1,2,3}};\n\tint main ()\n\t{\n\t\tprintf(\"%Lf, %Lf, %Lf\\n\", sample.b[0], sample.b[1], sample.b[2]);\n\t\t//printf(\"%ld,%ld\\n\", sizeof(sample),sizeof(sample.b));//加上此句会编译不过\n\t\treturn 0;\n\t}\n\n初始化赋值是正常的，但是`sizeof`那句编译不过：\n\n\terror: invalid application of ‘sizeof’ to incomplete type ‘long double[]’\n\n另外，对于`b[]`这种非零数组成员的结构体必须为全局静态定义，否则编译不过：\n\n\terror: non-static initialization of a flexible array member\n\n必须全局静态存储区间存放，才允许初始化赋值，是可以理解的，因为字符串数组（即使是定义在函数内部也能直接赋值。区别是`char *str=\"123\"`是存放在全局静态空间，`char str[]=\"123\"`是存放在栈空间，并且后者的`sizeof`是能得出数组大小的）就是这么实现的。但是在加上`sizeof(sample.b)`就编译不过，难道是gcc没有做好？因为编译期间是可以通过计算全局静态区间的b[]大小算出来的。（为方便下文描述，这种形式我们称为非零长数组）\n\n那么，再看看改为`b[0]`会怎么样。此时是零长数组了，所以不必放在全局静态存储空间了。\n\n\n\t#include \u003cstdio.h\u003e\n\tint main ()\n\t{\n\t\tstruct S{\n\t\t\tchar a;\n\t\t\tlong double b[0];\n\t\t};\n\t\tstruct S sample={'1',{1,2,3}};\n\t\tprintf(\"%Lf, %Lf, %Lf\\n\", sample.b[0], sample.b[1], sample.b[2]);\n\t\tprintf(\"%ld,%ld\\n\", sizeof(sample),sizeof(sample.b));\n\t\treturn 0;\n\t}\n\n`b[0]`表面上可以正常初始化赋值，但是实际没有做处理的：编译期间可以看到gcc的数组越界初始化警告：（此时会体会到`-Werror`的好处了）\n\n\twarning: excess elements in array initializer [enabled by default]\n\twarning: (near initialization for ‘sample.b’) [enabled by default]\n\n带着警告的运行实现结果：\n\n\t0.000000, -0.000000, 0.000000\n\t16,0\n\n显然，`b[]`中3个数值没有正确处理。而`sizeof`的运算结果和上面的一致：还是无法感知数组大小。\n\n我们最后抛开结构体内成员限制（下文有原因），观察下变长数组：元素个数是一个变量（跟上面的`b[]`形式的非零长数组是有区别的）。它实际就是在栈空间（既然变长，肯定不能是全局静态空间）分配空间的。\n\n\t#include\u003cstdio.h\u003e\n\t\n\tint main(void)\n\t{\n\t\tint i;\n\t\tscanf(\"%d\", \u0026i);\n\t\tchar str[i];\n\t\tprintf(\"sizeof(str[%d])=%d\\n\",i,sizeof(str));\n\t\treturn 0;\n\t}\n\t\n如果输入`i`为3，结果为`3，3`。对`sizeof`而言，变长数组是维持了数组的`sizeof`特性，毕竟以前普通数组就是这样的效果！需要注意的是，变长数组只能定义在栈空间，不能全局静态存储空间或堆空间定义，而且由编译器会尽量放到栈帧局部变量部分的最后。放在最后，是为了方便扩展，那如果块范围内有多个变长数组呢？多个就一个一个放到最后，逐个顺序扩展（后面会有示例）。\n\n那如果变长数组作为入参呢？也是维持了数组的`sizeof`特性，还是和以前一样：对入参做`sizeof`，结果就是指针长度8。（此处仅考虑一维的情况，后文会考虑多维）\n\n涉及多维数组以及指针的内容，我们以后再讲。。。\n\n## 关于变长数组的补充\n\n变长数组（`variable length array`，即`VLA`）是c99引入的，我们上面看过一个例子了。现在再看一个：\n\n\t#include\u003climits.h\u003e\n\t#include\u003cstdio.h\u003e\n\t\n\tint main(int argc, char *argv[])\n\t{\t\n\t\tint i, n;\n\t\tn = atoi(argv[1]);\n\t\tchar str[n+1];\n\t\tfor (i = 0; i \u003c n; i++) {\n\t\t\tstr[i] = (char)('0' + i);\n\t\t}\n\t\tstr[n]='\\0';\n\t\tprintf(\"str is %s\\n\", str);\n\t\tprintf(\"str:%ld, %ld\\n\",sizeof(str[ULONG_MAX]),sizeof(str));\n\t\treturn 0;\n\t}\n\n当入参`argv[1]`为“3”时，看结果：\n\n\tstr is 012\n\tstr:1, 4\n\n可见，对于变长数组，感知到了数组大小！另外，我们看到`sizeof(str[ULONG_MAX])`也是可以的，看来计算时是只看元素类型大小，不考虑数组下标范围的！\n\n**总结变长数组的特点**，如下：\n\n + 1）必须在块范围内定义，不能在文件范围内定义（static修饰）或全局引用（extern修饰），即保证只能是栈空间分配；\n + 2）变长数组不能作结构体或者联合的成员，只能以独立数组方式存在；\n + 3）作用域为块范围，即其生存周期为所在块入栈和出栈之间的时间内；\n\n第二个特点也是我们**不去设置变长数组成员的结构体的原因**。\n\n其实有个函数功能和变长数组类似，就是`void alloca(size_t size)`。它也是在栈中分配size字节大小的空间，当本栈帧退出时释放空间。要注意的是，`alloca()`执行失败时，不会返回一个`NULL`指针，因为它本质就是一条调整栈顶指针的汇编指令，不能有丰富的返回值。汇编实现就导致了很差的移植性，所以，相对而言，这种场景更应该用变长数组。\n\n最后看下，变长数组在多维时的处理。看代码：\n\n\t#include \u003cstdio.h\u003e\n\tint main( void )\n\t{\n\t\tint i;\n\t\tfor(i=0;i\u003c2;i++) {\n\t\t\tint m,n;\n\t\t\tscanf(\"%d %d\", \u0026m,\u0026n);\n\t\t\tchar a[m][n];\n\t\t\tchar (*p)[n]=a;\n\t\t\tprintf(\"%ld %ld\", sizeof(a), sizeof(*p));\n\t\t}\n\t\treturn 0;\n\t}\n\n输入`3，4`时，结果是`12，4`；输入`5，6`时，结果是`30，6`。\n\n可见，变长数组在各个维度上都很好地维持了普通数组的`sizeof`特性。另外，通过for循环也看到了块范围内变长数组可使用的重复性。\n\n对于二维变长数组作为函数参数也维持了普通二维数组的效果：\n\n\n\t#include \u003cstdio.h\u003e\n\t\n\tvoid func(int,int,long double a[*][*]);\n\tvoid func2(long double a[2][6]);\n\t\n\tint main(void)\n\t{\n\t\t int m=2, n=3;\n\t\t long double a[m][m*n];\n\t\t func(m,n,a);\n\t\t long double b[2][6];\n\t\t func2(b);\n\t\t return 0;\n\t}\n\n\tvoid func(int m,int n,long double x[m][m*n])\n\t{\n\t\t printf(\"%ld %ld %ld\\n\",sizeof(x), sizeof(x[0]), sizeof(x[0][0]));\n\t}\n\t\n\tvoid func2(long double x[2][6]){\n\t\t printf(\"%ld %ld %ld\\n\",sizeof(x), sizeof(x[0]), sizeof(x[0][0]));\n\t}\n\t\n输出结果表明，两种处理是一样的：\n\n\t8 96 16\n\t8 96 16\n\n可见，变长多维数组维持普通多维数组一样的效果：直接对入参取`sizeof`的结果是指针长度8，其它都能正常感知数组大小。为何数组做入参时，sizeof就识别不出来，只能做指针大小处理呢？看懂下面这个例子，就明白了：\n\n\n\t#include \u003cstdio.h\u003e\n\t\n\tvoid func(long double x[][3]){\n\t\t  printf(\"%ld %ld %ld\\n\",sizeof(x), sizeof(x[0]), sizeof(x[0][0]));\n\t}\n\t\n\tint main(void)\n\t{\n\t\t  long double a[1][3];\n\t\t  long double b[2][3];\n\t\t  func(a);\n\t\t  func(b);\n\t\t  return 0;\n\t}\n\t\n没错，是gcc编译器支持的这种数组第一维可以省略的参数形式的后遗症。\n\n## 总结\n\n我们最后做个总结。对结构体的成员而言，零数组用在堆空间，非零数组用在全局静态空间，变长数组不能用（独立的变长数组用在栈空间）。对sizeof处理而言，只有变长数组（以及非零数组的独立形式）以栈为存储空间的处理维持了普通数组的特性，能够感知实际的数组大小，从这个角度看，`sizeof`也沾上了函数色彩","Tags":["C"],"CreateTime":1429864174,"EditTime":1429864406,"UpdateTime":1429864174,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":233}