{"Id":216,"Title":"Tornado异步与延迟任务","Slug":"2015-06-08-1","Text":"曾经研究过Tornado异步操作，然而一番研究后发现要使一个函数异步化的最好方法就是采用相关异步库，但目前很多功能强大的库都不在此列。经过一番查找文档和搜索示范，终于发现了`ThreadPoolExecutor`模块和`run_on_executor`装饰器。用法就是建立线程池，用`run_on_executor`装饰的函数即运行在其中线程中，从而从主线程中分离出来，达到异步的目的。\n另外，`Tornado`的`IOLoop`实例还有`IOLoop.add_callback(callback, *args, **kwargs)`方法，文档中的描述如下：\n\n\u003e Calls the given callback on the next I/O loop iteration.\n\n\u003e It is safe to call this method from any thread at any time, except from a signal handler. Note that this is the only method in IOLoop that makes this thread-safety guarantee; all other interaction with theIOLoop must be done from that IOLoop ‘s thread. add_callback() may be used to transfer control from other threads to the IOLoop ‘s thread.\n\n意思就是在执行`add_callback`方法后马上就会执行下一行代码，而`callback`函数将在下一轮事件循环中才调用，从而就能实现延迟任务。在Web APP中应付HTTP请求时，当有一些耗时操作并不需要返回给请求方时，就可以采用延迟任务的形式，比如发送提醒邮件。\n\n示范代码如下：\n\n    #!/bin/env python\n    import tornado.httpserver\n    import tornado.ioloop\n    import tornado.options\n    import tornado.web\n    import tornado.httpclient\n    import tornado.gen\n    from tornado.concurrent import run_on_executor\n    # 这个并发库在python3自带;在python2需要安装sudo pip install futures\n    from concurrent.futures import ThreadPoolExecutor\n    import time\n    from tornado.options import define, options\n    define(\"port\", default=8002, help=\"run on the given port\", type=int)\n\n    class SleepHandler(tornado.web.RequestHandler):\n        executor = ThreadPoolExecutor(2)\n\n        def get(self):\n            # 这样将在下一轮事件循环执行self.sleep\n            tornado.ioloop.IOLoop.instance().add_callback(self.sleep)\n            self.write(\"when i sleep\")\n\n        @run_on_executor\n        def sleep(self):\n            time.sleep(5)\n            print(\"yes\")\n            return 5\n\n\n    if __name__ == \"__main__\":\n        tornado.options.parse_command_line()\n        app = tornado.web.Application(handlers=[\n                (r\"/sleep\", SleepHandler), ])\n        http_server = tornado.httpserver.HTTPServer(app)\n        http_server.listen(options.port)\n        tornado.ioloop.IOLoop.instance().start()\n\n\n当然，当需要用到一部网络请求IOLoop的时候，这样做还是最好的：\n\n    class GetRemoteIpHandler(tornado.web.RequestHandler):\n        @tornado.web.asynchronous\n        def post(self):\n            client = tornado.httpclient.AsyncHTTPClient()\n\n            headers = self.request.headers\n            if \"X-Real-Ip\" in headers:\n                remote_ip = headers['X-Real-Ip']\n            else:\n                remote_ip = self.request.remote_ip\n            \n            data_str = urllib.urlencode({\"ip\": self.get_argument(\"ipstr\", remote_ip)})\n            url = \"http://ip.taobao.com/service/getIpInfo.php?\" + data_str\n            client.fetch(url, callback=self.on_response)\n\n        def on_response(self, response):\n            jsonObj = json.loads(response.body)\n            self.write(response.body)\n            self.finish()","Tags":["python"],"CreateTime":1433746851,"EditTime":1433746851,"UpdateTime":1433746851,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":413}