{"Id":241,"Title":"Elixir入门教程\u003c上\u003e","Slug":"2015-10-07-1","Text":"\u003cdiv id=\"ztoc\"\u003e\u003c/div\u003e\n\n## 1. 简介\n\n### 1.1 安装\n+ Windows平台，Elixir提供了exe安装程序，自己去下载\n+ Windows Mac OS 和Linux 请先安装Erlang17+，再下载Elixir make\n\n### 1.2 交互模式\n 运行`iex`\n\n### 1.3 执行脚本\n\n`elixir simple.exs`\n\n## 2. 基本数据类型\n\n本章介绍Elixir一些基本的类型， 如：整型（integer），浮点型（float），布尔（boolean），原子（atom，又称symbol），字符串（string），列表（list）和元组（tuple）等。\n它们在`iex`中显示如下：\n\n```\niex\u003e 1          # integer\niex\u003e 0x1F       # integer\niex\u003e 1.0        # float\niex\u003e true       # boolean\niex\u003e :atom      # atom / symbol\niex\u003e \"elixir\"   # string\niex\u003e [1, 2, 3]  # list\niex\u003e {1, 2, 3}  # tuple\n```\n### 2.1 基本算数运算\n\n打开`iex`，输入以下表达式：\n\n```\niex\u003e 1 + 2\n3\niex\u003e 5 * 5\n25\niex\u003e 10 / 2\n5.0\n```\n`10 / 2`返回了一个浮点型的`5.0`而非整型的5，这是预期的。在Elixir中，`/`运算符总是返回浮点型数值。\n\n如果你想进行整型除法，或者求余数，可以使用函数`div`和`rem`。（`rem`的意思是`division remainder`）：\n\n```\niex\u003e div(10, 2)\n5\niex\u003e div 10, 2\n5\niex\u003e rem 10, 3\n1\n```\n在写函数参数时，括号是可选的。（ruby程序员会心一笑）\n\nElixir支持用捷径（shortcut）书写二进制、八进制、十六进制整数，如：\n\n```\niex\u003e 0b1010\n10\niex\u003e 0o777\n511\niex\u003e 0x1F\n31\n```\n揉揉眼，八进制是0o，数字0+小写o。\n\n输入浮点型数字需要一个小数点，且在其后至少有一位数字。Elixir支持使用`e`来表示指数：\n\n```\niex\u003e 1.0\n1.0\niex\u003e 1.0e-10\n1.0e-10\n```\nElixir中浮点型都是64位双精度。\n\n### 2.2 布尔\n\nElixir使用`true`和`false`两个布尔值。\n\n```\niex\u003e true\ntrue\niex\u003e true == false\nfalse\n```\nElixir提供了许多用以判断类型的函数，如`is_boolean/1`函数可以用来检查参数是不是布尔型。\n\n在Elixir中，函数通过名称和参数个数（又称元数，`arity`）来识别。 如`is_boolean/1`表示名为`is_boolean`，接受一个参数的函数； 而`is_boolean/2`表示与其同名、但接受2个参数的不同函数。（只是打个比方，这样的`is_boolean`实际上不存在）\n\n另外，`\u003c函数名\u003e/\u003c元数\u003e`这样的表述为了在讲述函数时方便。在实际程序中如果调用函数， 是不用注明`/1`或是`/2`的。\n```\niex\u003e is_boolean(true)\ntrue\niex\u003e is_boolean(1)\nfalse\n```\n类似的函数还有`is_integer/1`，`is_float/1`，`is_number/1`，分别测试参数是否是整型、浮点型或者两者其一。\n\n可以在交互式命令行中使用`h`命令来打印函数或运算符的帮助信息。如`h is_boolean/1`或`h ==/2`。注意此处提及某个函数时，不但要给出名称，还要加上元数`/\u003carity\u003e`。\n\n### 2.3 原子\n\n原子（`atom`）是一种常量，变量名就是它的值。有些语言（如ruby）中称其为符号（`symbol`）：\n\n```\niex\u003e :hello\n:hello\niex\u003e :hello == :world\nfalse\n```\n布尔值`true`和`false`实际上就是原子：\n```\niex\u003e true == :true\ntrue\niex\u003e is_atom(false)\ntrue  \n```\n此外原子也支持`:\"原子名\"`的方式\n大写字母开头的\"变量\"实际是`:\"Elixir.变量名\"`的别名:\n```\niex\u003e Hello == :\"Elixir.Hello\"\ntrue  \n```\n但如果这个别名已经有Elixir.前缀了 那么就不会再有Elixir前缀了:\n```\niex\u003e Elixir.Hello == :\"Elixir.Hello\"\ntrue\n```\n模块调用其实也是使用到了这种原子别名:\n```\niex\u003e IO == :\"Elixir.IO\"\ntrue\niex\u003e :\"Elixir.IO\".puts \"an atom\"\nan atom\n```\n\n### 2.4 字符串\n\n在Elixir中，字符串以双括号包裹，采用UTF-8编码：\n```\niex\u003e \"hellö\"\n\"hellö\"\n```\nElixir支持字符串插值（语法类似ruby）：\n```\niex\u003e \"hellö #{:world}\"\n\"hellö world\"\n```\n字符串可以直接包含换行符，或者其转义字符：\n```\niex\u003e \"hello\n...\u003e world\"\n\"hello\\nworld\"\niex\u003e \"hello\\nworld\"\n\"hello\\nworld\"\n```\n你可以使用`IO`模块（module）里的`IO.puts/1`方法打印字符串：\n```\niex\u003e IO.puts \"hello\\nworld\"\nhello\nworld\n:ok\n```\n\n函数`IO.puts/1`打印完字符串后，返回原子值`:ok`。\n\n字符串在Elixir内部被表示为二进制数值（binaries），也就是一连串的字节（bytes）：\n```\niex\u003e is_binary(\"hellö\")\ntrue\n```\n注意，二进制数值（binary）是Elixir内部的存储结构之一。字符串、列表等类型在语言内部就存储为二进制数值，因此它们也可以被专门操作二进制数值的函数修改。\n\n你可以查看字符串包含的字节数量：\n```\niex\u003e byte_size(\"hellö\")\n6\n```\n为啥是6？不是5个字符么？注意里面有一个非ASCII字符ö，在UTF-8下被编码为2个字节。\n\n我们可以使用专门的函数来返回字符串中的字符数量：\n```\niex\u003e String.length(\"hellö\")\n5\n```\n在`String`模块中提供了很多符合Unicode标准的函数来操作字符串。 如：\n```\niex\u003e String.upcase(\"hellö\")\n\"HELLÖ\"\n```\n记住，单引号和双引号包裹的字符串在Elixir中是两种不同的数据类型：\n```\niex\u003e 'hellö' == \"hellö\"\nfalse\n```\n我们将在之后关于“二进制、字符串与字符列表”章节中详细讲述它们的区别。\n\n\n### 2.5 匿名函数\n\n在Elixir中，使用关键字`fn`和`end`来界定函数。如：\n```\niex\u003e add = fn a, b -\u003e a + b end\n#Function\u003c12.71889879/2 in :erl_eval.expr/5\u003e\niex\u003e is_function(add)\ntrue\niex\u003e is_function(add, 2)\ntrue\niex\u003e is_function(add, 1)\nfalse\niex\u003e add.(1, 2)\n3\n```\n在Elixir中，函数是头等公民。你可以将函数作为参数传递给其他函数，就像整型和浮点型一样。 在上面的例子中，我们向函数`is_function/1`传递了由变量`add`表示的匿名函数，结果返回`true`。 我们还可以调用函数`is_function/2`来判断该参数函数的元数（参数个数）。\n\n注意，在调用一个匿名函数时，在变量名和写参数的括号之间要有个点号(`.`)。\n\n匿名函数是闭包，意味着它们可以访问当前作用域（scope）内的其它变量：\n```\niex\u003e add_two = fn a -\u003e add.(a, 2) end\n#Function\u003c6.71889879/1 in :erl_eval.expr/5\u003e\niex\u003e add_two.(2)\n4\n```\n这个例子定义的匿名函数`add_two`它内部使用了之前在同一个`iex`内定义好的`add`变量。\n但要注意，在匿名函数内修改了所引用的外部变量的值，并不实际反映到该变量上：\n```\niex\u003e x = 42\n42\niex\u003e (fn -\u003e x = 0 end).()\n0\niex\u003e x\n42\n```\n这个例子中匿名函数把引用了外部变量`x`，并修改它的值为`0`.这时函数执行后，外部的x没有被影响。\n\n### 2.6（链式）列表\n\nElixir使用方括号标识列表。列表可以包含任意类型的值：\n```\niex\u003e [1, 2, true, 3]\n[1, 2, true, 3]\niex\u003e length [1, 2, 3]\n3\n```\n两个列表可以使用`++/2`拼接，使用`--/2`做“减法”：\n```\niex\u003e [1, 2, 3] ++ [4, 5, 6]\n[1, 2, 3, 4, 5, 6]\niex\u003e [1, true, 2, false, 3, true] -- [true, false]\n[1, 2, 3, true]\n```\n本教程将多次涉及列表的头（head）和尾（tail）的概念。 列表的头指的是第一个元素，而尾指的是除了第一个元素以外，其它元素组成的列表。 它们分别可以用函数`hd/1`和`tl/1`从原列表中取出：\n```\niex\u003e list = [1,2,3]\niex\u003e hd(list)\n1\niex\u003e tl(list)\n[2, 3]\n```\n尝试从一个空列表中取出头或尾将会报错：\n```\niex\u003e hd []\n** (ArgumentError) argument error\n```\n\n### 2.7 元组\n\nElixir使用大括号（花括号）定义元组（tuples）。\n类似列表，元组也可以承载任意类型的数据：\n```\niex\u003e {:ok, \"hello\"}\n{:ok, \"hello\"}\niex\u003e tuple_size {:ok, \"hello\"}\n2\n```\n元组使用连续的内存空间存储数据。这意味着可以很方便地使用索引访问元组数据，以及获取元组大小。（索引从0开始）：\n```\niex\u003e tuple = {:ok, \"hello\"}\n{:ok, \"hello\"}\niex\u003e elem(tuple, 1)\n\"hello\"\niex\u003e tuple_size(tuple)\n2\n```\n也可以很方便地使用函数`put_elem/3`设置某个位置的元素值：\n```\niex\u003e tuple = {:ok, \"hello\"}\n{:ok, \"hello\"}\niex\u003e put_elem(tuple, 1, \"world\")\n{:ok, \"world\"}\niex\u003e tuple\n{:ok, \"hello\"}\n```\n注意函数`put_elem/3`返回一个新元组。原来那个由变量`tuple`标识的元组没有被改变。 这是因为Elixir的数据类型是不可变的。 这种不可变性使你永远不用担心你的数据会在某处被某些代码改变。 在处理并发程序时，该不可变性有利于减少多个不同程序实体在同时修改一个数据结构时引起的竞争以及其他麻烦。\n\n### 2.8 列表还是元组？\n\n列表与元组的区别：列表在内存中是以链表的形式存储的，一个元素指向下一个元素，然后再下一个...直到到达列表末尾。我们称这样的一对（元素值+指向下一个元素的指针）为列表的一个单元（cons cell）。 \n用Elixir语法表示这种模式：\n```\niex\u003e list = [1|[2|[3|[]]]]\n[1, 2, 3]\n```\n列表方括号中的竖线（|）表示列表头与尾的分界。\n\n这个原理意味着获取列表的长度是一个线性操作：我们必须遍历完整个列表才能知道它的长度。\n但是列表的前置拼接操作很快捷：\n```\niex\u003e [0] ++ list\n[0, 1, 2, 3]\niex\u003e list ++ [4]\n[1, 2, 3, 4]\n```\n上面例子中第一条语句是前置拼接操作，执行起来很快。因为它只是简单地添加了一个新列表单元，它指向原先列表头部。而原先的列表没有任何变化。\n\n第二条语句是后缀拼接操作，执行速度较慢。这是因为它重建了原先的列表，让原先列表的末尾元素指向那个新元素。\n\n而另一方面，元组在内存中是连续存储的。这意味着获取元组大小，或者使用索引访问元组元素的操作十分快速。 但是元组在修改或添加元素时开销很大，因为这些操作会在内存中对元组的进行整体复制。\n\n这些讨论告诉我们当如何在不同的情况下选择使用不同的数据结构。\n\n函数常用元组来返回多个信息。如`File.read/1`，它读取文件内容，返回一个元组：\n```\niex\u003e File.read(\"path/to/existing/file\")\n{:ok, \"... contents ...\"}\niex\u003e File.read(\"path/to/unknown/file\")\n{:error, :enoent}\n```\n如果传递给函数`File.read/1`的文件路径有效，那么函数返回一个元组，其首元素是原子`:ok`，第二个元素是文件内容。 如果路径无效，函数也将返回一个元组，其首元素是原子`:error`，第二个元素是错误信息。\n\n大多数情况下，Elixir会引导你做正确的事。 如有个叫`elem/2`的函数，它使用索引来访问一个元组元素。 这个函数没有相应的列表版本，因为根据存储机制，列表不适用通过索引来访问：\n```\niex\u003e tuple = {:ok, \"hello\"}\n{:ok, \"hello\"}\niex\u003e elem(tuple, 1)\n\"hello\"\n```\n当需要计算某数据结构包含的元素个数时，Elixir遵循一个简单的规则：** 如果操作在常数时间内完成（答案是提前算好的），这样的函数通常被命名为`**size*`**。 而如果操作需要显式计数，那么该函数通常命名为`**length*`。\n\n例如，目前讲到过的4个计数函数：`byte_size/1`（用来计算字符串有多少字节） ，`tuple_size/1`（用来计算元组大小） ，`length/1`（计算列表长度）以及`String.length/1`（计算字符串中的字符数）。\n\n按照命名规则，当我们用`byte_size`获取字符串所占字节数时，开销较小。 但是当我们用`String.length`获取字符串unicode字符个数时，需要遍历整个字符串，开销较大。 \n\n除了本章介绍的数据类型，Elixir还提供了`Port`，`Reference`和`PID`三个数据类型（它们常用于进程交互）。 这些数据类型将在讲解进程时详细介绍。\n\n## 3. 基本运算符\n\n通过前几章我们知道Elixir提供了 `+`，`-`，`*`，`/`4个算术运算符，外加整数除法函数`div/2`和取余函数`rem/2`。Elixir还提供了`++`和`--`运算符来操作列表：\n```\niex\u003e [1,2,3] ++ [4,5,6]\n[1,2,3,4,5,6]\niex\u003e [1,2,3] -- [2]\n[1,3]\n```\n使用`\u003c\u003e`进行字符串拼接：\n```\niex\u003e \"foo\" \u003c\u003e \"bar\"\n\"foobar\"\n```\nElixir还提供了三个布尔运算符：`or`，`and`和`not`。这三个运算符只接受布尔值作为第一个参数：\n```\niex\u003e true and true\ntrue\niex\u003e false or is_atom(:example)\ntrue\n```\n如果提供了非布尔值作为第一个参数，会报异常：\n```\niex\u003e 1 and true\n** (ArgumentError) argument error\n```\n`or`和`and`可短路，即它们仅在第一个参数无法决定整体结果的情况下才执行第二个参数：\n```\niex\u003e false and error(\"This error will never be raised\")\nfalse\niex\u003e true or error(\"This error will never be raised\")\ntrue\n```\n如果你是Erlang程序员，Elixir中的`and`和`or`其实就是`andalso`和`orelse`运算符。\n\n除了这几个布尔运算符，Elixir还提供`||`，`\u0026\u0026`和`!`运算符。它们可以接受任意类型的参数值。 在使用这些运算符时，除了`false`和`nil`的值都被视作`true`：\n```\n# or\niex\u003e 1 || true\n1\niex\u003e false || 11\n11\n\n# and\niex\u003e nil \u0026\u0026 13\nnil\niex\u003e true \u0026\u0026 17\n17\n\n# !\niex\u003e !true\nfalse\niex\u003e !1\nfalse\niex\u003e !nil\ntrue\n```\n根据经验，当参数返回的是布尔时，使用`and`，`or`和`not`；如果非布尔值，用`\u0026\u0026`，`||`和`!`。\n\nElixir还提供了`==`，`!=`，`===`，`!==`，`\u003c=`，`\u003e=`，`\u003c`和`\u003e`这些比较运算符：\n```\niex\u003e 1 == 1\ntrue\niex\u003e 1 != 2\ntrue\niex\u003e 1 \u003c 2\ntrue\n```\n`==`和`===`的不同之处是后者在判断数字时更严格：\n```\niex\u003e 1 == 1.0\ntrue\niex\u003e 1 === 1.0\nfalse\n```\n在Elixir中，可以判断不同类型数据的大小：\n```\niex\u003e 1 \u003c :atom\ntrue\n```\n这很实用。排序算法不必担心如何处理不同类型的数据。总体上，不同类型的排序顺序是：\n```\nnumber \u003c atom \u003c reference \u003c functions \u003c port \u003c pid \u003c tuple \u003c maps \u003c list \u003c bitstring\n```\n不用背，只要知道有这么回事儿就可以。\n\n## 4.模式匹配\n\n+ 匹配运算符\n+ 模式匹配\n+ pin运算符\n\n本章起教程进入不那么基础的阶段，开始涉及函数式编程概念。 在Elixir中，`=`运算符实际上是一个匹配运算符。 本章将讲解如何使用=运算符来对数据结构进行模式匹配。最后本章还会讲解`pin`运算符`^`，用来访问某变量之前绑定的值。\n\n### 4.1 匹配运算符\n\n我们已经多次使用=符号进行变量的赋值操作：\n```\niex\u003e x = 1\n1\niex\u003e x\n1\n```\n在Elixir中，`=`其实称为匹配运算符。下面来学习这样的概念：\n```\niex\u003e 1 = x\n1\niex\u003e 2 = x\n** (MatchError) no match of right hand side value: 1\n```\n注意`1 = x`是一个合法的表达式。由于前面给`x`赋值为`1`，左右相同，所以它匹配成功了。而两侧不匹配的时候，`MatchError`将被抛出。\n\n变量只有在匹配操作符`=`的左侧时才被赋值：\n```\niex\u003e 1 = unknown\n** (RuntimeError) undefined function: unknown/0\n```\n错误原因是`unknown`变量没有被赋过值，Elixir猜你想调用一个名叫`unknown/0`的函数，但是找不到这样的函数。\n\n### 4.2 模式匹配\n\n匹配运算符不光可以匹配简单数值，还能用来解构复杂的数据类型。\n例如，我们在元组上使用模式匹配：\n```\niex\u003e {a, b, c} = {:hello, \"world\", 42}\n{:hello, \"world\", 42}\niex\u003e a\n:hello\niex\u003e b\n\"world\"\n```\n在两端不匹配的情况下，模式匹配会失败。比方说，匹配两端的元组不一样长：\n```\niex\u003e {a, b, c} = {:hello, \"world\"}\n** (MatchError) no match of right hand side value: {:hello, \"world\"}\n```\n或者两端不是一个类型：\n```\niex\u003e {a, b, c} = [:hello, \"world\", \"!\"]\n** (MatchError) no match of right hand side value: [:hello, \"world\", \"!\"]\n```\n有趣的是，我们可以匹配特定值。下面例子中匹配的左端当且仅当右端是个元组，且第一个元素是原子`:ok`。\n```\niex\u003e {:ok, result} = {:ok, 13}\n{:ok, 13}\niex\u003e result\n13\n\niex\u003e {:ok, result} = {:error, :oops}\n** (MatchError) no match of right hand side value: {:error, :oops}\n```\n\n用在列表上：\n```\niex\u003e [a, b, c] = [1, 2, 3]\n[1, 2, 3]\niex\u003e a\n1\n```\n列表支持匹配自己的`head`和`tail`（这相当于同时调用`hd/1`和`tl/1`，给`head`和`tail`赋值）：\n```\niex\u003e [head | tail] = [1, 2, 3]\n[1, 2, 3]\niex\u003e head\n1\niex\u003e tail\n[2, 3]\n```\n同`hd/1`和`tl/1`函数一样，以上代码不能对空列表使用：\n```\niex\u003e [h|t] = []\n** (MatchError) no match of right hand side value: []\n```\n`[head|tail]`这种形式不光在模式匹配时可以用，还可以用作前置数值：\n```\niex\u003e list = [1, 2, 3]\n[1, 2, 3]\niex\u003e [0|list]\n[0, 1, 2, 3]\n```\n模式匹配使得程序员可以容易地解构数据结构（如元组和列表）。在后面我们还会看到，它是Elixir的一个基础，对其它数据结构同样适用，比如图和二进制。\n\n### 4.3 pin运算符\n\n在Elixir中，变量可以被重新绑定：\n```\niex\u003e x = 1\n1\niex\u003e x = 2\n2\n```\n如果你不想这样，可以使用pin运算符(^)。加上了pin运算符的变量，在匹配时使用的值是匹配前就赋予的值：\n```\niex\u003e x = 1\n1\niex\u003e ^x = 2\n** (MatchError) no match of right hand side value: 2\niex\u003e {x, ^x} = {2, 1}\n{2, 1}\niex\u003e x\n2\n```\n注意如果一个变量在匹配中被引用超过一次，所有的引用都应该绑定同一个模式：\n```\niex\u003e {x, x} = {1, 1}\n1\niex\u003e {x, x} = {1, 2}\n** (MatchError) no match of right hand side value: {1, 2}\n```\n有些时候，你并不在意模式里的一些值。通常你就可以把它们绑定到特殊的变量“_”上。例如，如果你只想要某列表的head，而不要tail值。你可以这么做：\n```\niex\u003e [h | _] = [1, 2, 3]\n[1, 2, 3]\niex\u003e h\n1\n```\n变量“`_`”特殊之处在于它不能被读。尝试读取它会报“未绑定的变量”错误：\n```\niex\u003e _\n** (CompileError) iex:1: unbound variable _\n```\n尽管模式匹配可以让我们创建功能强大的结构，但是它的作用被限制了。 比如，你不能让函数调用作为匹配的左端。下面例子就是非法的：\n```\niex\u003e length([1,[2],3]) = 3\n** (CompileError) iex:1: illegal pattern\n```\n\n## 5. 控制语句\n\n+ case\n+ 子句与卫兵表达式\n+ cond\n+ if和unless\n+ do语句块\n\n本章讲解Elixir的流程控制结构。\n\n### 5.1 case\n\ncase将一个值与许多模式进行比较，直到找到一个匹配的：\n```\niex\u003e case {1, 2, 3} do\n...\u003e   {4, 5, 6} -\u003e\n...\u003e     \"This clause won't match\"\n...\u003e   {1, x, 3} -\u003e\n...\u003e     \"This clause will match and bind x to 2 in this clause\"\n...\u003e   _ -\u003e\n...\u003e     \"This clause would match any value\"\n...\u003e end\n```\n如果与一个已赋值的变量做比较，要用`pin`运算符(`^`)标记该变量：\n```\niex\u003e x = 1\n1\niex\u003e case 10 do\n...\u003e   ^x -\u003e \"Won't match\"\n...\u003e   _  -\u003e \"Will match\"\n...\u003e end\n```\n可以加上卫兵表达式提供额外的条件：\n```\niex\u003e case {1, 2, 3} do\n...\u003e   {1, x, 3} when x \u003e 0 -\u003e\n...\u003e     \"Will match\"\n...\u003e   _ -\u003e\n...\u003e     \"Won't match\"\n...\u003e end\n```\n上面例子中，第一个待比较的模式多了一个条件：x必须是正数。\n\n### 5.2 子句中的卫兵表达式\n\nErlang中只允许以下卫兵表达式出现在子句中：\n\n+ 比较运算符（==，!=，===，!==，\u003e，\u003c，\u003c=，\u003e=）\n+ 布尔运算符（and，or）以及否定运算符（not，!）\n+ 算数运算符（+，-，*，/）\n+ \u003c\u003e和++如果左端是字面值\n+ in运算符\n+ 以下类型判断函数：\n\t+ is_atom/1\n\t+ is_binary/1\n\t+ is_bitstring/1\n\t+ is_boolean/1\n\t+ is_float/1\n\t+ is_function/1\n\t+ is_function/2\n\t+ is_integer/1\n\t+ is_list/1\n\t+ is_map/1\n\t+ is_number/1\n\t+ is_pid/1\n\t+ is_reference/1\n\t+ is_tuple/1\n+ 外加以下函数：\n\t+ abs(number)\n\t+ bit_size(bitstring)\n\t+ byte_size(bitstring)\n\t+ div(integer, integer)\n\t+ elem(tuple, n)\n\t+ hd(list)\n\t+ length(list)\n\t+ map_size(map)\n\t+ node()\n\t+ node(pid | ref | port)\n\t+ rem(integer, integer)\n\t+ round(number)\n\t+ self()\n\t+ tl(list)\n\t+ trunc(number)\n\t+ tuple_size(tuple)\n\n记住，卫兵表达式中出现的错误不会抛出，只会简单地让卫兵条件失败：\n\n```\niex\u003e hd(1)\n** (ArgumentError) argument error\n    :erlang.hd(1)\niex\u003e case 1 do\n...\u003e   x when hd(x) -\u003e \"Won't match\"\n...\u003e   x -\u003e \"Got: #{x}\"\n...\u003e end\n\"Got 1\"\n```\n如果case中没有一条模式能匹配，会报错：\n```\niex\u003e case :ok do\n...\u003e   :error -\u003e \"Won't match\"\n...\u003e end\n** (CaseClauseError) no case clause matching: :ok\n```\n匿名函数也可以像下面这样，用多个模式或卫兵条件来灵活地匹配该函数的参数：\n\n```\niex\u003e f = fn\n...\u003e   x, y when x \u003e 0 -\u003e x + y\n...\u003e   x, y -\u003e x * y\n...\u003e end\n#Function\u003c12.71889879/2 in :erl_eval.expr/5\u003e\niex\u003e f.(1, 3)\n4\niex\u003e f.(-1, 3)\n-3\n```\n需要注意的是，所有`case`模式中表示的参数个数必须一致，否则会报错。\n\n上面的例子两个待匹配模式都是`x`，`y`。如果再有一个模式表示的参数是`x`，`y`，`z`，那就不行：\n\n```\niex(5)\u003e f2 = fn\n...(5)\u003e   x,y -\u003e x+y\n...(5)\u003e   x,y,z -\u003e x+y+z\n...(5)\u003e end\n** (CompileError) iex:5: cannot mix clauses with different arities in function definition\n    (elixir) src/elixir_translator.erl:17: :elixir_translator.translate/2\n```\n\n### 5.3 cond\n\n`case`是拿一个值去同多个值或模式进行匹配，匹配了就执行那个分支的语句。 \n\n然而，许多情况下我们要检查不同的条件，找到第一个结果为true的，执行它的分支。 这时我们用cond：\n\n```\niex\u003e cond do\n...\u003e   2 + 2 == 5 -\u003e\n...\u003e     \"This will not be true\"\n...\u003e   2 * 2 == 3 -\u003e\n...\u003e     \"Nor this\"\n...\u003e   1 + 1 == 2 -\u003e\n...\u003e     \"But this will\"\n...\u003e end\n\"But this will\"\n```\n这样的写法和命令式语言里的`else if`差不多一个意思（尽管很少这么写）。\n\n如果没有一个条件结果为`true`，会报错。因此，实际应用中通常会使用`true`作为最后一个条件。 因为即使上面的条件没有一个是`true`，那么该`cond`表达式至少还可以执行这最后一个分支：\n\n```\niex\u003e cond do\n...\u003e   2 + 2 == 5 -\u003e\n...\u003e     \"This is never true\"\n...\u003e   2 * 2 == 3 -\u003e\n...\u003e     \"Nor this\"\n...\u003e   true -\u003e\n...\u003e     \"This is always true (equivalent to else)\"\n...\u003e end\n```\n用法就好像许多语言中`switch`语句中的`default`一样。\n\n最后需要注意的是，`cond`视所有除了`false`和`nil`的数值都为`true`：\n```\niex\u003e cond do\n...\u003e   hd([1,2,3]) -\u003e\n...\u003e     \"1 is considered as true\"\n...\u003e end\n\"1 is considered as true\"\n```\n### 5.4 if和unless\n\n除了`case`和`cond`，Elixir还提供了两很常用的宏：`if/2`和`unless/2`，用它们检查单个条件：\n```\niex\u003e if true do\n...\u003e   \"This works!\"\n...\u003e end\n\"This works!\"\niex\u003e unless true do\n...\u003e   \"This will never be seen\"\n...\u003e end\nnil\n```\n如果给`if/2`的条件结果为`false`或者`nil`，那么它在`do/end`间的语句块就不会执行，该表达式返回`nil`。 `unless/2`相反。\n\n它们都支持`else`语句块：\n```\niex\u003e if nil do\n...\u003e   \"This won't be seen\"\n...\u003e else\n...\u003e   \"This will\"\n...\u003e end\n\"This will\"\n```\n有趣的是，`if/2`和`unless/2`是以宏的形式提供的，而不像在很多语言中那样是语句。 可以阅读文档或`if/2`的源码（Kernel模块）。`Kernel`模块还定义了诸如`+/2`运算符和`is_function/2`函数。它们是默认是被自动导入，因而一开始就在你的代码中可用。\n\n### 5.5 do语句块\n\n以上讲解的4种流程控制结构：`case`，`cond`，`if`和`unless`，它们都被包裹在`do/end`语句块中。 即使我们把if语句写成这样：\n\n```\niex\u003e if true, do: 1 + 2\n3\n```\n在Elixir中，`do/end`语句块方便地将一组表达式传递给`do`:。以下是等同的：\n\n```\niex\u003e if true do\n...\u003e   a = 1 + 2\n...\u003e   a + 10\n...\u003e end\n13\niex\u003e if true, do: (\n...\u003e   a = 1 + 2\n...\u003e   a + 10\n...\u003e )\n13\n```\n我们称第二种语法使用了键值列表（keyword lists）。我们可以这样传递`else`：\n\n```\niex\u003e if false, do: :this, else: :that\n:that\n```\n注意一点，`do/end`语句块永远是被绑定在最外层的函数调用上。例如：\n```\niex\u003e is_number if true do\n...\u003e  1 + 2\n...\u003e end\n```\n将被解析为：\n```\niex\u003e is_number(if true) do\n...\u003e  1 + 2\n...\u003e end\n```\n这使得Elixir认为你是要调用函数`is_number/2`（第一个参数是`if true`，第二个是语句块）。 这时就需要加上括号解决二义性：\n\n```\niex\u003e is_number(if true do\n...\u003e  1 + 2\n...\u003e end)\ntrue\n```\n关键字列表在Elixir语言中占有重要地位，在许多函数和宏中都有使用。后文中还会对其进行详解。\n\n## 6. 二进制数据-字符串-字符列表\n\n+ UTF-8和Unicode\n+ 二进制（和bitstring）\n+ 字符列表\n\n在“基本类型”一章中介绍了字符串，以及如何使用`is_binary/1`函数来检查它：\n```\niex\u003e string = \"hello\"\n\"hello\"\niex\u003e is_binary string\ntrue\n```\n本章将学习理解，二进制数据（binaries）是个啥，它怎么和字符串扯上关系的，以及用单引号包裹的值，'像这样'，是啥意思。\n\n### 6.1 UTF-8和Unicode\n\nElixir中，字符串就是UTF-8编码的二进制数据（binaries）。为了弄清这句话啥意思，我们要先理解两个概念：`bytes`和`code point`的区别。\n\n“二进制数据”（binaries）这个翻译不一定准确。它其实就是以二进制为内容的列表。下文有些地方可能会简单写成“二进制”。如有模糊的地方，一般也会用原文标出。\n\n而`bytes`和`code points`就不怎么翻译了（`bytes`有时会翻译成字节），可根据上下文语境理解。\n\n字母`a`的`code point`是`97`，而字母`ł`的`code point`是`322`。\n\n当把字符串`\"hełło\"`写到硬盘上的时候，需要将其`code point`转化为字节（`bytes`）。 如果一个字节对应一个`code point`，那是存储不了`\"hełło\"`的，因为字母ł的`code point`是`322`，超过了一个字节所能存储的最大数值（`255`）。\n\n但是如你所见，该字母能够显示到屏幕上，说明还是有一定的解决方法的。方法就是编码。\n\n要用字节表示`code point`，我们需要在一定程度上对其进行编码。 Elixir使用UTF-8为默认编码格式。 当我们说，某个字符串是UTF-8编码的二进制数据（binaries），这句话意思是该字符串是一串字节，以一定方法组织，来表示特定的一串code points。\n\n因此当我们存储字母ł的时候，实际上是用两个字节来表示它。 这就是为什么有时候对同一字符串调用函数`byte_size/1`和`String.length/1`结果不一样：\n\n```\niex\u003e string = \"hełło\"\n\"hełło\"\niex\u003e byte_size string\n7\niex\u003e String.length string\n5\n```\nUTF-8需要1个字节来表示code points：`‘h’`，`‘e’`和`‘o’`各用一个，而`‘ł’`用2个字节。 在Elixir中，可以使用`?`运算符获取某字符的code point值：\n```\niex\u003e ?a\n97\niex\u003e ?ł\n322\n```\n你还可以使用String模块里的函数，将字符串切成单独的code points：\n```\niex\u003e String.codepoints(\"hełło\")\n[\"h\", \"e\", \"ł\", \"ł\", \"o\"]\n```\nElixir为字符串操作提供了强大的支持。实际上，Elixir通过了文章“字符串类型破了”记录的所有测试。\n\n不仅如此，因为字符串是二进制数据，Elixir还提供了更强大的底层类型的操作。下面就来介绍该底层类型---二进制数据。\n\n### 6.2 二进制数据（和bitstring）\n\n在Elixir中可以用`\u003c\u003c\u003e\u003e`定义一个二进制数据：\n```\niex\u003e \u003c\u003c0, 1, 2, 3\u003e\u003e\n\u003c\u003c0, 1, 2, 3\u003e\u003e\niex\u003e byte_size \u003c\u003c0, 1, 2, 3\u003e\u003e\n4\n```\n一个二进制只是一连串字节。这些字节可以以任何方法组织，即使凑不成一个合法的字符串：\n```\niex\u003e String.valid?(\u003c\u003c239, 191, 191\u003e\u003e)\nfalse\n```\n字符串的拼接操作实际上是二进制的拼接操作：\n```\niex\u003e \u003c\u003c0, 1\u003e\u003e \u003c\u003e \u003c\u003c2, 3\u003e\u003e\n\u003c\u003c0, 1, 2, 3\u003e\u003e\n```\n一个常见技巧是，通过给某字符串尾部拼接一个空字节\u003c\u003c0\u003e\u003e，来看看该字符串内部二进制的样子：\n```\niex\u003e \"hełło\" \u003c\u003e \u003c\u003c0\u003e\u003e\n\u003c\u003c104, 101, 197, 130, 197, 130, 111, 0\u003e\u003e\n```\n\n二进制中的每个数值都表示一个`byte`，因此其最大是`255`。 如果超出了255，二进制允许你再提供一个修饰符，标识一下那个位置的存储空间大小，使其可以满足存储要求。或者使用修饰符将其转换为utf8编码后的形式（变成多个字节的二进制），再存储：\n```\niex\u003e \u003c\u003c255\u003e\u003e\n\u003c\u003c255\u003e\u003e\niex\u003e \u003c\u003c256\u003e\u003e # truncated\n\u003c\u003c0\u003e\u003e\niex\u003e \u003c\u003c256 :: size(16)\u003e\u003e # use 16 bits (2 bytes) to store the number\n\u003c\u003c1, 0\u003e\u003e\niex\u003e \u003c\u003c256 :: utf8\u003e\u003e # the number is a code point\n\"Ā\"\niex\u003e \u003c\u003c256 :: utf8, 0\u003e\u003e\n\u003c\u003c196, 128, 0\u003e\u003e\n```\n如果一个`byte`是`8 bits`，那如果我们给一个`size`是`1 bit`的修饰符会怎样？：\n```\niex\u003e \u003c\u003c1 :: size(1)\u003e\u003e\n\u003c\u003c1::size(1)\u003e\u003e\niex\u003e \u003c\u003c2 :: size(1)\u003e\u003e # truncated\n\u003c\u003c0::size(1)\u003e\u003e\niex\u003e is_binary(\u003c\u003c 1 :: size(1)\u003e\u003e)\nfalse\niex\u003e is_bitstring(\u003c\u003c 1 :: size(1)\u003e\u003e)\ntrue\niex\u003e bit_size(\u003c\u003c 1 :: size(1)\u003e\u003e)\n1\n```\n这样（每个元素是`1 bit`）就不再是二进制数据（人家每个元素是`byte`，至`少8 bits`）了，而是`bitstring`，就是一串比特！ 所以实际上二进制数据（binary）就是一串比特（`bitstring`），只是它容纳的比特总数必须是8的倍数。\n\n我们也可以对二进制数据或bitstring做模式匹配：\n```\niex\u003e \u003c\u003c0, 1, x\u003e\u003e = \u003c\u003c0, 1, 2\u003e\u003e\n\u003c\u003c0, 1, 2\u003e\u003e\niex\u003e x\n2\niex\u003e \u003c\u003c0, 1, x\u003e\u003e = \u003c\u003c0, 1, 2, 3\u003e\u003e\n** (MatchError) no match of right hand side value: \u003c\u003c0, 1, 2, 3\u003e\u003e\n```\n注意（没有修改器标识的情况下）二进制数据中的每个元素都应该匹配8 bits。 因此上面最后的例子，匹配的左右两端不具有相同容量，因此出现错误。\n\n下面是使用了修饰符标识的匹配例子：\n```\niex\u003e \u003c\u003c0, 1, x :: binary\u003e\u003e = \u003c\u003c0, 1, 2, 3\u003e\u003e\n\u003c\u003c0, 1, 2, 3\u003e\u003e\niex\u003e x\n\u003c\u003c2, 3\u003e\u003e\n```\n上面的模式仅在二进制尾部元素被修改器标识为又一个二进制时才正确。 字符串的连接操作也是一个意思：\n```\niex\u003e \"he\" \u003c\u003e rest = \"hello\"\n\"hello\"\niex\u003e rest\n\"llo\"\n```\n总之，记住字符串是UTF-8编码的二进制数据，而二进制数据是特殊的、`bit`数量是8的倍数的`bitstring`。 这种机制增加了Elixir在处理`bits`或`bytes`时的灵活性。 现实中99%的时候你会用到`is_binary/1`和`byte_size/1`函数，来跟二进制数据打交道。\n\n### 6.3 字符列表\n\n字符列表就是字符的列表。 双引号包裹字符串，单引号包裹字符列表。\n```\niex\u003e 'hełło'\n[104, 101, 322, 322, 111]\niex\u003e is_list 'hełło'\ntrue\niex\u003e 'hello'\n'hello'\n```\n字符列表存储的不是字节，而是字符的`code points`（实际上就是这些code points的普通列表）。 如果某字符不属于ASCII范围，iex就打印它的code point。\n\n实际应用中，字符列表常被用来做一些老的库，或者同Erlang平台交互时使用的参数。因为这些老库不接受二进制数据作为参数。\n\n将字符列表和字符串之间转换，使用函数`to_string/1`和`to_char_list/1`：\n```\niex\u003e to_char_list \"hełło\"\n[104, 101, 322, 322, 111]\niex\u003e to_string 'hełło'\n\"hełło\"\niex\u003e to_string :hello\n\"hello\"\niex\u003e to_string 1\n\"1\"\n```\n注意这些函数是多态的。它们不但转化字符列表和字符串，还能转化字符串和整数，等等。","Tags":["Elixir"],"CreateTime":1444222588,"EditTime":1444222691,"UpdateTime":1444222588,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":1640}