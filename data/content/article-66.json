{"Id":66,"Title":"C语言基础（1）-Linux下的基本编译","Slug":"2014-10-31-1","Text":"#### 1：跑起来\n先把hello world跑起来\n\n    #include \u003cstdio.h\u003e\n      \n    int main()  \n    {  \n         printf(\"hello world!/n\");  \n         return 0;  \n    }  \n\n保存为 ex1.c linux终端中敲入\n\n    ~$:make ex1  \n    ~$:cc -Wall -g    ex1.c   -o ex1 \n\n你会发现 生成了一个ex1文件\n\n    ~$:./ex1  \n       hello world! \n\n#### 2：怎么跑起来的\n\n但是 它到底做了什么 ？ 各个段落都干了什么？ 这段我不知道怎么说了 直接命令说话\n\n    ~$:gcc -E ex1.c -o ex1.i   \n\n`-E` 这是一个预处理选项，其实生成的`.i`文件还是C语言文件，只是把`include` 还有宏之类的东西做了替换 替换\n\n比如 ex2.c如下：\n\n    #include \"stdio.h\"  \n    #define  HELLOWORLD \"hello world!\"  \n  \n     int main()  \n    {  \n         printf(\"%s\\n\",HELLOWORLD);  \n         return 0;  \n    }  \n \n 运行一下\n\n    ~$:gcc -E ex2.c -o ex2.i\n\nHELLOWORLD 做了相应的的替换 接着下面，如像下面这样：\n\n    int main()\n    {\n     printf(\"%s\\n\",\"hello world!\");\n     return 0;\n    }\n\n进行下一步\n\n    ~$:gcc -S ex2.i -o ex2.s  \n \n这个会把`.i` 文件编译成汇编文件 如果熟悉汇编语言 你可以看一下`ex2.s`文件\n\n继续下一步\n\n    ~$:gcc -c ex2.s -o ex2.o\n\n上面是把汇编代码 转换成机器代码,最后:\n\n    ~$:gcc ex2.o -o ex2  \n\n最后，在连接阶段将输入的机器代码文件*.o（与其它的机器代码文件和库文件）汇集成一个可执行的二进制代码文件。\n\n这个是整个的编译过程\n\n#### 3：链接\n\n然而 就如上面所说，与其它的机器代码文件和库文件，这个其他代码和库文件是怎么链接过来的呢？\n\n我们先看一下这个命令\n\n\n    ~$:ldd ex2  \n     libc.so.6 =\u003e /lib64/libc.so.6 (0x0000003195800000)  \n     /lib64/ld-linux-x86-64.so.2 (0x0000003195400000) \n \n这个命令可以看得到上面的C文件所用到的动态连接库是什么\n\n现在问题来了，如果我们自己想写一个自己的动态或是静态的链接库，怎么来写？ \n\nOK 我们下面解决这个问题 比如 我们的printf函数是哪里实现的呢 是怎么来链接此函数实现的呢？通过上面的ldd，可以分析到原来是程序连接到了libc.so.6\n\n#### 4：实现自己的链接库\n\n实现自己的链接库\n\ntest1.c:\n    \n    #include \"stdio.h\"  \n    #define  HELLOWORLD \"hello world!\"  \n      \n     int test1()  \n    {  \n         printf(\"%s\\n\",HELLOWORLD);  \n         return 0;  \n    } \n\ntest2.c:\n\n    #include \"stdio.h\"  \n      \n    void test2(int test2)  \n    {  \n         printf(\"test2:%d\\n\",test2);  \n    } \n    \ntest.h：\n\n    void test1(int);  \n    void test2(int);   \n   \n把它们编译成.o文件\n\n    ~$:cc -c test1.c  \n    ~$:cc -c test2.c  \n \n会生成test1.o 和test2.o\n\n写一个他们的调用函数 test.c：\n\n    #include \"stdio.h\"  \n    #include \"test.h\"  \n      \n    int main(void)  \n    {  \n         test1(1);  \n         test2(2);  \n         return 0；  \n    }  \n  \n编译一下：\n\n    ~$:cc -c test.c  \n    ~$:cc -o test test.o test1.o test2.o  \n\n这样会生成一个可执行文件test，运行它\n \n    ~$:./test  \n        test1:1  \n        test2:2  \n \n我们可以运行了，然后我们开始做自己的静态库 libself.a\n\n    ~$:ar crv libself.a test1.o test2.o  \n        a - test1.o  \n        a - test2.o \n\n我们试用一下自己的库\n\n    ~$:cc -o test test.o libself.a  \n    ~$: ./test \n        test1:1  \n        test2:2  \n \n成功 看一下用参数\n\n如果不行 记得生成内容表\n\n    ~$:ranlib libself.a\n\n这个可以运行了 但是呢，我还是很郁闷 因为静态库有以下缺点：\n\n\n`当需要多次调用静态库的时候，内存中会存在多个静态库 占用资源  `\n\n这个时候就需要共享库了 它成功的解决了这个问题：\n\n  + 链接方式：程序本身不包含函数代码，而是引用运行时可访问的共享代码  \n  + 对于一个共享库 他是这样的 ：程序本身不包含函数代码，在磁盘上和内存中也仅保存一份，更新也更方便。  \n  + 一个共享库的典型的名字为libNAME.so.N NAME为共享库的名字 N为版本号码。 \n  \n书上说linux负责装载共享库并解析客户程序函数应用的程序（动态装载器）是ld.so.N s搜索共享库使用的,是配置/etc/ld.so.conf 如果修改了这个文件,需要 ldconfig来处理它  \n我对动态连接库的了解也就这么多了.\n\n试着自己做一下\n\n    ~$:gcc test12.c test2.c -fPIC -shared -o libtest.so  \n    ~$:gcc test.c -L. -ltest -o test  \n    ~$:./test\n        test1:1  \n        test2:2  \n\n成功，解释一下\n \n  + -shared 该选项指定生成动态连接库（让连接器生成T类型的导出符号表，有时候也生成弱连接W类型的导出符号），不用该标志外部程序无法连接。相当于一个可执行文件  \n  + -fPIC：表示编译为位置独立的代码，不用此选项的话编译后的代码是位置相关的所以动态载入时是通过\n\t代码拷贝的方式来满足不同进程的需要，而不能达到真正代码段共享的目的。  \n  + -L.：表示要连接的库在当前目录中  \n  + -ltest：编译器查找动态连接库时有隐含的命名规则，即在给出的名字\n\t前面加上lib，后面加上.so来确定库的名称  \n  + LD_LIBRARY_PATH：这个环境变量指示动态连接器可以装载动态库的路径。  \n  + 当然如果有root权限的话，可以修改/etc/ld.so.conf文件，然后调用 /sbin/ldconfig来达到同样的目的，不过如果没有root权限，那么只能采用输出LD_LIBRARY_PATH的方法了。 \n  \n\n注意:\n\n调用动态库的时候有几个问题会经常碰到，有时，明\t明已经将库的头文件所在目录 通过 `-I` `include`进来了，\t库所在文件通过 `-L`参数引导，并指定了`-l`的库名，\t但通过`ldd`命令察看时，就是死活找不到你指定链接的so文件，这时你要作的就是通过修改`LD_LIBRARY_PATH`或者`/etc/ld.so.conf`文件来指定动态库的目录。通常这样做就可以解决库无法链接的问题了。\n\n#### 5： 附 gcc以及相关使用\n\n    1：-I 增加头文件路径\n    2：-L 增加链接库路径\n    3：-c 只激活预处理,编译,和汇编,也就是他只把程序做成obj文件\n    4：-S 汇编文件\n    5：-E 只激活预处理，但是不输出为文件，需要定向\n    6：-l -lm引入数学库\n    7：ldd 库依赖\n    8：ar 归档\n    9：ranlib 函数库生成内容表\n  ","Tags":["C","Linux","Gcc"],"CreateTime":1414741597,"EditTime":1414749301,"UpdateTime":1414741597,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":205}