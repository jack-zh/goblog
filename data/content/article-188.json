{"Id":188,"Title":"What a C programmer should know about memory","Slug":"2015-03-23-1","Text":"![](/static/upload/201503231318123.jpg)\n\n\u003ccite\u003eSource: Weapons by [T4LLBERG](http://www.flickr.com/photos/t4llberg/5828882565), on Flickr (CC-BY-SA)\u003c/cite\u003e\n\nIn 2007, Ulrich Drepper wrote a “[What every programmer should know about memory](http://www.akkadia.org/drepper/cpumemory.pdf)”. Yes, it’s a wee long-winded, but it’s worth its salt. Many years and “every programmer should know about” articles later, the concept of virtual memory is still elusive to many, as if it was a kind of magic. Awww, I couldn’t resist the reference. Even the validity of the original article was [questioned](http://stackoverflow.com/questions/8126311/what-every-programmer-should-know-about-memory) many years later. What gives?\n\n\n\u003e “North bridge? What is this crap? That ain’t street-fighting.”\n\nI’ll try to convey the practical side of things (i.e. what can you do) from “getting your fundamentals on a lock”, to more fun stuff. Think of it as a glue between the original article, and the things that you use every day. The examples are going to be C99 on Linux, but a lot of topics are universal. EDIT: I don’t have much knowledge about Windows, but I’d be thrilled to link an article which explains it. I tried my best to mention which functions are platform-specific, but again I’m only a human. If you find a discrepancy, please let me know.\n\nWithout further ado, grab a cup of coffee and let’s get to it.\n\n## Understanding virtual memory - the plot thickens\n\nUnless you’re dealing with some embedded systems or kernel-space code, you’re going to be working in protected mode. This is awesome, since your program is guaranteed to have it’s own [virtual] address space. The word “virtual” is important here. This means, among other things, that you’re not bounded by the available memory, but also not entitled to any. In order to use this space, you have to ask the OS to back it with something real, this is called mapping. A backing can be either a physical memory (not necessarily RAM), or a persistent storage. The former is also called an “anonymous mapping”. But hold your horses.\n\nThe virtual memory allocator (VMA) may give you a memory it doesn’t have, all in a vain hope that you’re not going to use it. Just like banks today. This is called [overcommiting](https://www.kernel.org/doc/Documentation/vm/overcommit-accounting), and while it has legitimate applications (sparse arrays), it also means that the memory allocation is not going to simply say **“NO”**.\n\n    char *block = malloc(1024 * sizeof(char));\n    if (block == NULL) {\n        return -ENOMEM; /* Sad :( */\n    }\n\nThe `NULL` return value checking is a good practice, but it’s not as powerful as it once was. With the overcommit, the OS may give your memory allocator a valid pointer to memory, but if you’re going to access it - dang\\*. The dang in this case is platform-specific, but generally an [OOM killer](http://www.win.tue.nl/%7Eaeb/linux/lk/lk-9.html#ss9.6) killing your process.\n\n\\* — This is an oversimplification, as timbatron [noted](https://www.reddit.com/r/C_Programming/comments/2ya9gl/what_a_c_programmer_should_know_about_memory/cp8mpau), and it’s further explained in the “[Demand paging explained](http://marek.vavrusa.com/c/memory/2015/02/20/memory/#pagefault)” section. But I’d like to go through the well-known stuff first before we delve into specifics.\n\n### Detour - a process memory layout\n\nhe layout of a process memory is well covered in the [Anatomy of a Program in Memory](http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/) by Gustavo Duarte, so I’m going to quote and reference to the original article, I hope it’s a fair use. I have only a few minor quibbles, for one it covers only a x86-32 memory layout, but fortunately nothing much has changed for x86-64. Except that a process can use much more space — the whopping 48 bits on Linux.\n\n![](/static/upload/201503231318178.png)\n\n\u003ccite\u003eSource: Linux address space layout by \u003ca href=\"http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/\"\u003eGustavo Duarte\u003c/a\u003e\u003c/cite\u003e\n\nIt also shows the memory mapping segment (MMS) growing down, but that may not always be the case. The MMS usually starts ([x86/mm/mmap.c:113](http://lxr.free-electrons.com/source/mm/mmap.c#L1953) and [arch/mm/mmap.c:1953](http://lxr.free-electrons.com/source/arch/x86/mm/mmap.c#L113)) at a randomized address just below the lowest address of the stack. Usually, because it may start above the stack and grow upwards iff the stack limit is large (or unlimited), or the compatibility layout is enabled. How is this important? It’s not, but it helps to give you an idea about the [free address ranges](http://marek.vavrusa.com/c/memory/2015/02/20/memory/#mmap-fun).\n\nLooking at the diagram, you can see three possible variable placements: the process data segment (static storage or heap allocation), the memory mapping segment, and the stack. Let’s start with that one.\n\n## Understanding stack allocation\n\nUtility belt:\n\n+ `alloca()` - [allocate memory in the stack frame of the caller](http://linux.die.net/man/3/alloca)\n+ `getrlimit()` - [get/set resource limits](http://linux.die.net/man/2/getrlimit)\n+ `sigaltstack()` - [set and/or get signal stack context](http://linux.die.net/man/2/sigaltstack)\n\nThe stack is kind of easy to digest, everybody knows how to make a variable on the stack right? Here are two:\n\n    int stairway = 2;\n    int heaven[] = { 6, 5, 4 };\n\nThe validity of the variables is limited by scope. In C, that means this: {}. So each time a closing curly bracket comes, a variable dies. And then there’s alloca(), which allocates memory dynamically in the current stack frame. A stack frame is not (entirely) the same thing as memory frame (aka physical page), it’s simply a group of data that gets pushed onto the stack (function, parameters, variables…). Since we’re on the top of the stack, we can use the remaining memory up to the stack size limit.\n\nThis is how variable-length arrays (VLA), and also alloca() work, with one difference - VLA validity is limited by the scope, alloca’d memory persists until the current function returns (or unwinds if you’re feeling sophisticated). This is no language lawyering, but a real issue if you’re using the alloca inside a loop, as you don’t have any means to free it.\n\n    void laugh(void) {\n        for (unsigned i = 0; i \u003c megatron; ++i) {\n            char *res = alloca(2);\n            memcpy(res, \"ha\", 2);\n            char vla[2] = {'h','a'}\n        } /* vla dies, res lives */\n    } /* all allocas die */\n\nNeither VLA or alloca play nice with large allocations, because you have almost no control over the available stack memory and the allocation past the stack limits leads to the jolly stack overflow. There are two ways around it, but neither is practical.\n\nThe first idea is to use a `sigaltstack()` to catch and handle the `SIGSEGV`. However this just lets you catch the stack overflow.\n\nThe other way is to compile with split-stacks. It’s called this way, because it really splits the monolithic stack into a linked-list of smaller stacks called stacklets. As far as I know, [GCC](https://gcc.gnu.org/wiki/SplitStacks) and [clang](http://llvm.org/releases/3.0/docs/SegmentedStacks.html) support it with the `-fsplit-stack` option. In theory this also improves memory consumption and reduces the cost of creating threads — because the stack can start really small and grow on demand. In reality, expect compatibility issues, as it needs a split-stack aware linker (i.e. gold) to play nice with the split-stack unaware libraries, and performance issues (the “hot split” problem in Go is [nicely explained](http://agis.io/2014/03/25/contiguous-stacks-in-go.html) by Agis Anastasopoulos).\n\n## Understanding heap allocation\n\nUtility belt:\n\n+ `brk()`, `sbrk()` - [manipulate the data segment size](http://linux.die.net/man/2/sbrk)\n+ `malloc()` [family - portable libc memory allocator](http://linux.die.net/man/3/malloc)\n\nThe heap allocation can be as simple as moving a [program break](http://linux.die.net/man/2/sbrk) and claiming the memory between the old position, and the new position. Up to this point, a heap allocation is as fast as stack allocation (sans the paging, presuming the stack is already locked in memory). But there’s a \u003cdel\u003ecat\u003c/del\u003e, I mean catch, dammit.\n\n    char *block = sbrk(1024 * sizeof(char));\n\n⑴ we can’t reclaim unused memory blocks, ⑵ is not thread-safe since the heap is shared between threads, ⑶ the interface is hardly portable, libraries must not touch the break\n\n\u003e `man 3 sbrk` — Various systems use various types for the argument of sbrk(). Common are int, ssizet, ptrdifft, intptr_t.\n\nFor these reasons libc implements a centralized interface for memory allocation. The [implementation varies](http://en.wikibooks.org/wiki/C_Programming/C_Reference/stdlib.h/malloc#Implementations), but it provides you a thread safe memory allocation of any size … at a cost. The cost is latency, as there is now locking involved, data structures keeping the information about used / free blocks and an extra memory overhead. The heap is not used exclusively either, as the memory mapping segment is often utilised for large blocks as well.\n\n\u003e `man 3 malloc` — Normally, `malloc()` allocates memory from the heap, … when allocating blocks of memory larger than MMAP_THRESHOLD, the glibc `malloc()` implementation allocates the memory as a private anonymous mapping.\n\nAs the heap is always contiguous from `start_brk` to `brk`, you can’t exactly punch holes through it and reduce the data segment size. Imagine the following scenario:\n\n    char *truck = malloc(1024 * 1024 * sizeof(char));\n    char *bike  = malloc(sizeof(char));\n    free(truck);\n\nThe heap [allocator] moves the `brk` to make space for `truck`. The same for the `bike`. But after the `truck` is freed, the `brk` can’t be moved down, as it’s the `bike` that occupies the highest address. The result is that your process can reuse the former `truck` memory, but it can’t be returned to the system until the `bike` is freed. But presuming the `truck` was mmaped, it wouldn’t reside in the heap segment, and couldn’t affect the program break. Still, this trick doesn’t prevent the holes created by small allocations (in another words “cause fragmentation”).\n\nNote that the `free()` doesn’t always try to shrink the data segment, as that is a [potentially expensive operation](http://marek.vavrusa.com/c/memory/2015/02/20/memory/#pagefault). This is a problem for long-running programs, such as daemons. A GNU extension, called `malloc_trim()`, exists for releasing memory from the top of the heap, but it can be painfully slow. It hurts real bad for a lot of small objects, so it should be used sparingly.\n\n### When to bother with a custom allocator\n\nThere are a few practical use cases where a GP allocator falls short — for example an allocation of a large number of small fixed-size chunks. This might not look like a typical pattern, but it is very frequent. For example, lookup data structures like trees and tries typically require nodes to build hierarchy. In this case, not only the fragmentation is the problem, but also the data locality. A cache-efficient data structure packs the keys together (preferably on the same page), instead of mixing it with data. With the default allocator, there is no guarantee about the locality of the blocks from the subsequent allocations. Even worse is the space overhead for allocating small units. Here comes the solution!\n\n![](/static/upload/201503231318201.jpg)\n\n\u003ccite\u003eSource: Slab by \u003ca href=\"https://www.flickr.com/people/99174151@N00/\"\u003ewadem\u003c/a\u003e, on Flickr (CC-BY-SA)\u003c/cite\u003e\n\n#### Slab allocator\n\nUtility belt:\n\n+ `posix_memalign()` - [allocate aligned memory](http://linux.die.net/man/3/posix_memalign)\n\nThe principle of slab allocation was described by [Bonwick](https://www.usenix.org/legacy/publications/library/proceedings/bos94/full_papers/bonwick.a) for a kernel object cache, but it applies for the user-space as well. Oh-kay, we’re not interested in pinning slabs to CPUs, but back to the gist — you ask the allocator for a slab of memory, let’s say a whole page, and you cut it into many fixed-size pieces. Presuming each piece can hold at least a pointer or an integer, you can link them into a list, where the list head points to the first free element.\n\n    /* Super-simple slab. */\n\tstruct slab {\n\t    void **head;\n\t};\n\n\t/* Create page-aligned slab */\n\tstruct slab *slab = NULL;\n\tposix_memalign(\u0026slab, page_size, page_size);\n\tslab-\u003ehead = (void **)((char*)slab + sizeof(struct slab));\n\n\t/* Create a NULL-terminated slab freelist */\n\tchar* item = (char*)slab-\u003ehead;\n\tfor(unsigned i = 0; i \u003c item_count; ++i) {\n\t    *((void**)item) = item + item_size;\n\t    item += item_size;\n\t}\n\t*((void**)item) = NULL;\n\nAllocation is then as simple as popping a list head. Freeing is equal to as pushing a new list head. There is also a neat trick. If the slab is aligned to the `page_size` boundary, you can get the slab pointer as cheaply as [rounding down](http://stackoverflow.com/a/2601527/4591872) to the `page_size`.\n\n    /* Free an element */\n\tstruct slab *slab = (void *)((size_t)ptr \u0026 PAGESIZE_BITS);\n\t*((void**)ptr) = (void*)slab-\u003ehead;\n\tslab-\u003ehead = (void**)ptr;\n\n\t/* Allocate an element */\n\tif((item = slab-\u003ehead)) {\n\t    slab-\u003ehead = (void**)*item;\n\t} else {\n\t    /* No elements left. */\n\t}\n\nGreat, but what about binning, variable size storage, cache aliasing and caffeine, …? Peek at [my old implementation](https://github.com/CZNIC-Labs/knot/blob/1.5/src/common-knot/slab/slab.h) for [Knot DNS](https://github.com/CZNIC-Labs/knot) to get the idea, or use a library that implements it. For example, \\*gasp\\*, the glib implementation has a [tidy documentation](https://developer.gnome.org/glib/stable/glib-Memory-Slices.html) and calls it “memory slices”.\n\n#### Memory pools\n\nUtility belt:\n\n+ `obstack_alloc()` - [allocate memory from object stack](http://www.gnu.org/software/libc/manual/html_node/Obstacks.html)\n\nAs with the slab, you’re going to outsmart the GP allocator by asking it for whole chunks of memory only. Then you just slice the cake until it runs out, and then ask for a new one. And another one. When you’re done with the cakes, you call it a day and free everything in one go.\n\nDoes it sound obvious and stupid simple? Because it is, but that’s what makes it great for specific use cases. You don’t have to worry about synchronisation, not about freeing either. There are no use-after-free bugs, data locality is much more predictable, there is almost zero overhead for small fragments.\n\nThe pattern is surprisingly suitable for many tasks, ranging from short-lived repetitive (i.e. “network request processing”), to long-lived immutable data (i.e. “frozen set”). You don’t have to free everything either. If you can make an educated guess on how much memory is needed on average, you can just free the excess memory and reuse. This reduces the memory allocation problem to simple pointer arithmetic.\n\nAnd you’re in luck here, as the GNU libc provides, \\*whoa\\*, an actual API for this. It’s called [obstacks](http://www.gnu.org/software/libc/manual/html_node/Obstacks.html), as in “stack of objects”. The HTML documentation formatting is a bit underwhelming, but minor quibbles aside — it allows you to do both pool allocation, and full or partial unwinding.\n\n\t/* Define block allocator. */\n\t#define obstack_chunk_alloc malloc\n\t#define obstack_chunk_free free\n\n\t/* Initialize obstack and allocate a bunch of animals. */\n\tstruct obstack animal_stack;\n\tobstack_init (\u0026animal_stack);\n\tchar *bob = obstack_alloc(\u0026animal_stack, sizeof(animal));\n\tchar *fred = obstack_alloc(\u0026animal_stack, sizeof(animal));\n\tchar *roger = obstack_alloc(\u0026animal_stack, sizeof(animal));\n\n\t/* Free everything after fred (i.e. fred and roger). */\n\tobstack_free(\u0026animal_stack, fred);\n\n\t/* Free everything. */\n\tobstack_free(\u0026animal_stack, NULL);\n\nThere is one more trick to it, you can grow the object on the top of the stack. Think buffering input, variable-length arrays, or just a way to combat the `realloc()-strcpy()` pattern.\n\n\t/* This is wrong, I better cancel it. */\n\tobstack_grow(\u0026animal_stack, \"long\", 4);\n\tobstack_grow(\u0026animal_stack, \"fred\", 5);\n\tobstack_free (\u0026animal_stack, obstack_finish(\u0026animal_stack));\n\n\t/* This time for real. */\n\tobstack_grow(\u0026animal_stack, \"long\", 4);\n\tobstack_grow(\u0026animal_stack, \"bob\", 4);\n\tchar *result = obstack_finish(\u0026animal_stack);\n\tprintf(\"%s\\n\", result); /* \"longbob\" */\n\n#### Demand paging explained\n\nUtility belt:\n\n+ `mlock()` - [lock/unlock memory](http://linux.die.net/man/2/mlock)\n+ `madvise()` - [give advice about use of memory](http://linux.die.net/man/2/madvise)\n\nOne of the reasons why the GP memory allocator doesn’t immediately return the memory to the system is, that it’s costly. The system has to do two things: ⑴ establish the mapping of a virtual page to real page, and ⑵ give you a blanked real page. The real page is called frame, now you know the difference. Each frame must be sanitized, because you don’t want the operating system to leak your secrets to another process, would you? But here’s the trick, remember the overcommit? The virtual memory allocator honours the only the first part of the deal, and then plays some “now you see me and now you don’t” shit — instead of pointing you to a real page, it points to a special page `0`.\n\nEach time you try to access the special page, a page fault occurs, which means that: the kernel pauses process execution and fetches a real page, then it updates the page tables, and resumes like nothing happened. That’s about the best explanation I could muster in one sentence, [here’s](http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/) more detailed one. This is also called “demand paging” or “lazy loading”.\n\n\u003e The Spock said that “one man cannot summon the future”, but here you can pull the strings.\n\nThe memory manager is no oracle and it makes very conservative predictions about how you’re going to access memory, but you may know better. You can [lock](http://linux.die.net/man/2/mlock) the contiguous memory block in physical memory, avoiding further page faulting:\n\n    char *block = malloc(1024 * sizeof(char));\n\tmlock(block, 1024 * sizeof(char));\n\n\\*psst\\*, you can also give an [advise](http://linux.die.net/man/2/madvise) about your memory usage pattern:\n\n\tchar *block = malloc(1024 * sizeof(block));\n\tmadvise(block, 1024 * sizeof(block), MADV_SEQUENTIAL);\n\nThe interpretation of the actual advice is platform-specific, the system may even choose to ignore it altogether, but most of the platforms play nice. Not all advices are well-supported, and some even change semantics (·MADV_FREE· drops dirty private memory), but the ·MADV_SEQUENTIAL·, ·MADV_WILLNEED·, and ·MADV_DONTNEED· holy trinity is what you’re going to use most.\n\n## Fun with \u003cdel\u003eflags\u003c/del\u003e memory mapping\n\nUtility belt:\n\n+ `sysconf()` - [get configuration information at run time](http://linux.die.net/man/3/sysconf)\n+ `mmap()` - [map virtual memory](http://linux.die.net/man/2/mlock)\n+ `mincore()` - [determine whether pages are resident in memory](http://linux.die.net/man/2/mincore)\n+ `shmat()` - [shared memory operations](http://linux.die.net/man/2/shmat)\n\nThere are several things that the memory allocator just can’t do, memory maps to to rescue! To pick one, the fact that you can’t choose the allocated address range. For that we’re willing to sacrifice some comfort — we’re going to be working with whole pages from now on. Just to make things clear, a page is usually a 4K block, but you shouldn’t rely on it and use `sysconf()` to discover it.\n\n    long page_size = sysconf(_SC_PAGESIZE); /* Slice and dice. */\n\nSide note — even if the platform advertises a uniform page size, it may not do so in the background. For example a Linux has a concept of [transparent huge pages](http://lwn.net/Articles/423584/)  (THP) to reduce the cost of address translation and page faulting for contiguous blocks. This is however questionable, as the huge contiguous blocks become scarce when the physical memory gets fragmented. The cost of faulting a huge page also increases with the page size, so it’s not very efficient for “small random I/O” workload. This is unfortunately transparent to you, but there is a Linux-specific `mmap` option `MAP_HUGETLB` that allows you to use it explicitly, so you should be aware of the costs.\n\n#### Fixed memory mappings\n\nSay you want to do fixed mapping for a poor man’s IPC for example, how do you choose an address? On x86-32 bit it’s a risky proposal, but on the 64-bit, an address around 2/3rds of the `TASK_SIZE` (highest usable address of the user space process) is a safe bet. You can get away without fixed mapping, but then forget pointers in your shared memory.\n\n    #define TASK_SIZE 0x800000000000\n    #define SHARED_BLOCK (void *)(2 * TASK_SIZE / 3)\n\n    void *shared_cats = shmat(shm_key, SHARED_BLOCK, 0);\n    if(shared_cats == (void *)-1) {\n        perror(\"shmat\"); /* Sad :( */\n    }\n\nOkay, I get it, this is hardly a portable example, but you get the gist. Mapping a fixed address range is usually considered unsafe at least, as it doesn’t check whether there is something already mapped or not. There is a `mincore()` function to tell you whether a page is mapped or not, but you’re out of luck in multi-threaded environment.\n\nHowever, fixed-address mapping is not only useful for unused address ranges, but for the used address ranges as well. Remember how the memory allocator used `mmap()` for bigger chunks? This makes efficient sparse arrays possible thanks to the on-demand paging. Let’s say you have created a sparse array, and now you want to free some data, but how to do that? You can’t exactly `free()` it, and `munmap()` would render it unusable. You could use the `madvise()` `MADV_FREE / MADV_DONTNEED` to mark the pages free, this is the best solution performance-wise as the pages don’t have to be faulted in, but the semantics of the advice [differs](http://lwn.net/Articles/591214/) is implementation-specific.\n\nA portable approach is to map over the sucker.\n\n    void *array = mmap(NULL, length, PROT_READ|PROT_WRITE,\n                   MAP_ANONYMOUS, -1, 0);\n\n    /* ... some magic gone awry ... */\n\n    /* Let's clear some pages. */\n    mmap(array + offset, length, MAP_FIXED|MAP_ANONYMOUS, -1, 0);\n\nThis is equivalent to unmapping the old pages and mapping them again to that special page. How does this affect the perception of the process memory consumption — the process still uses the same amount of virtual memory, but the resident [in physical memory] size lowers. This is as close to memory hole punching as we can get.\n\n#### File-backed memory maps\n\nUtility belt:\n\n+ `msync()` - [synchronize a file with memory map](http://linux.die.net/man/2/msync)\n+ `ftruncate()` - [truncate a file to a specified length](http://linux.die.net/man/2/ftruncate)\n+ `vmsplice()` - [splice user pages into a pipe](http://linux.die.net/man/2/vmsplice)\n\nSo far we’ve been all about anonymous memory, but it’s the file-backed memory mapping that really shines in the 64 bit address space, as it provides you with intelligent caching, synchronization and copy-on-write. Maybe that’s too much.\n\n\u003e To most people, LMDB is magic performance sprinkles compared to using the filesystem directly. ;)\n\n\u003e — [Baby_Food](http://www.reddit.com/r/programming/comments/2vyzer/what_every_programmer_should_know_about/comhq3s) on r/programming\n\nThe file-backed shared memory maps add novel mode `MAP_SHARED`, which means that the changes you make to the pages will be written back to the file, therefore shared with other processes. The decision of when to synchronize is left up to the memory manager, but fortunately there’s a `msync()` function to enforce the synchronization with the backing store. This is great for the databases, as it guarantees durability of the written data. But not everyone needs that, it’s perfectly okay **not** to sync if the durability isn’t required, you’re not going to lose write visibility. This is thanks to the page cache, and it’s good because you can use memory maps for cheap IPC for example.\n\n    /* Map the contents of a file into memory (shared). */\n\tint fd = open(...);\n\tvoid *db = mmap(NULL, file_size, PROT_READ|PROT_WRITE,\n\t                MAP_SHARED, fd, 0);\n\tif (db == (void *)-1) {\n\t    /* Mapping failed */\n\t}\n\n\t/* Write to a page */\n\tchar *page = (char *)db;\n\tstrcpy(page, \"bob\");\n\t/* This is going to be a durable page. */\n\tmsync(page, 4, MS_SYNC);\n\t/* This is going to be a less durable page. */\n\tpage = page + PAGE_SIZE;\n\tstrcpy(page, \"fred\");\n\tmsync(page, 5, MS_ASYNC);\n\n\nNote that you can’t map more bytes than the file actually has, so you can’t grow it or shrink it this way. You can however create (or grow) a sparse file in advance with `ftruncate()`. The downside is, that it makes compaction harder, as the ability to punch holes through a sparse file depends both on the file system, and the platform.\n\nThe fallocate(`FALLOC_FL_PUNCH_HOLE`) on Linux is your best chance, but the most portable (and easiest) way is to make a copy of the file without the trimmed stuff.\n\n    /* Resize the file. */\n    int fd = open(...);\n    ftruncate(fd, expected_length);\n\nAccessing a file memory map doesn’t exclude using it as a file either. This is useful for implementing a split access, where you map the file read only, but write to the file using a standard file API. This is good for security (as the exposed map is write-protected), but there’s more to it. The  \u003ca href=\"http://linux.die.net/man/2/msync\"\u003e\u003ccode\u003emsync()\u003c/code\u003e\u003c/a\u003e  implementation is not defined, so the `MS_SYNC` may very well be just a sequence of synchronous writes. Yuck. In that case, it may be faster to use a regular file APIs to do an asynchronous `pwrite()` and `fsync() / fdatasync()` for synchronisation or cache invalidation.\n\nAs always there is a caveat — the system has to have a unified buffer cache. Historically, a page cache and block device cache (raw blocks) were two different things. This means that writing to a file using a standard API and reading it through a memory map is not coherent\u003csup id=\"fnref1\"\u003e\u003ca href=\"#fn1\" rel=\"footnote\"\u003e1\u003c/a\u003e\u003c/sup\u003e, unless you invalidate buffers after each write. Uh oh. On the other hand, you’re in luck unless you’re running OpenBSD or Linux \u003c 2.4. \n\n##### Copy-on-write\n\nSo far this was about shared memory mapping. But you can use the memory mapping in another way — to map a shared copy of a file, and make modifications without modifying the backing store. Note that the pages are not duplicated immediately, that wouldn’t make sense, but in the moment you modify them. This is not only useful for forking processes or loading shared libraries, but also for working on a large set of data in-place, from multiple processes at once.\n\n    int fd = open(...);\n\n    /* Copy-on-write mapping */\n    void *db = mmap(NULL, file_size, PROT_READ|PROT_WRITE,\n                    MAP_PRIVATE, fd, 0);\n    if (db == (void *)-1) {\n        /* Mapping failed */\n    }\n\n    /* This page will be copied as soon as we write to it */\n    char *page = (char *)db;\n    strcpy(page, \"bob\");\n\n##### Zero-copy streaming\n\nSince the file is essentially a memory, you can stream it to pipes (that includes sockets), zero-copy style. Unlike the `splice()`, this plays well with the copy-on-write modification of the data. Disclaimer: This is for Linux folks only!\n\n    int sock = get_client();\n    struct iovec iov = { .iov_base = cat_db, .iov_len = PAGE_SIZE };\n    int ret = vmsplice(sock, \u0026iov, 1, 0);\n    if (ret != 0) {\n        /* No streaming :( */\n    }\n\n##### When mmap() isn’t the holy grail\n\nThere are pathological cases where mmapping a file is going to be much worse than the usual approach. A rule of thumb is that handling a page fault is slower than simply reading a file block, on the basis that it has to read the file block and do something more. In reality though, mmapped I/O may be faster as it avoids double or triple caching of the data, and does read-ahead in the background. But there are times when this is going to hurt. One such example is “small random reads in a file larger than available memory”. In this case the system reads ahead blocks that are likely not to be used, and each access is going to page fault instead. You can combat this to a degree with  \u003ca href=\"http://linux.die.net/man/2/madvise\"\u003e\u003ccode\u003emadvise()\u003c/code\u003e\u003c/a\u003e.\n\nThen there’s TLB thrashing. Translation of each virtual page to a frame is hardware-assisted, and the CPU keeps a cache of latest translations — this is the Translation Lookaside Buffer. A random access to a larger number of pages than the cache can hold inevitably leads to “thrashing”, as the system has to do the translation by walking the page tables. For other cases, the solution is to use [huge pages](https://wiki.debian.org/Hugepages), but it’s not going to cut it, as loading megabytes worth of data just to access a few odd bytes has even more detrimental effect.\n\n## Understanding memory consumption\n\nUtility belt:\n\n+ `vmtouch` - [portable virtual memory toucher](http://hoytech.com/vmtouch/)\n\nThe concept of shared memory renders the traditional approach — measuring resident size \u0026mdash obsolete, as there’s no just quantification on the amount exclusive for your process. That leads to confusion and horror, which can be two-fold:\n\n\u003e With mmap’d I/O, our app now uses almost zero memory.\n    — CorporateGuy\n\n\u003e Helpz! My process writing to shared map leaks so much memory!!1\n    — HeavyLifter666\n\nThere are two states of pages, `clean` and `dirty`. The difference is that a dirty page has to be flushed to permanent storage before it can be reclaimed. The `MADV_FREE` advice uses this as a cheap way to free memory just by clearing the dirty bit instead of updating the page table entry. In addition, each page can be either `private` or `shared`, and this is where things get confusing.\n\nBoth claims are [sort of] true, depending on the perspective. Do pages in the buffer cache count towards the process memory consumption? What about when a process dirties file-backed pages that end up in the buffer cache? How to make something out of this madness?\n\nImagine a process, the_eye, writing to the shared map of mordor. Writing to the shared memory doesn’t count towards Rss, right?\n\n    $ ps -p $$ -o pid,rss\n      PID   RSS\n    17906 1574944 # \u003c-- WTF?\n\nErr, back to the drawing board.\n\n##### PSS (Proportional Set Size)\n\nProportional Set Size counts the private maps and adds a portion of the shared maps. This is as fair as we can get when talking about memory. By “portion”, I mean a size of a shared map, divided by the number of processes sharing it. Let’s see an example, we have an application that does read/write to a shared memory map.\n\n\t$ cat /proc/$$/maps\n\t00400000-00410000         r-xp 0000 08:03 1442958 /tmp/the_eye\n\t00bda000-01a3a000         rw-p 0000 00:00 0       [heap]\n\t7efd09d68000-7f0509d68000 rw-s 0000 08:03 4065561 /tmp/mordor.map\n\t7f0509f69000-7f050a108000 r-xp 0000 08:03 2490410 libc-2.19.so\n\t7fffdc9df000-7fffdca00000 rw-p 0000 00:00 0       [stack]\n\t... snip ...\n\nHere’s the simplified breakdown of each map, the first column is the address range, the second is permissions information, where `r` stands for read, `w` stands for write, `x` means executable — so far the classic stuff — `s` is shared and `p` is private. Then there’s offset, device, inode, and finally a pathname. [Here’s](https://www.kernel.org/doc/Documentation/filesystems/proc.txt) the documentation, massively comprehensive.\n\nI admit I’ve snipped the not-so-interesting bits from the output. Read [FAQ (Why is “strict overcommit” a dumb idea?)](http://landley.net/writing/memory-faq.txt) if you’re interested why the shared libraries are mapped as private, but it’s the map of mordor that interests us:\n\n\t$ grep -A12 mordor.map /proc/$$/smaps\n\tSize:           33554432 kB\n\tRss:             1557632 kB\n\tPss:             1557632 kB\n\tShared_Clean:          0 kB\n\tShared_Dirty:          0 kB\n\tPrivate_Clean:   1557632 kB\n\tPrivate_Dirty:         0 kB\n\tReferenced:      1557632 kB\n\tAnonymous:             0 kB\n\tAnonHugePages:         0 kB\n\tSwap:                  0 kB\n\tKernelPageSize:        4 kB\n\tMMUPageSize:           4 kB\n\tLocked:                0 kB\n\tVmFlags: rd wr sh mr mw me ms sd\n\nPrivate pages on a shared map — what am I, a wizard? On Linux, even a shared memory is counted as private unless it’s actually shared. Let’s see if it’s in the buffer cache:\n\n\t# Seems like the first part is...\n\t$ vmtouch -m 64G -v mordor.map\n\t[OOo                                      ] 389440/8388608\n\n\t           Files: 1\n\t     Directories: 0\n\t  Resident Pages: 389440/8388608  1G/32G  4.64%\n\t         Elapsed: 0.27624 seconds\n\n\t# Let's load it in the cache!\n\t$ cat mordor.map \u003e /dev/null\n\t$ vmtouch -m 64G -v mordor.map\n\t[ooooooooooooooooooooooooo      oooOOOOOOO] 2919606/8388608\n\n\t           Files: 1\n\t     Directories: 0\n\t  Resident Pages: 2919606/8388608  11G/32G  34.8%\n\t         Elapsed: 0.59845 seconds\n\nWhoa, simply reading a file gets it cached? Anyway, how’s our process?\n\n    ps -p $$ -o pid,rss\n      PID   RSS\n    17906 286584 # \u003c-- Wait a bloody minute\n\nA common misconception is that mapping a file consumes memory, whereas reading it using file API does not. One way or another, the pages from that file are going to get in the buffer cache. There is only a small difference, a process has to create the page table entries with mmap way, but the pages themselves are shared. Interestingly our process Rss shrinked, as there was a demand for the process pages.\n\n##### Sometimes all of our thoughts are misgiven\n\nThe file-backed memory is always reclaimable, the only difference between dirty and clean — the dirty memory has to be cleaned before it can be reclaimed. So should you panick when a process consumes a lot of memory in top? Start panicking (mildly) when a process has a lot of anonymous dirty pages — these can’t be reclaimed. If you see a very large growing anonymous mapping segment, you’re probably in trouble (and make it double). But the Rss or even Pss is not to be blindly trusted.\n\nAnother common mistake is to assume any relation between the process virtual memory and the memory consumption, or even treating all memory maps equally. Any reclaimable memory, is as good as a free one. To put it simply, it’s not going to fail your next memory allocation, but it may increase latency — let me explain.\n\nThe memory manager is making hard choices about what to keep in the physical memory, and what not. It may decide to page out a part of the process memory to swap in favour of more space for buffers, so the process has to page in that part on the next access. Fortunately it’s usually configurable. For example, there is an option called [swappiness](http://en.wikipedia.org/wiki/Swappiness) on Linux, that determines when should the kernel start paging out anonymous memory. A value of 0 means “until abso-fucking-lutely necessary”.\n\n## An end, once and for all\n\nIf you got here, I salute you! I started this article as a break from actual work, in a hope that simply explaining a thousand times explained concepts in a more accessible way is going to help me to organize thoughts, and help others in the process. It took me longer than expected. Way more.\n\nI have nothing but utmost respect for writers, as it’s a tedious hair-pulling process of neverending edits and rewrites. Somewhere, Jeff Atwood has said that the best book about learning how to code is the one about building houses. I can’t remember where it was, so I can’t quote it. I could only add, that book about writing comes next. After all, that’s programming in it’s distilled form — writing stories, clear an concise.\n\nEDIT: I’ve fixed the stupid mistakes with `alloca()` and `sizeof(char *) vs sizeof(char)`, thanks immibis and BonzaiThePenguin. Thanks sWvich for pointing out missing cast in `slab + sizeof(struct slab)`. Obviously I should have run the article through static analysis, but I didn’t — lesson learned.\n\nOpen question — is there anything better than Markdown code block, where I could show an annotated excerpt with a possibility to download the whole code block?\n\n转自：http://marek.vavrusa.com/c/memory/2015/02/20/memory/","Tags":["C"],"CreateTime":1427088072,"EditTime":1427088072,"UpdateTime":1427088072,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":111}