{"Id":205,"Title":" gevent程序员指南","Slug":"2015-04-28-1","Text":"\u003e 由Gevent社区编写\n\n\u003e\u003e gevent是一个基于[libev](http://software.schmorp.de/pkg/libev.html)的并发库。它为各种并发和网络相关的任务提供了整洁的API。\n\n![](/static/upload/2015042811195910.jpg)\n\n## 介绍\n\n本指南假定读者有中级P\nython水平，但不要求有其它更多的知识，不期待读者有 并发方面的知识。本指南的目标在于给予你需要的工具来开始使用gevent，帮助你 驯服现有的并发问题，并从今开始编写异步应用程序。\n\n贡献者\n\n按提供贡献的时间先后顺序列出如下: Stephen Diehl Jérémy Bethmont sww Bruno Bigras David Ripton Travis Cline Boris Feld youngsterxyf Eddie Hebert Alexis Metaireau Daniel Velkov\n\n同时感谢Denis Bilenko写了gevent和相应的指导以形成本指南。\n\n这是一个以MIT许可证发布的协作文档。你想添加一些内容？或看见一个排版错误？ Fork一个分支发布一个request到 [Github](https://github.com/sdiehl/gevent-tutorial). 我们欢迎任何贡献。\n\n## 核心部分\n\n### Greenlets\n\n在gevent中用到的主要模式是`Greenlet`, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。\n\n\u003e 在任何时刻，只有一个协程在运行。\n\n这与multiprocessing或threading等提供真正并行构造的库是不同的。 这些库轮转使用操作系统调度的进程和线程，是真正的并行。\n同步和异步执行\n\n并发的核心思想在于，大的任务可以分解成一系列的子任务，后者可以被调度成 同时执行或异步执行，而不是一次一个地或者同步地执行。两个子任务之间的 切换也就是上下文切换。\n\n在gevent里面，上下文切换是通过yielding来完成的. 在下面的例子里， 我们有两个上下文，通过调用gevent.sleep(0)，它们各自yield向对方。\n\n    import gevent\n\n    def foo():\n        print('Running in foo')\n        gevent.sleep(0)\n        print('Explicit context switch to foo again')\n\n    def bar():\n        print('Explicit context to bar')\n        gevent.sleep(0)\n        print('Implicit context switch back to bar')\n\n    gevent.joinall([\n        gevent.spawn(foo),\n        gevent.spawn(bar),\n    ])\n\n---\n    Running in foo\n    Explicit context to bar\n    Explicit context switch to foo again\n    Implicit context switch back to bar\n\n下图将控制流形象化，就像在调试器中单步执行整个程序，以说明上下文切换如何发生。\n\n![](/static/upload/201504281114145.gif)\n\n当我们在受限于网络或IO的函数中使用gevent，这些函数会被协作式的调度， gevent的真正能力会得到发挥。Gevent处理了所有的细节， 来保证你的网络库会在可能的时候，隐式交出greenlet上下文的执行权。 这样的一种用法是如何强大，怎么强调都不为过。或者我们举些例子来详述。\n\n下面例子中的select()函数通常是一个在各种文件描述符上轮询的阻塞调用。\n\n    import time\n    import gevent\n    from gevent import select\n\n    start = time.time()\n    tic = lambda: 'at %1.1f seconds' % (time.time() - start)\n\n    def gr1():\n        # Busy waits for a second, but we don't want to stick around...\n        print('Started Polling: %s' % tic())\n        select.select([], [], [], 2)\n        print('Ended Polling: %s' % tic())\n\n    def gr2():\n        # Busy waits for a second, but we don't want to stick around...\n        print('Started Polling: %s' % tic())\n        select.select([], [], [], 2)\n        print('Ended Polling: %s' % tic())\n\n    def gr3():\n        print(\"Hey lets do some stuff while the greenlets poll, %s\" % tic())\n        gevent.sleep(1)\n\n    gevent.joinall([\n        gevent.spawn(gr1),\n        gevent.spawn(gr2),\n        gevent.spawn(gr3),\n    ])\n\n---\n\n    Started Polling: at 0.0 seconds\n    Started Polling: at 0.0 seconds\n    Hey lets do some stuff while the greenlets poll, at 0.0 seconds\n    Ended Polling: at 2.0 seconds\n    Ended Polling: at 2.0 seconds\n\n下面是另外一个多少有点人造色彩的例子，定义一个非确定性的(non-deterministic) 的task函数(给定相同输入的情况下，它的输出不保证相同)。 此例中执行这个函数的副作用就是，每次task在它的执行过程中都会随机地停某些秒。\n\n\n    import gevent\n    import random\n\n    def task(pid):\n        \"\"\"\n        Some non-deterministic task\n        \"\"\"\n        gevent.sleep(random.randint(0,2)*0.001)\n        print('Task %s done' % pid)\n\n    def synchronous():\n        for i in range(1,10):\n            task(i)\n\n    def asynchronous():\n        threads = [gevent.spawn(task, i) for i in xrange(10)]\n        gevent.joinall(threads)\n\n    print('Synchronous:')\n    synchronous()\n\n    print('Asynchronous:')\n    asynchronous()\n\n---\n\n    Synchronous:\n    Task 1 done\n    Task 2 done\n    Task 3 done\n    Task 4 done\n    Task 5 done\n    Task 6 done\n    Task 7 done\n    Task 8 done\n    Task 9 done\n    Asynchronous:\n    Task 3 done\n    Task 7 done\n    Task 9 done\n    Task 2 done\n    Task 4 done\n    Task 1 done\n    Task 8 done\n    Task 6 done\n    Task 0 done\n    Task 5 done\n\n上例中，在同步的部分，所有的task都同步的执行， 结果当每个task在执行时主流程被阻塞(主流程的执行暂时停住)。\n\n程序的重要部分是将task函数封装到Greenlet内部线程的gevent.spawn。 初始化的greenlet列表存放在数组threads中，此数组被传给gevent.joinall 函数，后者阻塞当前流程，并执行所有给定的greenlet。执行流程只会在 所有greenlet执行完后才会继续向下走。\n\n要重点留意的是，异步的部分本质上是随机的，而且异步部分的整体运行时间比同步 要大大减少。事实上，同步部分的最大运行时间，即是每个task停0.002秒，结果整个 队列要停0.02秒。而异步部分的最大运行时间大致为0.002秒，因为没有任何一个task会 阻塞其它task的执行。\n\n一个更常见的应用场景，如异步地向服务器取数据，取数据操作的执行时间 依赖于发起取数据请求时远端服务器的负载，各个请求的执行时间会有差别。\n\n    import gevent.monkey\n    gevent.monkey.patch_socket()\n\n    import gevent\n    import urllib2\n    import simplejson as json\n\n    def fetch(pid):\n        response = urllib2.urlopen('http://json-time.appspot.com/time.json')\n        result = response.read()\n        json_result = json.loads(result)\n        datetime = json_result['datetime']\n\n        print('Process %s: %s' % (pid, datetime))\n        return json_result['datetime']\n\n    def synchronous():\n        for i in range(1,10):\n            fetch(i)\n\n    def asynchronous():\n        threads = []\n        for i in range(1,10):\n            threads.append(gevent.spawn(fetch, i))\n        gevent.joinall(threads)\n\n    print('Synchronous:')\n    synchronous()\n\n    print('Asynchronous:')\n    asynchronous()\n\n### 确定性\n\n就像之前所提到的，greenlet具有确定性。在相同配置相同输入的情况下，它们总是 会产生相同的输出。下面就有例子，我们在multiprocessing的pool之间执行一系列的 任务，与在gevent的pool之间执行作比较。\n\n    import time\n\n    def echo(i):\n        time.sleep(0.001)\n        return i\n\n    # Non Deterministic Process Pool\n\n    from multiprocessing.pool import Pool\n\n    p = Pool(10)\n    run1 = [a for a in p.imap_unordered(echo, xrange(10))]\n    run2 = [a for a in p.imap_unordered(echo, xrange(10))]\n    run3 = [a for a in p.imap_unordered(echo, xrange(10))]\n    run4 = [a for a in p.imap_unordered(echo, xrange(10))]\n\n    print(run1 == run2 == run3 == run4)\n\n    # Deterministic Gevent Pool\n\n    from gevent.pool import Pool\n\n    p = Pool(10)\n    run1 = [a for a in p.imap_unordered(echo, xrange(10))]\n    run2 = [a for a in p.imap_unordered(echo, xrange(10))]\n    run3 = [a for a in p.imap_unordered(echo, xrange(10))]\n    run4 = [a for a in p.imap_unordered(echo, xrange(10))]\n\n    print(run1 == run2 == run3 == run4)\n\n---\n\n    False\n    True\n\n\n即使gevent通常带有确定性，当开始与如socket或文件等外部服务交互时， 不确定性也可能溜进你的程序中。因此尽管gevent线程是一种“确定的并发”形式， 使用它仍然可能会遇到像使用POSIX线程或进程时遇到的那些问题。\n\n涉及并发长期存在的问题就是竞争条件(race condition)。简单来说， 当两个并发线程/进程都依赖于某个共享资源同时都尝试去修改它的时候， 就会出现竞争条件。这会导致资源修改的结果状态依赖于时间和执行顺序。 这是个问题，我们一般会做很多努力尝试避免竞争条件， 因为它会导致整个程序行为变得不确定。\n\n最好的办法是始终避免所有全局的状态。全局状态和导入时(import-time)副作用总是会 反咬你一口！\n\n### 创建Greenlets\n\ngevent对Greenlet初始化提供了一些封装，最常用的使用模板之一有\n\n\n    import gevent\n    from gevent import Greenlet\n\n    def foo(message, n):\n        \"\"\"\n        Each thread will be passed the message, and n arguments\n        in its initialization.\n        \"\"\"\n        gevent.sleep(n)\n        print(message)\n\n    # Initialize a new Greenlet instance running the named function\n    # foo\n    thread1 = Greenlet.spawn(foo, \"Hello\", 1)\n\n    # Wrapper for creating and running a new Greenlet from the named\n    # function foo, with the passed arguments\n    thread2 = gevent.spawn(foo, \"I live!\", 2)\n\n    # Lambda expressions\n    thread3 = gevent.spawn(lambda x: (x+1), 2)\n\n    threads = [thread1, thread2, thread3]\n\n    # Block until all threads complete.\n    gevent.joinall(threads)\n\n---\n\n    Hello\n    I live!\n\n除使用基本的Greenlet类之外，你也可以子类化Greenlet类，重载它的_run方法。\n\n\n    import gevent\n    from gevent import Greenlet\n\n    class MyGreenlet(Greenlet):\n\n        def __init__(self, message, n):\n            Greenlet.__init__(self)\n            self.message = message\n            self.n = n\n\n        def _run(self):\n            print(self.message)\n            gevent.sleep(self.n)\n\n    g = MyGreenlet(\"Hi there!\", 3)\n    g.start()\n    g.join()\n\n---\n\n    Hi there!\n\n### Greenlet状态\n\n就像任何其他成段代码，Greenlet也可能以不同的方式运行失败。 Greenlet可能未能成功抛出异常，不能停止运行，或消耗了太多的系统资源。\n\n一个greenlet的状态通常是一个依赖于时间的参数。在greenlet中有一些标志， 让你可以监视它的线程内部状态：\n\n + started -- Boolean, 指示此Greenlet是否已经启动\n + ready() -- Boolean, 指示此Greenlet是否已经停止\n + successful() -- Boolean, 指示此Greenlet是否已经停止而且没抛异常\n + value -- 任意值, 此Greenlet代码返回的值\n + exception -- 异常, 此Greenlet内抛出的未捕获异常\n\n代码:\n\n    import gevent\n\n    def win():\n        return 'You win!'\n\n    def fail():\n        raise Exception('You fail at failing.')\n\n    winner = gevent.spawn(win)\n    loser = gevent.spawn(fail)\n\n    print(winner.started) # True\n    print(loser.started)  # True\n\n    # Exceptions raised in the Greenlet, stay inside the Greenlet.\n    try:\n        gevent.joinall([winner, loser])\n    except Exception as e:\n        print('This will never be reached')\n\n    print(winner.value) # 'You win!'\n    print(loser.value)  # None\n\n    print(winner.ready()) # True\n    print(loser.ready())  # True\n\n    print(winner.successful()) # True\n    print(loser.successful())  # False\n\n    # The exception raised in fail, will not propogate outside the\n    # greenlet. A stack trace will be printed to stdout but it\n    # will not unwind the stack of the parent.\n\n    print(loser.exception)\n\n    # It is possible though to raise the exception again outside\n    # raise loser.exception\n    # or with\n    # loser.get()\n\n---\n\n    True\n    True\n    You win!\n    None\n    True\n    True\n    True\n    False\n    You fail at failing.\n\n### 程序停止\n\n当主程序(main program)收到一个SIGQUIT信号时，不能成功做yield操作的 Greenlet可能会令意外地挂起程序的执行。这导致了所谓的僵尸进程， 它需要在Python解释器之外被kill掉。\n\n对此，一个通用的处理模式就是在主程序中监听SIGQUIT信号，在程序退出 调用gevent.shutdown。\n\n    import gevent\n    import signal\n\n    def run_forever():\n        gevent.sleep(1000)\n\n    if __name__ == '__main__':\n        gevent.signal(signal.SIGQUIT, gevent.shutdown)\n        thread = gevent.spawn(run_forever)\n        thread.join()\n\n### 超时\n\n超时是一种对一块代码或一个Greenlet的运行时间的约束。\n\n\n    import gevent\n    from gevent import Timeout\n\n    seconds = 10\n\n    timeout = Timeout(seconds)\n    timeout.start()\n\n    def wait():\n        gevent.sleep(10)\n\n    try:\n        gevent.spawn(wait).join()\n    except Timeout:\n        print('Could not complete')\n\n\n超时类也可以用在上下文管理器(context manager)中, 也就是with语句内。\n\n    import gevent\n    from gevent import Timeout\n\n    time_to_wait = 5 # seconds\n\n    class TooLong(Exception):\n        pass\n\n    with Timeout(time_to_wait, TooLong):\n        gevent.sleep(10)\n\n另外，对各种Greenlet和数据结构相关的调用，gevent也提供了超时参数。 例如：\n\n\n    import gevent\n    from gevent import Timeout\n\n    def wait():\n        gevent.sleep(2)\n\n    timer = Timeout(1).start()\n    thread1 = gevent.spawn(wait)\n\n    try:\n        thread1.join(timeout=timer)\n    except Timeout:\n        print('Thread 1 timed out')\n\n    # --\n\n    timer = Timeout.start_new(1)\n    thread2 = gevent.spawn(wait)\n\n    try:\n        thread2.get(timeout=timer)\n    except Timeout:\n        print('Thread 2 timed out')\n\n    # --\n\n    try:\n        gevent.with_timeout(1, wait)\n    except Timeout:\n        print('Thread 3 timed out')\n\n---\n\n    Thread 1 timed out\n    Thread 2 timed out\n    Thread 3 timed out\n\n### 猴子补丁(Monkey patching)\n\n我们现在来到gevent的死角了. 在此之前，我已经避免提到猴子补丁(monkey patching) 以尝试使gevent这个强大的协程模型变得生动有趣，但现在到了讨论猴子补丁的黑色艺术 的时候了。你之前可能注意到我们提到了monkey.patch_socket()这个命令，这个 纯粹副作用命令是用来改变标准socket库的。\n\n    import socket\n    print(socket.socket)\n\n    print(\"After monkey patch\")\n    from gevent import monkey\n    monkey.patch_socket()\n    print(socket.socket)\n\n    import select\n    print(select.select)\n    monkey.patch_select()\n    print(\"After monkey patch\")\n    print(select.select)\n\n---\n\n    class 'socket.socket'\n    After monkey patch\n    class 'gevent.socket.socket'\n\n    built-in function select\n    After monkey patch\n    function select at 0x1924de8\n\nPython的运行环境允许我们在运行时修改大部分的对象，包括模块，类甚至函数。 这是个一般说来令人惊奇的坏主意，因为它创造了“隐式的副作用”，如果出现问题 它很多时候是极难调试的。虽然如此，在极端情况下当一个库需要修改Python本身 的基础行为的时候，猴子补丁就派上用场了。在这种情况下，gevent能够 修改标准库里面大部分的阻塞式系统调用，包括socket、ssl、threading和 select等模块，而变为协作式运行。\n\n例如，Redis的python绑定一般使用常规的tcp socket来与redis-server实例通信。 通过简单地调用gevent.monkey.patch_all()，可以使得redis的绑定协作式的调度 请求，与gevent栈的其它部分一起工作。\n\n这让我们可以将一般不能与gevent共同工作的库结合起来，而不用写哪怕一行代码。 虽然猴子补丁仍然是邪恶的(evil)，但在这种情况下它是“有用的邪恶(useful evil)”。\n\n## 数据结构\n\n### 事件\n\n事件(event)是一个在Greenlet之间异步通信的形式。\n\n    import gevent\n    from gevent.event import Event\n\n    '''\n    Illustrates the use of events\n    '''\n\n    evt = Event()\n\n    def setter():\n        '''After 3 seconds, wake all threads waiting on the value of evt'''\n        print('A: Hey wait for me, I have to do something')\n        gevent.sleep(3)\n        print(\"Ok, I'm done\")\n        evt.set()\n\n    def waiter():\n        '''After 3 seconds the get call will unblock'''\n        print(\"I'll wait for you\")\n        evt.wait()  # blocking\n        print(\"It's about time\")\n\n    def main():\n        gevent.joinall([\n            gevent.spawn(setter),\n            gevent.spawn(waiter),\n            gevent.spawn(waiter),\n            gevent.spawn(waiter),\n            gevent.spawn(waiter),\n            gevent.spawn(waiter)\n        ])\n\n    if __name__ == '__main__': main()\n\n事件对象的一个扩展是AsyncResult，它允许你在唤醒调用上附加一个值。 它有时也被称作是future或defered，因为它持有一个指向将来任意时间可设置 为任何值的引用。\n\n    import gevent\n    from gevent.event import AsyncResult\n    a = AsyncResult()\n\n    def setter():\n        \"\"\"\n        After 3 seconds set the result of a.\n        \"\"\"\n        gevent.sleep(3)\n        a.set('Hello!')\n\n    def waiter():\n        \"\"\"\n        After 3 seconds the get call will unblock after the setter\n        puts a value into the AsyncResult.\n        \"\"\"\n        print(a.get())\n\n    gevent.joinall([\n        gevent.spawn(setter),\n        gevent.spawn(waiter),\n    ])\n\n\n### 队列\n\n队列是一个排序的数据集合，它有常见的put / get操作， 但是它是以在Greenlet之间可以安全操作的方式来实现的。\n\n举例来说，如果一个Greenlet从队列中取出一项，此项就不会被 同时执行的其它Greenlet再取到了。\n\n\n    import gevent\n    from gevent.queue import Queue\n\n    tasks = Queue()\n\n    def worker(n):\n        while not tasks.empty():\n            task = tasks.get()\n            print('Worker %s got task %s' % (n, task))\n            gevent.sleep(0)\n\n        print('Quitting time!')\n\n    def boss():\n        for i in xrange(1,25):\n            tasks.put_nowait(i)\n\n    gevent.spawn(boss).join()\n\n    gevent.joinall([\n        gevent.spawn(worker, 'steve'),\n        gevent.spawn(worker, 'john'),\n        gevent.spawn(worker, 'nancy'),\n    ])\n\n---\n\n    Worker steve got task 1\n    Worker john got task 2\n    Worker nancy got task 3\n    Worker steve got task 4\n    Worker nancy got task 5\n    Worker john got task 6\n    Worker steve got task 7\n    Worker john got task 8\n    Worker nancy got task 9\n    Worker steve got task 10\n    Worker nancy got task 11\n    Worker john got task 12\n    Worker steve got task 13\n    Worker john got task 14\n    Worker nancy got task 15\n    Worker steve got task 16\n    Worker nancy got task 17\n    Worker john got task 18\n    Worker steve got task 19\n    Worker john got task 20\n    Worker nancy got task 21\n    Worker steve got task 22\n    Worker nancy got task 23\n    Worker john got task 24\n    Quitting time!\n    Quitting time!\n    Quitting time!\n\n如果需要，队列也可以阻塞在put或get操作上。\n\nput和get操作都有非阻塞的版本，put_nowait和get_nowait不会阻塞， 然而在操作不能完成时抛出gevent.queue.Empty或gevent.queue.Full异常。\n\n在下面例子中，我们让boss与多个worker同时运行，并限制了queue不能放入多于3个元素。 这个限制意味着，直到queue有空余空间之间，put操作会被阻塞。相反地，如果队列中 没有元素，get操作会被阻塞。它同时带一个timeout参数，允许在超时时间内如果 队列没有元素无法完成操作就抛出gevent.queue.Empty异常。\n\n\n    import gevent\n    from gevent.queue import Queue, Empty\n\n    tasks = Queue(maxsize=3)\n\n    def worker(n):\n        try:\n            while True:\n                task = tasks.get(timeout=1) # decrements queue size by 1\n                print('Worker %s got task %s' % (n, task))\n                gevent.sleep(0)\n        except Empty:\n            print('Quitting time!')\n\n    def boss():\n        \"\"\"\n        Boss will wait to hand out work until a individual worker is\n        free since the maxsize of the task queue is 3.\n        \"\"\"\n\n        for i in xrange(1,10):\n            tasks.put(i)\n        print('Assigned all work in iteration 1')\n\n        for i in xrange(10,20):\n            tasks.put(i)\n        print('Assigned all work in iteration 2')\n\n    gevent.joinall([\n        gevent.spawn(boss),\n        gevent.spawn(worker, 'steve'),\n        gevent.spawn(worker, 'john'),\n        gevent.spawn(worker, 'bob'),\n    ])\n\n---\n\n    Worker steve got task 1\n    Worker john got task 2\n    Worker bob got task 3\n    Worker steve got task 4\n    Worker bob got task 5\n    Worker john got task 6\n    Assigned all work in iteration 1\n    Worker steve got task 7\n    Worker john got task 8\n    Worker bob got task 9\n    Worker steve got task 10\n    Worker bob got task 11\n    Worker john got task 12\n    Worker steve got task 13\n    Worker john got task 14\n    Worker bob got task 15\n    Worker steve got task 16\n    Worker bob got task 17\n    Worker john got task 18\n    Assigned all work in iteration 2\n    Worker steve got task 19\n    Quitting time!\n    Quitting time!\n    Quitting time!\n\n### 组和池\n\n组(group)是一个运行中greenlet的集合，集合中的greenlet像一个组一样 会被共同管理和调度。 它也兼饰了像Python的multiprocessing库那样的 平行调度器的角色。\n\n\n    import gevent\n    from gevent.pool import Group\n\n    def talk(msg):\n        for i in xrange(3):\n            print(msg)\n\n    g1 = gevent.spawn(talk, 'bar')\n    g2 = gevent.spawn(talk, 'foo')\n    g3 = gevent.spawn(talk, 'fizz')\n\n    group = Group()\n    group.add(g1)\n    group.add(g2)\n    group.join()\n\n    group.add(g3)\n    group.join()\n\n---\n\n    bar\n    bar\n    bar\n    foo\n    foo\n    foo\n    fizz\n    fizz\n    fizz\n\n在管理异步任务的分组上它是非常有用的。\n\n就像上面所说，Group也以不同的方式为分组greenlet/分发工作和收集它们的结果也提供了API。\n\n\n    import gevent\n    from gevent import getcurrent\n    from gevent.pool import Group\n\n    group = Group()\n\n    def hello_from(n):\n        print('Size of group %s' % len(group))\n        print('Hello from Greenlet %s' % id(getcurrent()))\n\n    group.map(hello_from, xrange(3))\n\n    def intensive(n):\n        gevent.sleep(3 - n)\n        return 'task', n\n\n    print('Ordered')\n\n    ogroup = Group()\n    for i in ogroup.imap(intensive, xrange(3)):\n        print(i)\n\n    print('Unordered')\n\n    igroup = Group()\n    for i in igroup.imap_unordered(intensive, xrange(3)):\n        print(i)\n\n---\n\n    Size of group 3\n    Hello from Greenlet 31048720\n    Size of group 3\n    Hello from Greenlet 31049200\n    Size of group 3\n    Hello from Greenlet 31049040\n    Ordered\n    ('task', 0)\n    ('task', 1)\n    ('task', 2)\n    Unordered\n    ('task', 2)\n    ('task', 1)\n    ('task', 0)\n\n池(pool)是一个为处理数量变化并且需要限制并发的greenlet而设计的结构。 在需要并行地做很多受限于网络和IO的任务时常常需要用到它。\n\n\n    import gevent\n    from gevent.pool import Pool\n\n    pool = Pool(2)\n\n    def hello_from(n):\n        print('Size of pool %s' % len(pool))\n\n    pool.map(hello_from, xrange(3))\n\n---\n\n    Size of pool 2\n    Size of pool 2\n    Size of pool 1\n\n当构造gevent驱动的服务时，经常会将围绕一个池结构的整个服务作为中心。 一个例子就是在各个socket上轮询的类。\n\n    from gevent.pool import Pool\n\n    class SocketPool(object):\n\n        def __init__(self):\n            self.pool = Pool(1000)\n            self.pool.start()\n\n        def listen(self, socket):\n            while True:\n                socket.recv()\n\n        def add_handler(self, socket):\n            if self.pool.full():\n                raise Exception(\"At maximum pool size\")\n            else:\n                self.pool.spawn(self.listen, socket)\n\n        def shutdown(self):\n            self.pool.kill()\n\n\n### 锁和信号量\n\n信号量是一个允许greenlet相互合作，限制并发访问或运行的低层次的同步原语。 信号量有两个方法，acquire和release。在信号量是否已经被 acquire或release，和拥有资源的数量之间不同，被称为此信号量的范围 (the bound of the semaphore)。如果一个信号量的范围已经降低到0，它会 阻塞acquire操作直到另一个已经获得信号量的greenlet作出释放。\n\n\n    from gevent import sleep\n    from gevent.pool import Pool\n    from gevent.coros import BoundedSemaphore\n\n    sem = BoundedSemaphore(2)\n\n    def worker1(n):\n        sem.acquire()\n        print('Worker %i acquired semaphore' % n)\n        sleep(0)\n        sem.release()\n        print('Worker %i released semaphore' % n)\n\n    def worker2(n):\n        with sem:\n            print('Worker %i acquired semaphore' % n)\n            sleep(0)\n        print('Worker %i released semaphore' % n)\n\n    pool = Pool()\n    pool.map(worker1, xrange(0,2))\n    pool.map(worker2, xrange(3,6))\n\n---\n\n    Worker 0 acquired semaphore\n    Worker 1 acquired semaphore\n    Worker 0 released semaphore\n    Worker 1 released semaphore\n    Worker 3 acquired semaphore\n    Worker 4 acquired semaphore\n    Worker 3 released semaphore\n    Worker 4 released semaphore\n    Worker 5 acquired semaphore\n    Worker 5 released semaphore\n\n范围为1的信号量也称为锁(lock)。它向单个greenlet提供了互斥访问。 信号量和锁常常用来保证资源只在程序上下文被单次使用。\n线程局部变量\n\nGevent也允许你指定局部于greenlet上下文的数据。 在内部，它被实现为以greenlet的getcurrent()为键， 在一个私有命名空间寻址的全局查找。\n\n\n    import gevent\n    from gevent.local import local\n\n    stash = local()\n\n    def f1():\n        stash.x = 1\n        print(stash.x)\n\n    def f2():\n        stash.y = 2\n        print(stash.y)\n\n        try:\n            stash.x\n        except AttributeError:\n            print(\"x is not local to f2\")\n\n    g1 = gevent.spawn(f1)\n    g2 = gevent.spawn(f2)\n\n    gevent.joinall([g1, g2])\n\n---\n\n    1\n    2\n    x is not local to f2\n\n很多集成了gevent的web框架将HTTP会话对象以线程局部变量的方式存储在gevent内。 例如使用Werkzeug实用库和它的proxy对象，我们可以创建Flask风格的请求对象。\n\n    from gevent.local import local\n    from werkzeug.local import LocalProxy\n    from werkzeug.wrappers import Request\n    from contextlib import contextmanager\n\n    from gevent.wsgi import WSGIServer\n\n    _requests = local()\n    request = LocalProxy(lambda: _requests.request)\n\n    @contextmanager\n    def sessionmanager(environ):\n        _requests.request = Request(environ)\n        yield\n        _requests.request = None\n\n    def logic():\n        return \"Hello \" + request.remote_addr\n\n    def application(environ, start_response):\n        status = '200 OK'\n\n        with sessionmanager(environ):\n            body = logic()\n\n        headers = [\n            ('Content-Type', 'text/html')\n        ]\n\n        start_response(status, headers)\n        return [body]\n\n    WSGIServer(('', 8000), application).serve_forever()\n\n\nFlask系统比这个例子复杂一点，然而使用线程局部变量作为局部的会话存储， 这个思想是相同的。\n子进程\n\n自gevent 1.0起，gevent.subprocess，一个Python subprocess模块 的修补版本已经添加。它支持协作式的等待子进程。\n\n\n    import gevent\n    from gevent.subprocess import Popen, PIPE\n\n    def cron():\n        while True:\n            print(\"cron\")\n            gevent.sleep(0.2)\n\n    g = gevent.spawn(cron)\n    sub = Popen(['sleep 1; uname'], stdout=PIPE, shell=True)\n    out, err = sub.communicate()\n    g.kill()\n    print(out.rstrip())\n\n---\n\n    cron\n    cron\n    cron\n    cron\n    cron\n    Linux\n\n很多人也想将gevent和multiprocessing一起使用。最明显的挑战之一 就是multiprocessing提供的进程间通信默认不是协作式的。由于基于 multiprocessing.Connection的对象(例如Pipe)暴露了它们下面的 文件描述符(file descriptor)，gevent.socket.wait_read和wait_write 可以用来在直接读写之前协作式的等待ready-to-read/ready-to-write事件。\n\n\n    import gevent\n    from multiprocessing import Process, Pipe\n    from gevent.socket import wait_read, wait_write\n\n    # To Process\n    a, b = Pipe()\n\n    # From Process\n    c, d = Pipe()\n\n    def relay():\n        for i in xrange(10):\n            msg = b.recv()\n            c.send(msg + \" in \" + str(i))\n\n    def put_msg():\n        for i in xrange(10):\n            wait_write(a.fileno())\n            a.send('hi')\n\n    def get_msg():\n        for i in xrange(10):\n            wait_read(d.fileno())\n            print(d.recv())\n\n    if __name__ == '__main__':\n        proc = Process(target=relay)\n        proc.start()\n\n        g1 = gevent.spawn(get_msg)\n        g2 = gevent.spawn(put_msg)\n        gevent.joinall([g1, g2], timeout=1)\n\n然而要注意，组合multiprocessing和gevent必定带来 依赖于操作系统(os-dependent)的缺陷，其中有：\n\n + 在兼容POSIX的系[统创建子进程(forking)](http://linux.die.net/man/2/fork)之后， 在子进程的gevent的状态是不适定的(ill-posed)。一个副作用就是， multiprocessing.Process创建之前的greenlet创建动作，会在父进程和子进程两 方都运行。\n + 上例的put_msg()中的a.send()可能依然非协作式地阻塞调用的线程：一个 ready-to-write事件只保证写了一个byte。在尝试写完成之前底下的buffer可能是满的。\n + 上面表示的基于wait_write()/wait_read()的方法在Windows上不工作 (IOError: 3 is not a socket (files are not supported))，因为Windows不能监视 pipe事件。\n\nPython包gipc以大体上透明的方式在 兼容POSIX系统和Windows上克服了这些挑战。它提供了gevent感知的基于 multiprocessing.Process的子进程和gevent基于pipe的协作式进程间通信。\nActors\n\nactor模型是一个由于Erlang变得普及的更高层的并发模型。 简单的说它的主要思想就是许多个独立的Actor，每个Actor有一个可以从 其它Actor接收消息的收件箱。Actor内部的主循环遍历它收到的消息，并 根据它期望的行为来采取行动。\n\nGevent没有原生的Actor类型，但在一个子类化的Greenlet内使用队列， 我们可以定义一个非常简单的。\n\n    import gevent\n    from gevent.queue import Queue\n\n    class Actor(gevent.Greenlet):\n\n        def __init__(self):\n            self.inbox = Queue()\n            Greenlet.__init__(self)\n\n        def receive(self, message):\n            \"\"\"\n            Define in your subclass.\n            \"\"\"\n            raise NotImplemented()\n\n        def _run(self):\n            self.running = True\n\n            while self.running:\n                message = self.inbox.get()\n                self.receive(message)\n\n\n下面是一个使用的例子：\n\n    import gevent\n    from gevent.queue import Queue\n    from gevent import Greenlet\n\n    class Pinger(Actor):\n        def receive(self, message):\n            print(message)\n            pong.inbox.put('ping')\n            gevent.sleep(0)\n\n    class Ponger(Actor):\n        def receive(self, message):\n            print(message)\n            ping.inbox.put('pong')\n            gevent.sleep(0)\n\n    ping = Pinger()\n    pong = Ponger()\n\n    ping.start()\n    pong.start()\n\n    ping.inbox.put('start')\n    gevent.joinall([ping, pong])\n\n## 真实世界的应用\n\n### Gevent ZeroMQ\n\n[ZeroMQ](http://www.zeromq.org/) 被它的作者描述为 “一个表现得像一个并发框架的socket库”。 它是一个非常强大的，为构建并发和分布式应用的消息传递层。\n\nZeroMQ提供了各种各样的socket原语。最简单的是请求-应答socket对 (Request-Response socket pair)。一个socket有两个方法send和recv， 两者一般都是阻塞操作。但是[Travis Cline](https://github.com/traviscline) 的一个杰出的库弥补了这一点，这个库使用gevent.socket来以非阻塞的方式 轮询ZereMQ socket。通过命令：\n\n    pip install gevent-zeromq\n\n你可以从PyPi安装gevent-zeremq。\n\n\n    # Note: Remember to ``pip install pyzmq gevent_zeromq``\n    import gevent\n    from gevent_zeromq import zmq\n\n    # Global Context\n    context = zmq.Context()\n\n    def server():\n        server_socket = context.socket(zmq.REQ)\n        server_socket.bind(\"tcp://127.0.0.1:5000\")\n\n        for request in range(1,10):\n            server_socket.send(\"Hello\")\n            print('Switched to Server for %s' % request)\n            # Implicit context switch occurs here\n            server_socket.recv()\n\n    def client():\n        client_socket = context.socket(zmq.REP)\n        client_socket.connect(\"tcp://127.0.0.1:5000\")\n\n        for request in range(1,10):\n\n            client_socket.recv()\n            print('Switched to Client for %s' % request)\n            # Implicit context switch occurs here\n            client_socket.send(\"World\")\n\n    publisher = gevent.spawn(server)\n    client    = gevent.spawn(client)\n\n    gevent.joinall([publisher, client])\n\n\n    Switched to Server for 1\n    Switched to Client for 1\n    Switched to Server for 2\n    Switched to Client for 2\n    Switched to Server for 3\n    Switched to Client for 3\n    Switched to Server for 4\n    Switched to Client for 4\n    Switched to Server for 5\n    Switched to Client for 5\n    Switched to Server for 6\n    Switched to Client for 6\n    Switched to Server for 7\n    Switched to Client for 7\n    Switched to Server for 8\n    Switched to Client for 8\n    Switched to Server for 9\n    Switched to Client for 9\n\n### 简单server\n\n\n    # On Unix: Access with ``$ nc 127.0.0.1 5000``\n    # On Window: Access with ``$ telnet 127.0.0.1 5000``\n\n    from gevent.server import StreamServer\n\n    def handle(socket, address):\n        socket.send(\"Hello from a telnet!\\n\")\n        for i in range(5):\n            socket.send(str(i) + '\\n')\n        socket.close()\n\n    server = StreamServer(('127.0.0.1', 5000), handle)\n    server.serve_forever()\n\n### WSGI Servers\n\nGevent为HTTP内容服务提供了两种WSGI server。从今以后就称为 wsgi和pywsgi：\n\n        gevent.wsgi.WSGIServer\n        gevent.pywsgi.WSGIServer\n\n在1.0.x之前更早期的版本里，gevent使用libevent而不是libev。 Libevent包含了一个快速HTTP server，它被用在gevent的wsgi server。\n\n在gevent 1.0.x版本，没有包括http server了。作为替代，gevent.wsgi 现在是纯Python server gevent.pywsgi的一个别名。\n\n### 流式server\n\n这个章节不适用于gevent 1.0.x版本\n\n熟悉流式HTTP服务(streaming HTTP service)的人知道，它的核心思想 就是在头部(header)不指定内容的长度。反而，我们让连接保持打开， 在每块数据前加一个16进制字节来指示数据块的长度，并将数据刷入pipe中。 当发出一个0长度数据块时，流会被关闭。\n\n    HTTP/1.1 200 OK\n    Content-Type: text/plain\n    Transfer-Encoding: chunked\n\n    8\n    \u003cp\u003eHello\n\n    9\n    World\u003c/p\u003e\n\n    0\n\n上述的HTTP连接不能在wsgi中创建，因为它不支持流式。 请求只有被缓冲(buffered)下来。\n\n    from gevent.wsgi import WSGIServer\n\n    def application(environ, start_response):\n        status = '200 OK'\n        body = '\u003cp\u003eHello World\u003c/p\u003e'\n\n        headers = [\n            ('Content-Type', 'text/html')\n        ]\n\n        start_response(status, headers)\n        return [body]\n\n    WSGIServer(('', 8000), application).serve_forever()\n\n\n然而使用pywsgi我们可以将handler写成generator，并以块的形式yield出结果。\n\n    from gevent.pywsgi import WSGIServer\n\n    def application(environ, start_response):\n        status = '200 OK'\n\n        headers = [\n            ('Content-Type', 'text/html')\n        ]\n\n        start_response(status, headers)\n        yield \"\u003cp\u003eHello\"\n        yield \"World\u003c/p\u003e\"\n\n    WSGIServer(('', 8000), application).serve_forever()\n\n\n但无论如何，与其它Python server相比gevent server性能是显胜的。 Libev是得到非常好审查的技术，由它写出的server在大规模上表现优异为人熟知。\n\n为了测试基准，试用Apache Benchmark ab或浏览[Benchmark of Python WSGI Servers](http://nichol.as/benchmark-of-python-web-servers)来与其它server作对比。\n\n    $ ab -n 10000 -c 100 http://127.0.0.1:8000/\n\n### Long Polling\n\n    import gevent\n    from gevent.queue import Queue, Empty\n    from gevent.pywsgi import WSGIServer\n    import simplejson as json\n\n    data_source = Queue()\n\n    def producer():\n        while True:\n            data_source.put_nowait('Hello World')\n            gevent.sleep(1)\n\n    def ajax_endpoint(environ, start_response):\n        status = '200 OK'\n        headers = [\n            ('Content-Type', 'application/json')\n        ]\n\n        start_response(status, headers)\n\n        while True:\n            try:\n                datum = data_source.get(timeout=5)\n                yield json.dumps(datum) + '\\n'\n            except Empty:\n                pass\n\n    gevent.spawn(producer)\n\n    WSGIServer(('', 8000), ajax_endpoint).serve_forever()\n\n\n### Websockets\n\n运行Websocket的例子需要[gevent-websocket](https://bitbucket.org/Jeffrey/gevent-websocket/src)包。\n\n    # Simple gevent-websocket server\n    import json\n    import random\n\n    from gevent import pywsgi, sleep\n    from geventwebsocket.handler import WebSocketHandler\n\n    class WebSocketApp(object):\n        '''Send random data to the websocket'''\n\n        def __call__(self, environ, start_response):\n            ws = environ['wsgi.websocket']\n            x = 0\n            while True:\n                data = json.dumps({'x': x, 'y': random.randint(1, 5)})\n                ws.send(data)\n                x += 1\n                sleep(0.5)\n\n    server = pywsgi.WSGIServer((\"\", 10000), WebSocketApp(),\n        handler_class=WebSocketHandler)\n    server.serve_forever()\n\nHTML Page:\n\n    \u003chtml\u003e\n        \u003chead\u003e\n            \u003ctitle\u003eMinimal websocket application\u003c/title\u003e\n            \u003cscript type=\"text/javascript\" src=\"jquery.min.js\"\u003e\u003c/script\u003e\n            \u003cscript type=\"text/javascript\"\u003e\n            $(function() {\n                // Open up a connection to our server\n                var ws = new WebSocket(\"ws://localhost:10000/\");\n\n                // What do we do when we get a message?\n                ws.onmessage = function(evt) {\n                    $(\"#placeholder\").append('\u003cp\u003e' + evt.data + '\u003c/p\u003e')\n                }\n                // Just update our conn_status field with the connection status\n                ws.onopen = function(evt) {\n                    $('#conn_status').html('\u003cb\u003eConnected\u003c/b\u003e');\n                }\n                ws.onerror = function(evt) {\n                    $('#conn_status').html('\u003cb\u003eError\u003c/b\u003e');\n                }\n                ws.onclose = function(evt) {\n                    $('#conn_status').html('\u003cb\u003eClosed\u003c/b\u003e');\n                }\n            });\n        \u003c/script\u003e\n        \u003c/head\u003e\n        \u003cbody\u003e\n            \u003ch1\u003eWebSocket Example\u003c/h1\u003e\n            \u003cdiv id=\"conn_status\"\u003eNot Connected\u003c/div\u003e\n            \u003cdiv id=\"placeholder\" style=\"width:600px;height:300px;\"\u003e\u003c/div\u003e\n        \u003c/body\u003e\n    \u003c/html\u003e\n\n### 聊天server\n\n最后一个生动的例子，实现一个实时聊天室。运行这个例子需要 [Flask](http://flask.pocoo.org/) (你可以使用Django, Pyramid等，但不是必须的)。 对应的Javascript和HTML文件可以在[这里](https://github.com/sdiehl/minichat)找到。\n\n    # Micro gevent chatroom.\n    # ----------------------\n\n    from flask import Flask, render_template, request\n\n    from gevent import queue\n    from gevent.pywsgi import WSGIServer\n\n    import simplejson as json\n\n    app = Flask(__name__)\n    app.debug = True\n\n    rooms = {\n        'topic1': Room(),\n        'topic2': Room(),\n    }\n\n    users = {}\n\n    class Room(object):\n\n        def __init__(self):\n            self.users = set()\n            self.messages = []\n\n        def backlog(self, size=25):\n            return self.messages[-size:]\n\n        def subscribe(self, user):\n            self.users.add(user)\n\n        def add(self, message):\n            for user in self.users:\n                print(user)\n                user.queue.put_nowait(message)\n            self.messages.append(message)\n\n    class User(object):\n\n        def __init__(self):\n            self.queue = queue.Queue()\n\n    @app.route('/')\n    def choose_name():\n        return render_template('choose.html')\n\n    @app.route('/\u003cuid\u003e')\n    def main(uid):\n        return render_template('main.html',\n            uid=uid,\n            rooms=rooms.keys()\n        )\n\n    @app.route('/\u003croom\u003e/\u003cuid\u003e')\n    def join(room, uid):\n        user = users.get(uid, None)\n\n        if not user:\n            users[uid] = user = User()\n\n        active_room = rooms[room]\n        active_room.subscribe(user)\n        print('subscribe %s %s' % (active_room, user))\n\n        messages = active_room.backlog()\n\n        return render_template('room.html',\n            room=room, uid=uid, messages=messages)\n\n    @app.route(\"/put/\u003croom\u003e/\u003cuid\u003e\", methods=[\"POST\"])\n    def put(room, uid):\n        user = users[uid]\n        room = rooms[room]\n\n        message = request.form['message']\n        room.add(':'.join([uid, message]))\n\n        return ''\n\n    @app.route(\"/poll/\u003cuid\u003e\", methods=[\"POST\"])\n    def poll(uid):\n        try:\n            msg = users[uid].queue.get(timeout=10)\n        except queue.Empty:\n            msg = []\n        return json.dumps(msg)\n\n    if __name__ == \"__main__\":\n        http = WSGIServer(('', 5000), app)\n        http.serve_forever()\n\n\n","Tags":["python"],"CreateTime":1430190701,"EditTime":1430191208,"UpdateTime":1430190701,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":474}