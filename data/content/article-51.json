{"Id":51,"Title":"Simple-Clojure","Slug":"2014-10-28-3","Text":"    \n    ; 注释以分号开始。\n    \n    ; Clojure代码由一个个form组成， 即写在小括号里的由空格分开的一组语句。\n    ; Clojure解释器会把第一个元素当做一个函数或者宏来调用，其余的被认为是参数。\n    \n    ; Clojure代码的第一条语句一般是用ns来指定当前的命名空间。\n    (ns learnclojure)\n    \n    ; 更基本的例子:\n    \n    ; str会使用所有参数来创建一个字符串\n    (str \"Hello\" \" \" \"World\") ; =\u003e \"Hello World\"\n    \n    ; 数学计算比较直观\n    (+ 1 1) ; =\u003e 2\n    (- 2 1) ; =\u003e 1\n    (* 1 2) ; =\u003e 2\n    (/ 2 1) ; =\u003e 2\n    \n    ; 等号是 =\n    (= 1 1) ; =\u003e true\n    (= 2 1) ; =\u003e false\n    \n    ; 逻辑非\n    (not true) ; =\u003e false\n    \n    ; 嵌套的form工作起来应该和你预想的一样\n    (+ 1 (- 3 2)) ; = 1 + (3 - 2) =\u003e 2\n    \n    ; 类型\n    ;;;;;;;;;;;;;\n    \n    ; Clojure使用Java的Object来描述布尔值、字符串和数字\n    ; 用函数 `class` 来查看具体的类型\n    (class 1) ; 整形默认是java.lang.Long类型\n    (class 1.); 浮点默认是java.lang.Double类型的\n    (class \"\"); String是java.lang.String类型的，要用双引号引起来\n    (class false) ; 布尔值是java.lang.Boolean类型的\n    (class nil); \"null\"被称作nil\n    \n    ; 如果你想创建一组数据字面量，用单引号(')来阻止form被解析和求值\n    '(+ 1 2) ; =\u003e (+ 1 2)\n    ; (单引号是quote的简写形式，故上式等价于(quote (+ 1 2)))\n    \n    ; 可以对一个引用列表求值\n    (eval '(+ 1 2)) ; =\u003e 3\n    \n    ; 集合（Collection）和序列\n    ;;;;;;;;;;;;;;;;;;;\n    \n    ; List的底层实现是链表，Vector的底层实现是数组\n    ; 二者也都是java类\n    (class [1 2 3]); =\u003e clojure.lang.PersistentVector\n    (class '(1 2 3)); =\u003e clojure.lang.PersistentList\n    \n    ; list本可以写成(1 2 3), 但必须用引用来避免被解释器当做函数来求值。\n    ; (list 1 2 3)等价于'(1 2 3)\n    \n    ; 集合其实就是一组数据\n    ; List和Vector都是集合:\n    (coll? '(1 2 3)) ; =\u003e true\n    (coll? [1 2 3]) ; =\u003e true\n    \n    ; 序列 (seqs) 是数据列表的抽象描述\n    ; 只有列表才可称作序列。\n    (seq? '(1 2 3)) ; =\u003e true\n    (seq? [1 2 3]) ; =\u003e false\n    \n    ; 序列被访问时只需要提供一个值，所以序列可以被懒加载——也就意味着可以定义一个无限序列：\n    (range 4) ; =\u003e (0 1 2 3)\n    (range) ; =\u003e (0 1 2 3 4 ...) (无限序列)\n    (take 4 (range)) ;  (0 1 2 3)\n    \n    ; cons用以向列表或向量的起始位置添加元素\n    (cons 4 [1 2 3]) ; =\u003e (4 1 2 3)\n    (cons 4 '(1 2 3)) ; =\u003e (4 1 2 3)\n    \n    ; conj将以最高效的方式向集合中添加元素。\n    ; 对于列表，数据会在起始位置插入，而对于向量，则在末尾位置插入。\n    (conj [1 2 3] 4) ; =\u003e [1 2 3 4]\n    (conj '(1 2 3) 4) ; =\u003e (4 1 2 3)\n    \n    ; 用concat来合并列表或向量\n    (concat [1 2] '(3 4)) ; =\u003e (1 2 3 4)\n    \n    ; 用filter来过滤集合中的元素，用map来根据指定的函数来映射得到一个新的集合\n    (map inc [1 2 3]) ; =\u003e (2 3 4)\n    (filter even? [1 2 3]) ; =\u003e (2)\n    \n    ; recuce使用函数来规约集合\n    (reduce + [1 2 3 4])\n    ; = (+ (+ (+ 1 2) 3) 4)\n    ; =\u003e 10\n    \n    ; reduce还能指定一个初始参数\n    (reduce conj [] '(3 2 1))\n    ; = (conj (conj (conj [] 3) 2) 1)\n    ; =\u003e [3 2 1]\n    \n    ; 函数\n    ;;;;;;;;;;;;;;;;;;;;;\n    \n    ; 用fn来创建函数。函数的返回值是最后一个表达式的值\n    (fn [] \"Hello World\") ; =\u003e fn\n    \n    ; (你需要再嵌套一组小括号来调用它)\n    ((fn [] \"Hello World\")) ; =\u003e \"Hello World\"\n    \n    ; 你可以用def来创建一个变量（var）\n    (def x 1)\n    x ; =\u003e 1\n    \n    ; 将函数定义为一个变量（var）\n    (def hello-world (fn [] \"Hello World\"))\n    (hello-world) ; =\u003e \"Hello World\"\n    \n    ; 你可用defn来简化函数的定义\n    (defn hello-world [] \"Hello World\")\n    \n    ; 中括号内的内容是函数的参数。\n    (defn hello [name]\n      (str \"Hello \" name))\n    (hello \"Steve\") ; =\u003e \"Hello Steve\"\n    \n    ; 你还可以用这种简写的方式来创建函数：\n    (def hello2 #(str \"Hello \" %1))\n    (hello2 \"Fanny\") ; =\u003e \"Hello Fanny\"\n    \n    ; 函数也可以有多个参数列表。\n    (defn hello3\n      ([] \"Hello World\")\n      ([name] (str \"Hello \" name)))\n    (hello3 \"Jake\") ; =\u003e \"Hello Jake\"\n    (hello3) ; =\u003e \"Hello World\"\n    \n    ; 可以定义变参函数，即把\u0026后面的参数全部放入一个序列\n    (defn count-args [\u0026 args]\n      (str \"You passed \" (count args) \" args: \" args))\n    (count-args 1 2 3) ; =\u003e \"You passed 3 args: (1 2 3)\"\n    \n    ; 可以混用定参和变参（用\u0026来界定）\n    (defn hello-count [name \u0026 args]\n      (str \"Hello \" name \", you passed \" (count args) \" extra args\"))\n    (hello-count \"Finn\" 1 2 3)\n    ; =\u003e \"Hello Finn, you passed 3 extra args\"\n    \n    \n    ; 哈希表\n    ;;;;;;;;;;\n    \n    ; 基于hash的map和基于数组的map（即arraymap）实现了相同的接口，hashmap查询起来比较快，\n    ; 但不保证元素的顺序。\n    (class {:a 1 :b 2 :c 3}) ; =\u003e clojure.lang.PersistentArrayMap\n    (class (hash-map :a 1 :b 2 :c 3)) ; =\u003e clojure.lang.PersistentHashMap\n    \n    ; arraymap在足够大的时候，大多数操作会将其自动转换成hashmap，\n    ; 所以不用担心(对大的arraymap的查询性能)。\n    \n    ; map支持很多类型的key，但推荐使用keyword类型\n    ; keyword类型和字符串类似，但做了一些优化。\n    (class :a) ; =\u003e clojure.lang.Keyword\n    \n    (def stringmap {\"a\" 1, \"b\" 2, \"c\" 3})\n    stringmap  ; =\u003e {\"a\" 1, \"b\" 2, \"c\" 3}\n    \n    (def keymap {:a 1, :b 2, :c 3})\n    keymap ; =\u003e {:a 1, :c 3, :b 2}\n    \n    ; 顺便说一下，map里的逗号是可有可无的，作用只是提高map的可读性。\n    \n    ; 从map中查找元素就像把map名作为函数调用一样。\n    (stringmap \"a\") ; =\u003e 1\n    (keymap :a) ; =\u003e 1\n    \n    ; 可以把keyword写在前面来从map中查找元素。\n    (:b keymap) ; =\u003e 2\n    \n    ; 但不要试图用字符串类型的key来这么做。\n    ;(\"a\" stringmap)\n    ; =\u003e Exception: java.lang.String cannot be cast to clojure.lang.IFn\n    \n    ; 查找不存在的key会返回nil。\n    (stringmap \"d\") ; =\u003e nil\n    \n    ; 用assoc函数来向hashmap里添加元素\n    (def newkeymap (assoc keymap :d 4))\n    newkeymap ; =\u003e {:a 1, :b 2, :c 3, :d 4}\n    \n    ; 但是要记住的是clojure的数据类型是不可变的！\n    keymap ; =\u003e {:a 1, :b 2, :c 3}\n    \n    ; 用dissoc来移除元素\n    (dissoc keymap :a :b) ; =\u003e {:c 3}\n    \n    ; 集合（Set）\n    ;;;;;;\n    \n    (class #{1 2 3}) ; =\u003e clojure.lang.PersistentHashSet\n    (set [1 2 3 1 2 3 3 2 1 3 2 1]) ; =\u003e #{1 2 3}\n    \n    ; 用conj新增元素\n    (conj #{1 2 3} 4) ; =\u003e #{1 2 3 4}\n    \n    ; 用disj移除元素\n    (disj #{1 2 3} 1) ; =\u003e #{2 3}\n    \n    ; 把集合当做函数调用来检查元素是否存在:\n    (#{1 2 3} 1) ; =\u003e 1\n    (#{1 2 3} 4) ; =\u003e nil\n    \n    ; 在clojure.sets模块下有很多相关函数。\n    \n    ; 常用的form\n    ;;;;;;;;;;;;;;;;;\n    \n    ; clojure里的逻辑控制结构都是用宏（macro）实现的，这在语法上看起来没什么不同。\n    (if false \"a\" \"b\") ; =\u003e \"b\"\n    (if false \"a\") ; =\u003e nil\n    \n    ; 用let来创建临时的绑定变量。\n    (let [a 1 b 2]\n      (\u003e a b)) ; =\u003e false\n    \n    ; 用do将多个语句组合在一起依次执行\n    (do\n      (print \"Hello\")\n      \"World\") ; =\u003e \"World\" (prints \"Hello\")\n    \n    ; 函数定义里有一个隐式的do\n    (defn print-and-say-hello [name]\n      (print \"Saying hello to \" name)\n      (str \"Hello \" name))\n    (print-and-say-hello \"Jeff\") ;=\u003e \"Hello Jeff\" (prints \"Saying hello to Jeff\")\n    \n    ; let也是如此\n    (let [name \"Urkel\"]\n      (print \"Saying hello to \" name)\n      (str \"Hello \" name)) ; =\u003e \"Hello Urkel\" (prints \"Saying hello to Urkel\")\n    \n    ; 模块\n    ;;;;;;;;;;;;;;;\n    \n    ; 用use来导入模块里的所有函数\n    (use 'clojure.set)\n    \n    ; 然后就可以使用set相关的函数了\n    (intersection #{1 2 3} #{2 3 4}) ; =\u003e #{2 3}\n    (difference #{1 2 3} #{2 3 4}) ; =\u003e #{1}\n    \n    ; 你也可以从一个模块里导入一部分函数。\n    (use '[clojure.set :only [intersection]])\n    \n    ; 用require来导入一个模块\n    (require 'clojure.string)\n    \n    ; 用/来调用模块里的函数\n    ; 下面是从模块`clojure.string`里调用`blank?`函数。\n    (clojure.string/blank? \"\") ; =\u003e true\n    \n    ; 在`import`里你可以给模块名指定一个较短的别名。\n    (require '[clojure.string :as str])\n    (str/replace \"This is a test.\" #\"[a-o]\" str/upper-case) ; =\u003e \"THIs Is A tEst.\"\n    ; (#\"\"用来表示一个正则表达式)\n    \n    ; 你可以在一个namespace定义里用:require的方式来require（或use，但最好不要用）模块。\n    ; 这样的话你无需引用模块列表。\n    (ns test\n      (:require\n        [clojure.string :as str]\n        [clojure.set :as set]))\n    \n    ; Java\n    ;;;;;;;;;;;;;;;;;\n    \n    ; Java有大量的优秀的库，你肯定想学会如何用clojure来使用这些Java库。\n    \n    ; 用import来导入java类\n    (import java.util.Date)\n    \n    ; 也可以在ns定义里导入\n    (ns test\n      (:import java.util.Date\n               java.util.Calendar))\n    \n    ; 用类名末尾加`.`的方式来new一个Java对象\n    (Date.) ; \u003ca date object\u003e\n    \n    ; 用`.`操作符来调用方法，或者用`.method`的简化方式。\n    (. (Date.) getTime) ; \u003ca timestamp\u003e\n    (.getTime (Date.)) ; 和上例一样。\n    \n    ; 用`/`调用静态方法\n    (System/currentTimeMillis) ; \u003ca timestamp\u003e (system is always present)\n    \n    ; 用`doto`来更方便的使用（可变）类。\n    (import java.util.Calendar)\n    (doto (Calendar/getInstance)\n      (.set 2000 1 1 0 0 0)\n      .getTime) ; =\u003e A Date. set to 2000-01-01 00:00:00\n    \n    ; STM\n    ;;;;;;;;;;;;;;;;;\n    \n    ; 软件内存事务（Software Transactional Memory）被clojure用来处理持久化的状态。\n    ; clojure里内置了一些结构来使用STM。\n    ; atom是最简单的。给它传一个初始值\n    (def my-atom (atom {}))\n    \n    ; 用`swap!`更新atom。\n    ; `swap!`会以atom的当前值为第一个参数来调用一个指定的函数，\n    ; `swap`其余的参数作为该函数的第二个参数。\n    (swap! my-atom assoc :a 1) ; Sets my-atom to the result of (assoc {} :a 1)\n    (swap! my-atom assoc :b 2) ; Sets my-atom to the result of (assoc {:a 1} :b 2)\n    \n    ; 用`@`读取atom的值\n    my-atom  ;=\u003e Atom\u003c#...\u003e (返回Atom对象)\n    @my-atom ; =\u003e {:a 1 :b 2}\n    \n    ; 下例是一个使用atom实现的简单计数器\n    (def counter (atom 0))\n    (defn inc-counter []\n      (swap! counter inc))\n    \n    (inc-counter)\n    (inc-counter)\n    (inc-counter)\n    (inc-counter)\n    (inc-counter)\n    \n    @counter ; =\u003e 5\n    \n    ; 其他STM相关的结构是ref和agent.\n    ; Refs: http://clojure.org/refs\n    ; Agents: http://clojure.org/agents\n","Tags":["clojure"," learnxinyminutes"],"CreateTime":1414472049,"EditTime":1414472049,"UpdateTime":1414472049,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":317}