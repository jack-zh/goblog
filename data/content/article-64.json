{"Id":64,"Title":"Simple-javascript","Slug":"2014-10-28-8","Text":"    \n    // 注释方式和C很像，这是单行注释\n    /* 这是多行\n       注释 */\n    \n    // 语句可以以分号结束\n    doStuff();\n    \n    // ... 但是分号也可以省略，每当遇到一个新行时，分号会自动插入\n    doStuff()\n    \n    // 我们在这里会去掉分号，但是否添加最后的分号取决于你个人的习惯\n    // 及你所在团队的编程风格\n    \n    ///////////////////////////////////\n    // 1. 数字、字符串与操作符\n    \n    // Javascript 只有一种数字类型 (即 64位 IEEE 754 双精度浮点).\n    3 // = 3\n    1.5 // = 1.5\n    \n    // 所有基本的算数运算\n    1 + 1 // = 2\n    8 - 1 // = 7\n    10 * 2 // = 20\n    35 / 5 // = 7\n    \n    // 包括无法整除的除法\n    5 / 2 // = 2.5\n    \n    // 位运算也和其他语言一样。当你对浮点数进行位运算时，\n    // 浮点数会转换为至多 32 位的无符号整数\n    1 \u003c\u003c 2 // = 4\n    \n    // 括号可以决定优先级\n    (1 + 3) * 2 // = 8\n    \n    // 有三种非数字的数字类型\n    Infinity //  1/0 的结果\n    -Infinity // -1/0 的结果\n    NaN // 0/0 的结果\n    \n    // 也有布尔值\n    true\n    false\n    \n    // 可以通过单引号或双引号来构造字符串\n    'abc'\n    \"Hello, world\"\n    \n    // 用！来取非\n    !true // = false\n    !false // = true\n    \n    // 相等 ==\n    1 == 1 // = true\n    2 == 1 // = false\n    \n    // 不等 !=\n    1 != 1 // = false\n    2 != 1 // = true\n    \n    // 更多的比较操作符 \n    1 \u003c 10 // = true\n    1 \u003e 10 // = false\n    2 \u003c= 2 // = true\n    2 \u003e= 2 // = true\n    \n    // 字符串用+连接\n    \"Hello \" + \"world!\" // = \"Hello world!\"\n    \n    // 字符串也可以用 \u003c 、\u003e 来比较\n    \"a\" \u003c \"b\" // = true\n    \n    // 比较时会进行类型转换...\n    \"5\" == 5 // = true\n    \n    // ...除非你是用 ===\n    \"5\" === 5 // = false\n    \n    // 你可以用charAt来得到字符串中的字符\n    \"This is a string\".charAt(0)\n    \n    // 还有两个特殊的值：null和undefined\n    null // 用来表示刻意设置成的空值\n    undefined // 用来表示还没有设置的值\n    \n    // null, undefined, NaN, 0 和 \"\" 都是假的（false），其他的都视作逻辑真\n    // 注意 0 是逻辑假而  \"0\"是逻辑真, 尽管 0 == \"0\".\n    \n    ///////////////////////////////////\n    // 2. 变量、数组和对象\n    \n    // 变量需要用 var 这个关键字声明. Javascript是动态类型语言\n    // 所以你在声明时无需指定类型。 赋值需要用 = \n    var someVar = 5\n    \n    // 如果你在声明时没有加var关键字，你也不会得到错误\n    someOtherVar = 10\n    \n    // ...但是此时这个变量就会拥有全局的作用域，而非当前作用域\n    \n    // 没有被赋值的变量都会返回undefined这个值\n    var someThirdVar // = undefined\n    \n    // 对变量进行数学运算有一些简写法\n    someVar += 5 // 等价于 someVar = someVar + 5; someVar 现在是 10 \n    someVar *= 10 // 现在 someVar 是 100\n    \n    // 自增和自减也有简写\n    someVar++ // someVar 是 101\n    someVar-- // 回到 100\n    \n    // 数组是任意类型组成的有序列表\n    var myArray = [\"Hello\", 45, true]\n    \n    // 数组的元素可以用方括号下标来访问\n    // 数组的索引从0开始\n    myArray[1] // = 45\n    \n    // javascript中的对象相当于其他语言中的字典或映射：是键-值的集合\n    {key1: \"Hello\", key2: \"World\"}\n    \n    // 键是字符串，但是引号也并非是必须的，如果键本身是合法的js标识符\n    // 而值则可以是任意类型的值\n    var myObj = {myKey: \"myValue\", \"my other key\": 4}\n    \n    // 对象的访问可以通过下标\n    myObj[\"my other key\"] // = 4\n    \n    // ... 或者也可以用 . ，如果属性是合法的标识符\n    myObj.myKey // = \"myValue\"\n    \n    // 对象是可变的，键和值也可以被更改或增加\n    myObj.myThirdKey = true\n    \n    // 如果你想要访问一个还没有被定义的属性，那么会返回undefined\n    myObj.myFourthKey // = undefined\n    \n    ///////////////////////////////////\n    // 3. 逻辑与控制结构\n    \n    // if语句和其他语言中一样\n    var count = 1\n    if (count == 3){\n        // count 是 3 时执行\n    } else if (count == 4) {\n        // count 是 4 时执行\n    } else {\n        // 其他情况下执行 \n    }\n    \n    // while循环\n    while (true) {\n        // 无限循环\n    }\n    \n    // Do-while 和 While 循环很像 ，但前者会至少执行一次\n    var input\n    do {\n        input = getInput()\n    } while (!isValid(input))\n    \n    // for循环和C、Java中的一样\n    // 初始化; 继续执行的条件; 遍历后执行.\n    for (var i = 0; i \u003c 5; i++){\n        // 遍历5次\n    }\n    \n    // \u0026\u0026 是逻辑与, || 是逻辑或\n    if (house.size == \"big\" \u0026\u0026 house.colour == \"blue\"){\n        house.contains = \"bear\"\n    }\n    if (colour == \"red\" || colour == \"blue\"){\n        // colour是red或者blue时执行\n    }\n    \n    // \u0026\u0026 和 || 是“短路”语句，在初始化值时会变得有用 \n    var name = otherName || \"default\"\n    \n    ///////////////////////////////////\n    // 4. 函数、作用域、闭包\n    \n    // JavaScript 函数由function关键字定义\n    function myFunction(thing){\n        return thing.toUpperCase()\n    }\n    myFunction(\"foo\") // = \"FOO\"\n    \n    // 函数也可以是匿名的：\n    function(thing){\n        return thing.toLowerCase()\n    }\n    // (我们无法调用此函数，因为我们不知道这个函数的名字)\n    \n    // javascript中的函数也是对象，所以函数也能够赋给一个变量，并且被传递\n    // 比如一个事件处理函数：\n    function myFunction(){\n        // this code will be called in 5 seconds' time\n    }\n    setTimeout(myFunction, 5000)\n    \n    // 你甚至可以直接把一个函数写到另一个函数的参数中\n    \n    setTimeout(function myFunction(){\n        // 5秒之后会执行这里的代码\n    }, 5000)\n    \n    // JavaScript 仅有函数作用于，而其他的语句则没有作用域\n    if (true){\n        var i = 5\n    }\n    i // = 5 - 并非我们在其他语言中所得到的undefined\n    \n    // 这就导致了人们经常用一种叫做“即使执行匿名函数”的模式\n    // 这样可以避免一些临时变量扩散到外边去\n    function(){\n        var temporary = 5\n        // 我们可以访问一个全局对象来访问全局作用域\n        // 在浏览器中是 'window' 这个对象。 \n        // 在Node.js中这个对象的名字可能会不同。\n        window.permanent = 10\n        // 或者，我们也可以把var去掉就行了\n        permanent2 = 15\n    }()\n    temporary // 抛出引用异常\n    permanent // = 10\n    permanent2 // = 15\n    \n    // javascript最强大的功能之一就是闭包\n    // 如果一个函数在另一个函数中定义，那么这个函数就拥有外部函数的所有访问权\n    function sayHelloInFiveSeconds(name){\n        var prompt = \"Hello, \" + name + \"!\"\n        function inner(){\n            alert(prompt)\n        }\n        setTimeout(inner, 5000)\n        // setTimeout 是异步的，所以这个函数会马上终止不会等待。\n        // 然而，在5秒结束后，inner函数仍然会弹出prompt信息。\n    }\n    sayHelloInFiveSeconds(\"Adam\") // 会在5秒后弹出 \"Hello, Adam!\" \n    \n    ///////////////////////////////////\n    // 5. 对象、构造函数与原型\n    \n    //  对象包含方法\n    var myObj = {\n        myFunc: function(){\n            return \"Hello world!\"\n        }\n    }\n    myObj.myFunc() // = \"Hello world!\"\n    \n    // 当对象中的函数被调用时，这个函数就可以通过this关键字访问这个对象\n    myObj = {\n        myString: \"Hello world!\",\n        myFunc: function(){\n            return this.myString\n        }\n    }\n    myObj.myFunc() // = \"Hello world!\"\n    \n    // 但这个函数访问的其实是其运行时环境，而非定义时环境\n    // 所以如果函数所在的环境不在当前对象的环境中运行时，就运行不成功了\n    var myFunc = myObj.myFunc\n    myFunc() // = undefined\n    \n    // 相应的，一个函数也可以被指定为一个对象的方法，并且用过this可以访问\n    // 这个对象的成员，即使在定义时并没有绑定任何值\n    var myOtherFunc = function(){\n        return this.myString.toUpperCase()\n    }\n    myObj.myOtherFunc = myOtherFunc\n    myObj.myOtherFunc() // = \"HELLO WORLD!\"\n    \n    // 当你通过new关键字调用一个函数时，就会生成一个对象\n    // 而对象的成员需要通过this来定义。\n    // 这样的函数就叫做构造函数\n    \n    var MyConstructor = function(){\n        this.myNumber = 5\n    }\n    myNewObj = new MyConstructor() // = {myNumber: 5}\n    myNewObj.myNumber // = 5\n    \n    // 每一个js对象都有一个原型，当你要访问一个没有定义过的成员时，\n    // 解释器就回去找这个对象的原型\n    \n    // 有一些JS实现会让你通过一个对象的__proto__方法访问这个原型。\n    // 这虽然对理解这个对象很有用，但是这并不是标准的一部分\n    // 我们之后会通过标准方式来访问原型。\n    var myObj = {\n        myString: \"Hello world!\",\n    }\n    var myPrototype = {\n        meaningOfLife: 42,\n        myFunc: function(){\n            return this.myString.toLowerCase()\n        }\n    }\n    myObj.__proto__ = myPrototype\n    myObj.meaningOfLife // = 42\n    \n    // This works for functions, too.\n    myObj.myFunc() // = \"hello world!\"\n    \n    // 当然，如果你要访问的成员在原型当中也没有定义的话，解释器就会去找原型的原型。\n    myPrototype.__proto__ = {\n        myBoolean: true\n    }\n    myObj.myBoolean // = true\n    \n    // 这其中并没有对象的拷贝。每个对象的原型实际上是持有原型对象的引用\n    // 这说明当我们改变对象的原型时，会影响到其他以这个原型为原型的对象\n    myPrototype.meaningOfLife = 43\n    myObj.meaningOfLife // = 43\n    \n    // 我们知道 __proto__ 并非标准规定，实际上也没有办法更改已经指定好的原型。\n    // 但是，我们有两种方式可以为新的对象指定原型。\n    \n    // 第一种方式是 Object.create，这个方法是在最近才被添加到Js中的\n    // 也因此并不是所有的JS实现都有这个放啊\n    var myObj = Object.create(myPrototype)\n    myObj.meaningOfLife // = 43\n    \n    // 第二种方式可以在任意版本中使用，不过需要通过构造函数。\n    // 构造函数有一个属性prototype。但是这 *不是* 构造函数本身的函数\n    // 而是通过构造函数和new关键字生成新对象时自动生成的。\n    myConstructor.prototype = {\n        getMyNumber: function(){\n            return this.myNumber\n        }\n    }\n    var myNewObj2 = new myConstructor()\n    myNewObj2.getMyNumber() // = 5\n    \n    // 字符串和数字等内置类型也有通过构造函数来创建的包装类型\n    var myNumber = 12\n    var myNumberObj = new Number(12)\n    myNumber == myNumberObj // = true\n    \n    // 但是它们并非严格等价\n    typeof myNumber // = 'number'\n    typeof myNumberObj // = 'object'\n    myNumber === myNumberObj // = false\n    if (0){\n        // 这段代码不会执行，因为0代表假\n    }\n    if (Number(0)){\n        // 这段代码会执行，因为Number(0)代表真\n    }\n    \n    // 但是，包装类型和内置类型共享一个原型\n    // 这样你就可以给内置类型也增加一些功能\n    String.prototype.firstCharacter = function(){\n        return this.charAt(0)\n    }\n    \"abc\".firstCharacter() // = \"a\"\n    \n    // 这个技巧可以用来用老版本的javascript子集来是实现新版本js的功能\n    // 这样就可以在老的浏览器中使用新功能了。\n    \n    // 比如，我们知道Object.create并没有在所有的版本中都实现\n    // 但是我们仍然可以通过这个技巧来使用\n    if (Object.create === undefined){ // 如果存在则不覆盖\n        Object.create = function(proto){\n            // 用正确的原型来创建一个临时构造函数\n            var Constructor = function(){}\n            Constructor.prototype = proto\n            // 之后用它来创建一个新的对象\n            return new Constructor()\n        }\n    }\n","Tags":["learnxinyminutes"," javascript"],"CreateTime":1414472450,"EditTime":1414472450,"UpdateTime":1414472450,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":172}