{"Id":54,"Title":"Simple-common lisp","Slug":"2014-10-28-4","Text":"    \n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    ;;; 0. 语法\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    \n    ;;; 一般形式\n    \n    ;; Lisp有两个基本的语法单元：原子（atom），以及S-表达式。\n    ;; 一般的，一组S-表达式被称为“组合式”。\n    \n    10  ; 一个原子; 它对自身进行求值\n    \n    :THING ;同样是一个原子；它被求值为一个符号 :thing\n    \n    t  ;还是一个原子，代表逻辑真值。\n    \n    (+ 1 2 3 4) ; 一个S-表达式。\n    \n    '(4 :foo  t)  ;同样是一个S-表达式。\n    \n    \n    ;;; 注释\n    \n    ;; 一个分号开头的注释表示仅用于此行（单行）；两个分号开头的则表示一个所谓标准注释；\n    ;; 三个分号开头的意味着段落注释；\n    ;; 而四个分号开头的注释用于文件头注释（译者注：即对该文件的说明）。\n    \n    #| 块注释\n       可以涵盖多行，而且...\n        #|\n           他们可以被嵌套！\n        |#\n    |#\n    \n    ;;; 运行环境\n    \n    ;; 有很多不同的Common Lisp的实现；并且大部分的实现是一致（可移植）的。\n    ;; 对于入门学习来说，CLISP是个不错的选择。\n    \n    ;; 可以通过QuickLisp.org的Quicklisp系统管理你的库。\n    \n    ;; 通常，使用文本编辑器和“REPL”来开发Common Lisp；\n    ;; （译者注：“REPL”指读取-求值-打印循环）。\n    ;; “REPL”允许对程序进行交互式的运行、调试，就好像在系统“现场”操作。\n    \n    \n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    ;;; 1. 基本数据类型以及运算符\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    \n    ;;; 符号\n    \n    'foo ; =\u003e FOO  注意到这个符号被自动转换成大写了。\n    \n    ;; `intern`由一个给定的字符串而创建相应的符号\n    \n    (intern \"AAAA\") ; =\u003e AAAA\n    \n    (intern \"aaa\") ; =\u003e |aaa|\n    \n    ;;; 数字\n    9999999999999999999999 ; 整型数\n    #b111                  ; 二进制 =\u003e 7\n    #o111                  ; 八进制 =\u003e 73\n    #x111                  ; 十六进制 =\u003e 273\n    3.14159s0              ; 单精度\n    3.14159d0              ; 双精度\n    1/2                    ; 分数\n    #C(1 2)                ; 复数\n    \n    \n    ;; 使用函数时，应当写成这样的形式：(f x y z ...)；\n    ;; 其中，f是一个函数（名），x, y, z为参数；\n    ;; 如果你想创建一个“字面”意义上（即不求值）的列表， 只需使用单引号 ' ，\n    ;; 从而避免接下来的表达式被求值。即，只“引用”这个数据（而不求值）。\n    '(+ 1 2) ; =\u003e (+ 1 2)\n    ;; 你同样也可以手动地调用一个函数（译者注：即使用函数对象来调用函数）：\n    (funcall #'+ 1 2 3) ; =\u003e 6\n    ;; 一些算术运算符\n    (+ 1 1)              ; =\u003e 2\n    (- 8 1)              ; =\u003e 7\n    (* 10 2)             ; =\u003e 20\n    (expt 2 3)           ; =\u003e 8\n    (mod 5 2)            ; =\u003e 1\n    (/ 35 5)             ; =\u003e 7\n    (/ 1 3)              ; =\u003e 1/3\n    (+ #C(1 2) #C(6 -4)) ; =\u003e #C(7 -2)\n    \n                         ;;; 布尔运算\n    t                    ; 逻辑真（任何不是nil的值都被视为真值）\n    nil                  ; 逻辑假，或者空列表\n    (not nil)            ; =\u003e t\n    (and 0 t)            ; =\u003e t\n    (or 0 nil)           ; =\u003e 0\n    \n                         ;;; 字符\n    #\\A                  ; =\u003e #\\A\n    #\\λ                  ; =\u003e #\\GREEK_SMALL_LETTER_LAMDA（希腊字母Lambda的小写）\n    #\\u03BB              ; =\u003e #\\GREEK_SMALL_LETTER_LAMDA（Unicode形式的小写希腊字母Lambda）\n    \n    ;;; 字符串被视为一个定长字符数组\n    \"Hello, world!\"\n    \"Benjamin \\\"Bugsy\\\" Siegel\"   ;反斜杠用作转义字符\n    \n    ;; 可以拼接字符串\n    (concatenate 'string \"Hello \" \"world!\") ; =\u003e \"Hello world!\"\n    \n    ;; 一个字符串也可被视作一个字符序列\n    (elt \"Apple\" 0) ; =\u003e #\\A\n    \n    ;; `format`被用于格式化字符串\n    (format nil \"~a can be ~a\" \"strings\" \"formatted\")\n    \n    ;; 利用`format`打印到屏幕上是非常简单的\n    ;;（译者注：注意到第二个参数是t，不同于刚刚的nil）；~% 代表换行符\n    (format t \"Common Lisp is groovy. Dude.~%\")\n    \n    \n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    ;; 2. 变量\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    ;; 你可以通过`defparameter`创建一个全局（动态）变量\n    ;; 变量名可以是除了：()[]{}\",'`;#|\\ 这些字符之外的其他任何字符\n    \n    ;; 动态变量名应该由*号开头与结尾！\n    ;; (译者注：这个只是一个习惯)\n    \n    (defparameter *some-var* 5)\n    *some-var* ; =\u003e 5\n    \n    ;; 你也可以使用Unicode字符：\n    (defparameter *AΛB* nil)\n    \n    \n    ;; 访问一个在之前从未被绑定的变量是一种不规范的行为（即使依然是可能发生的）；\n    ;; 不要尝试那样做。\n    \n    \n    ;; 局部绑定：在(let ...)语句内，'me'被绑定到\"dance with you\"上。\n    ;; `let`总是返回在其作用域内最后一个表达式的值\n    \n    (let ((me \"dance with you\"))\n      me)\n    ;; =\u003e \"dance with you\"\n    \n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    ;; 3. 结构体和集合\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    \n    ;; 结构体\n    (defstruct dog name breed age)\n    (defparameter *rover*\n        (make-dog :name \"rover\"\n                  :breed \"collie\"\n                  :age 5))\n    *rover* ; =\u003e #S(DOG :NAME \"rover\" :BREED \"collie\" :AGE 5)\n    \n    (dog-p *rover*) ; =\u003e t  ;; ewww)\n    (dog-name *rover*) ; =\u003e \"rover\"\n    \n    ;; Dog-p，make-dog，以及 dog-name都是由defstruct创建的！\n    \n    ;;; 点对单元(Pairs)\n    ;; `cons`可用于生成一个点对单元， 利用`car`以及`cdr`将分别得到第一个和第二个元素\n    (cons 'SUBJECT 'VERB) ; =\u003e '(SUBJECT . VERB)\n    (car (cons 'SUBJECT 'VERB)) ; =\u003e SUBJECT\n    (cdr (cons 'SUBJECT 'VERB)) ; =\u003e VERB\n    \n    ;;; 列表\n    \n    ;; 所有列表都是由点对单元构成的“链表”。它以'nil'（或者'()）作为列表的最后一个元素。\n    (cons 1 (cons 2 (cons 3 nil))) ; =\u003e '(1 2 3)\n    ;; `list`是一个生成列表的便利途径\n    (list 1 2 3) ; =\u003e '(1 2 3)\n    ;; 并且，一个引用也可被用做字面意义上的列表值\n    '(1 2 3) ; =\u003e '(1 2 3)\n    \n    ;; 同样的，依然可以用`cons`来添加一项到列表的起始位置\n    (cons 4 '(1 2 3)) ; =\u003e '(4 1 2 3)\n    \n    ;; 而`append`也可用于连接两个列表\n    (append '(1 2) '(3 4)) ; =\u003e '(1 2 3 4)\n    \n    ;; 或者使用`concatenate`\n    \n    (concatenate 'list '(1 2) '(3 4))\n    \n    ;; 列表是一种非常核心的数据类型，所以有非常多的处理列表的函数\n    ;; 例如：\n    (mapcar #'1+ '(1 2 3))             ; =\u003e '(2 3 4)\n    (mapcar #'+ '(1 2 3) '(10 20 30))  ; =\u003e '(11 22 33)\n    (remove-if-not #'evenp '(1 2 3 4)) ; =\u003e '(2 4)\n    (every #'evenp '(1 2 3 4))         ; =\u003e nil\n    (some #'oddp '(1 2 3 4))           ; =\u003e T\n    (butlast '(subject verb object))   ; =\u003e (SUBJECT VERB)\n    \n    \n    ;;; 向量\n    \n    ;; 向量的字面意义是一个定长数组\n    ;;（译者注：此处所谓“字面意义”，即指#(......)的形式，下文还会出现）\n    #(1 2 3) ; =\u003e #(1 2 3)\n    \n    ;; 使用`concatenate`来将两个向量首尾连接在一起\n    (concatenate 'vector #(1 2 3) #(4 5 6)) ; =\u003e #(1 2 3 4 5 6)\n    \n    ;;; 数组\n    \n    ;; 向量和字符串只不过是数组的特例\n    \n    ;; 二维数组\n    \n    (make-array (list 2 2))\n    \n    ;; (make-array '(2 2)) 也是可以的\n    \n    ; =\u003e #2A((0 0) (0 0))\n    \n    (make-array (list 2 2 2))\n    \n    ; =\u003e #3A(((0 0) (0 0)) ((0 0) (0 0)))\n    \n    ;; 注意：数组的默认初始值是可以指定的\n    ;; 下面是如何指定的示例：\n    \n    (make-array '(2) :initial-element 'unset)\n    \n    ; =\u003e #(UNSET UNSET)\n    \n    ;; 若想获取数组[1][1][1]上的元素：\n    (aref (make-array (list 2 2 2)) 1 1 1)\n    \n    ; =\u003e 0\n    \n    ;;; 变长向量\n    \n    ;; 若将变长向量打印出来，那么它的字面意义上的值和定长向量的是一样的\n    \n    (defparameter *adjvec* (make-array '(3) :initial-contents '(1 2 3)\n          :adjustable t :fill-pointer t))\n          \n    *adjvec* ; =\u003e #(1 2 3)\n    \n    ;; 添加新的元素:\n    (vector-push-extend 4 *adjvec*) ; =\u003e 3\n    \n    *adjvec* ; =\u003e #(1 2 3 4)\n    \n    \n    \n    ;;; 不怎么严谨地说，集合也可被视为列表\n    \n    (set-difference '(1 2 3 4) '(4 5 6 7)) ; =\u003e (3 2 1)\n    (intersection '(1 2 3 4) '(4 5 6 7)) ; =\u003e 4\n    (union '(1 2 3 4) '(4 5 6 7))        ; =\u003e (3 2 1 4 5 6 7)\n    (adjoin 4 '(1 2 3 4))     ; =\u003e (1 2 3 4)\n    \n    ;; 然而，你可能想使用一个更好的数据结构，而并非一个链表\n    \n    ;;; 在Common Lisp中，“字典”和哈希表的实现是一样的。\n    \n    ;; 创建一个哈希表\n    (defparameter *m* (make-hash-table))\n    \n    ;; 给定键，设置对应的值\n    (setf (gethash 'a *m*) 1)\n    \n    ;; （通过键）检索对应的值\n    (gethash 'a *m*) ; =\u003e 1, t\n    \n    ;; 注意此处有一细节：Common Lisp往往返回多个值。`gethash`返回的两个值是t，代表找到了这个元素；返回nil表示没有找到这个元素。\n    ;;（译者注：返回的第一个值表示给定的键所对应的值或者nil；）\n    ;;（第二个是一个布尔值，表示在哈希表中是否存在这个给定的键）\n    ;; 例如，如果可以找到给定的键所对应的值，则返回一个t，否则返回nil\n    \n    ;; 由给定的键检索一个不存在的值，则返回nil\n    ;;（译者注：这个nil是第一个nil，第二个nil其实是指该键在哈希表中也不存在）\n     (gethash 'd *m*) ;=\u003e nil, nil\n    \n    ;; 给定一个键，你可以指定其对应的默认值：\n    (gethash 'd *m* :not-found) ; =\u003e :NOT-FOUND\n    \n    ;; 在此，让我们看一看怎样处理`gethash`的多个返回值。\n    \n    (multiple-value-bind\n          (a b)\n        (gethash 'd *m*)\n      (list a b))\n    ; =\u003e (NIL NIL)\n    \n    (multiple-value-bind\n          (a b)\n        (gethash 'a *m*)\n      (list a b))\n    ; =\u003e (1 T)\n    \n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    ;; 3. 函数\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    \n    ;; 使用`lambda`来创建一个匿名函数。\n    ;; 一个函数总是返回其形式体内最后一个表达式的值。\n    ;; 将一个函数对象打印出来后的形式是多种多样的...\n    \n    (lambda () \"Hello World\") ; =\u003e #\u003cFUNCTION (LAMBDA ()) {1004E7818B}\u003e\n    \n    ;; 使用`funcall`来调用lambda函数\n    (funcall (lambda () \"Hello World\")) ; =\u003e \"Hello World\"\n    \n    ;; 或者使用`apply`\n    (apply (lambda () \"Hello World\") nil) ; =\u003e \"Hello World\"\n    \n    ;; 显式地定义一个函数（译者注：即非匿名的）\n    (defun hello-world ()\n       \"Hello World\")\n    (hello-world) ; =\u003e \"Hello World\"\n    \n    ;; 刚刚上面函数名\"hello-world\"后的()其实是函数的参数列表\n    (defun hello (name)\n       (format nil \"Hello, ~a \" name))\n    \n    (hello \"Steve\") ; =\u003e \"Hello, Steve\"\n    \n    ;; 函数可以有可选形参并且其默认值都为nil\n    \n    (defun hello (name \u0026optional from)\n        (if from\n            (format t \"Hello, ~a, from ~a\" name from)\n            (format t \"Hello, ~a\" name)))\n    \n     (hello \"Jim\" \"Alpacas\") ;; =\u003e Hello, Jim, from Alpacas\n    \n    ;; 你也可以指定那些可选形参的默认值\n    (defun hello (name \u0026optional (from \"The world\"))\n       (format t \"Hello, ~a, from ~a\" name from))\n    \n    (hello \"Steve\")\n    ; =\u003e Hello, Steve, from The world\n    \n    (hello \"Steve\" \"the alpacas\")\n    ; =\u003e Hello, Steve, from the alpacas\n    \n    \n    ;; 当然，你也可以设置所谓关键字形参；\n    ;; 关键字形参往往比可选形参更具灵活性。\n    \n    (defun generalized-greeter (name \u0026key (from \"the world\") (honorific \"Mx\"))\n        (format t \"Hello, ~a ~a, from ~a\" honorific name from))\n    \n    (generalized-greeter \"Jim\")   ; =\u003e Hello, Mx Jim, from the world\n    \n    (generalized-greeter \"Jim\" :from \"the alpacas you met last summer\" :honorific \"Mr\")\n    ; =\u003e Hello, Mr Jim, from the alpacas you met last summer\n    \n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    ;; 4. 等式\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    \n    ;; Common Lisp具有一个十分复杂的用于判断等价的系统，下面只是其中一部分的例子\n    \n    ;; 若要比较数值是否等价，使用`=`\n    (= 3 3.0) ; =\u003e t\n    (= 2 1) ; =\u003e nil\n    \n    ;; 若要比较对象的类型，则使用`eql`\n    ;;（译者注：抱歉，翻译水平实在有限，下面是我个人的补充说明）\n    ;;（`eq` 返回真，如果对象的内存地址相等）\n    ;;（`eql` 返回真，如果两个对象内存地址相等，或者对象的类型相同，并且值相等）\n    ;;（例如同为整形数或浮点数，并且他们的值相等时，二者`eql`等价）\n    ;;（想要弄清`eql`，其实有必要先了解`eq`)\n    ;;（[可以参考](http://stackoverflow.com/questions/547436/whats-the-difference-between-eq-eql-equal-and-equalp-in-common-lisp)）\n    ;;（可以去CLHS上分别查看两者的文档）\n    ;;（另外，《实用Common Lisp编程》的4.8节也提到了两者的区别）\n    (eql 3 3) ; =\u003e t\n    (eql 3 3.0) ; =\u003e nil\n    (eql (list 3) (list 3)) ; =\u003e nil\n    \n    ;; 对于列表、字符串、以及位向量，使用`equal`\n    (equal (list 'a 'b) (list 'a 'b)) ; =\u003e t\n    (equal (list 'a 'b) (list 'b 'a)) ; =\u003e nil\n    \n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    ;; 5. 控制流\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    \n    ;;; 条件判断语句\n    \n    (if t                ; “test”，即判断语句\n        \"this is true\"   ; “then”，即判断条件为真时求值的表达式\n        \"this is false\") ; “else”，即判断条件为假时求值的表达式\n    ; =\u003e \"this is true\"\n    \n    ;; 在“test”（判断）语句中，所有非nil或者非()的值都被视为真值\n    (member 'Groucho '(Harpo Groucho Zeppo)) ; =\u003e '(GROUCHO ZEPPO)\n    (if (member 'Groucho '(Harpo Groucho Zeppo))\n        'yep\n        'nope)\n    ; =\u003e 'YEP\n    \n    ;; `cond`将一系列测试语句串联起来，并对相应的表达式求值\n    (cond ((\u003e 2 2) (error \"wrong!\"))\n          ((\u003c 2 2) (error \"wrong again!\"))\n          (t 'ok)) ; =\u003e 'OK\n    \n    ;; 对于给定值的数据类型，`typecase`会做出相应地判断\n    (typecase 1\n      (string :string)\n      (integer :int))\n    \n    ; =\u003e :int\n    \n    ;;; 迭代\n    \n    ;; 当然，递归是肯定被支持的：\n    \n    (defun walker (n)\n      (if (zerop n)\n          :walked\n          (walker (1- n))))\n    \n    (walker) ; =\u003e :walked\n    \n    ;; 而大部分场合下，我们使用`DOLIST`或者`LOOP`来进行迭代\n    \n    \n    (dolist (i '(1 2 3 4))\n      (format t \"~a\" i))\n    \n    ; =\u003e 1234\n    \n    (loop for i from 0 below 10\n          collect i)\n    \n    ; =\u003e (0 1 2 3 4 5 6 7 8 9)\n    \n    \n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    ;; 6. 可变性\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    \n    ;; 使用`setf`可以对一个已经存在的变量进行赋值；\n    ;; 事实上，刚刚在哈希表的例子中我们已经示范过了。\n    \n    (let ((variable 10))\n        (setf variable 2))\n     ; =\u003e 2\n    \n    \n    ;; 所谓好的Lisp编码风格就是为了减少使用破坏性函数，防止发生副作用。\n    \n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    ;; 7. 类与对象\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    \n    ;; 我们就不写什么有关动物的类了，下面给出的人力车的类\n    \n    (defclass human-powered-conveyance ()\n      ((velocity\n        :accessor velocity\n        :initarg :velocity)\n       (average-efficiency\n        :accessor average-efficiency\n       :initarg :average-efficiency))\n      (:documentation \"A human powered conveyance\"))\n    \n    ;; `defclass`，后面接类名，以及超类列表\n    ;; 再接着是槽的列表（槽有点像Java里的成员变量），最后是一些可选的特性\n    ;; 例如文档说明“:documentation”\n    \n    ;; 如果超类列表为空，则默认该类继承于“standard-object”类（standard-object又是T的子类）\n    ;; 这种默认行为是可以改变的，但你最好有一定的基础并且知道自己到底在干什么；\n    ;; 参阅《The Art of the Metaobject Protocol》来了解更多信息。\n    \n    (defclass bicycle (human-powered-conveyance)\n      ((wheel-size\n        :accessor wheel-size\n        :initarg :wheel-size\n        :documentation \"Diameter of the wheel.\")\n       (height\n        :accessor height\n        :initarg :height)))\n    \n    (defclass recumbent (bicycle)\n      ((chain-type\n        :accessor chain-type\n        :initarg  :chain-type)))\n    \n    (defclass unicycle (human-powered-conveyance) nil)\n    \n    (defclass canoe (human-powered-conveyance)\n      ((number-of-rowers\n        :accessor number-of-rowers\n        :initarg :number-of-rowers)))\n    \n    \n    ;; 在REPL中对human-powered-conveyance类调用`DESCRIBE`后结果如下：\n    \n    (describe 'human-powered-conveyance)\n    \n    ; COMMON-LISP-USER::HUMAN-POWERED-CONVEYANCE\n    ;  [symbol]\n    ;\n    ; HUMAN-POWERED-CONVEYANCE names the standard-class #\u003cSTANDARD-CLASS\n    ;                                                    HUMAN-POWERED-CONVEYANCE\u003e:\n    ;  Documentation:\n    ;    A human powered conveyance\n    ;  Direct superclasses: STANDARD-OBJECT\n    ;  Direct subclasses: UNICYCLE, BICYCLE, CANOE\n    ;  Not yet finalized.\n    ;  Direct slots:\n    ;    VELOCITY\n    ;      Readers: VELOCITY\n    ;      Writers: (SETF VELOCITY)\n    ;    AVERAGE-EFFICIENCY\n    ;      Readers: AVERAGE-EFFICIENCY\n    ;      Writers: (SETF AVERAGE-EFFICIENCY)\n    \n    ;; 注意到这些有用的返回信息——Common Lisp一直是一个交互式的系统。\n    \n    ;; 若要定义一个方法；\n    ;; 注意，我们计算自行车轮子周长时使用了这样一个公式：C = d * pi\n    \n    (defmethod circumference ((object bicycle))\n      (* pi (wheel-size object)))\n    \n    ;; pi在Common Lisp中已经是一个内置的常量。\n    \n    ;; 假设我们已经知道了效率值（“efficiency value”）和船桨数大概呈对数关系；\n    ;; 那么效率值的定义应当在构造器/初始化过程中就被完成。\n    \n    ;; 下面是一个Common Lisp构造实例时初始化实例的例子：\n    \n    (defmethod initialize-instance :after ((object canoe) \u0026rest args)\n      (setf (average-efficiency object)  (log (1+ (number-of-rowers object)))))\n    \n    ;; 接着初构造一个实例并检查平均效率...\n    \n    (average-efficiency (make-instance 'canoe :number-of-rowers 15))\n    ; =\u003e 2.7725887\n    \n    \n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    ;; 8. 宏\n    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n    \n    ;; 宏可以让你扩展语法\n    \n    ;; 例如，Common Lisp并没有自带WHILE循环——所以让我们自己来为他添加一个；\n    ;; 如果按照汇编程序的直觉来看，我们会这样写：\n    \n    (defmacro while (condition \u0026body body)\n        \"While `condition` is true, `body` is executed.\n    \n    `condition` is tested prior to each execution of `body`\"\n        (let ((block-name (gensym)))\n            `(tagbody\n               (unless ,condition\n                   (go ,block-name))\n               (progn\n               ,@body)\n               ,block-name)))\n    \n    ;; 让我们来看看它的高级版本：\n    \n    (defmacro while (condition \u0026body body)\n        \"While `condition` is true, `body` is executed.\n    \n    `condition` is tested prior to each execution of `body`\"\n      `(loop while ,condition\n             do\n             (progn\n                ,@body)))\n    \n    ;; 然而，在一个比较现代化的编译环境下，这样的WHILE是没有必要的；\n    ;; LOOP形式的循环和这个WHILE同样的好，并且更易于阅读。\n    \n    ;; 注意反引号'`'，逗号','以及'@'这三个符号； \n    ;; 反引号'`'是一种所谓“quasiquote”的引用类型的运算符，有了它，之后的逗号“,”才有意义。\n    ;; 逗号“,”意味着解除引用（unquote，即开始求值）；\n    ;; “@”符号则表示将当前的参数插入到当前整个列表中。\n    ;;（译者注：要想真正用好、用对这三个符号，需要下一番功夫）\n    ;;（甚至光看《实用 Common Lisp 编程》中关于宏的介绍都是不够的）\n    ;;（建议再去读一读Paul Graham的两本著作《ANSI Common Lisp》和《On Lisp》）\n    \n    ;; 函数`gensym`创建一个唯一的符号——这个符号确保不会出现在其他任何地方。\n    ;; 这样做是因为，宏是在编译期展开的\n    ;; 而在宏中声明的变量名极有可能和常规代码中使用的变量名发生冲突。\n    \n    ;; 可以去《实用 Common Lisp 编程》中阅读更多有关宏的内容。\n","Tags":["common lisp"," learnxinyminutes"],"CreateTime":1414472144,"EditTime":1414472144,"UpdateTime":1414472144,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":80}