{"Id":58,"Title":"Simple-go","Slug":"2014-10-28-6","Text":"    \n    // 单行注释\n    /* 多行\n        注释 */\n    \n    // 导入包的子句在每个源文件的开头。\n    // Main比较特殊，它用来声明可执行文件，而不是一个库。\n    package main\n    \n    // Import语句声明了当前文件引用的包。\n    import (\n        \"fmt\"       // Go语言标准库中的包\n        \"net/http\"  // 一个web服务器包\n        \"strconv\"   // 字符串转换\n    )\n    \n    // 函数声明：Main是程序执行的入口。\n    // 不管你喜欢还是不喜欢，反正Go就用了花括号来包住函数体。\n    func main() {\n        // 往标准输出打印一行。\n        // 用包名fmt限制打印函数。\n        fmt.Println(\"Hello world!\")\n    \n        // 调用当前包的另一个函数。\n        beyondHello()\n    }\n    \n    // 函数可以在括号里加参数。\n    // 如果没有参数的话，也需要一个空括号。\n    func beyondHello() {\n        var x int   // 变量声明，变量必须在使用之前声明。\n        x = 3       // 变量赋值。\n        // 可以用:=来偷懒，它自动把变量类型、声明和赋值都搞定了。\n        y := 4\n        sum, prod := learnMultiple(x, y)        // 返回多个变量的函数\n        fmt.Println(\"sum:\", sum, \"prod:\", prod) // 简单输出\n        learnTypes()                            // 少于y分钟，学的更多！\n    }\n    \n    // 多变量和多返回值的函数\n    func learnMultiple(x, y int) (sum, prod int) {\n        return x + y, x * y // 返回两个值\n    }\n    \n    // 内置变量类型和关键词\n    func learnTypes() {\n        // 短声明给你所想。\n        s := \"Learn Go!\" // String类型\n    \n        s2 := `A \"raw\" string literal\n    can include line breaks.` // 同样是String类型\n        \n        // 非ascii字符。Go使用UTF-8编码。\n        g := 'Σ' // rune类型，int32的别名，使用UTF-8编码\n    \n        f := 3.14195 // float64类型，IEEE-754 64位浮点数\n        c := 3 + 4i  // complex128类型，内部使用两个float64表示\n    \n        // Var变量可以直接初始化。\n        var u uint = 7  // unsigned 无符号变量，但是实现依赖int型变量的长度\n        var pi float32 = 22. / 7\n    \n        // 字符转换\n        n := byte('\\n') // byte是uint8的别名\n    \n        // 数组类型编译的时候大小固定。\n        var a4 [4] int              // 有4个int变量的数组，初始为0\n        a3 := [...]int{3, 1, 5}     // 有3个int变量的数组，同时进行了初始化\n    \n        // Slice 可以动态的增删。Array和Slice各有千秋，但是使用slice的地方更多些。\n        s3 := []int{4, 5, 9}        // 和a3相比，这里没有省略号\n        s4 := make([]int, 4)        // 分配一个有4个int型变量的slice，全部被初始化为0\n    \n        var d2 [][]float64          // 声明而已，什么都没有分配\n        bs := []byte(\"a slice\")     // 类型转换的语法\n    \n        p, q := learnMemory()       // 声明p,q为int型变量的指针\n        fmt.Println(*p, *q)         // * 取值\n    \n        // Map是动态可增长关联数组，和其他语言中的hash或者字典相似。\n        m := map[string]int{\"three\": 3, \"four\": 4}\n        m[\"one\"] = 1\n    \n        // 在Go语言中未使用的变量在编译的时候会报错，而不是warning。\n        // 下划线 _ 可以使你“使用”一个变量，但是丢弃它的值。\n        _,_,_,_,_,_,_,_,_ = s2, g, f, u, pi, n, a3, s4, bs\n        // 输出变量\n        fmt.Println(s, c, a4, s3, d2, m)\n    \n        learnFlowControl() // 回到流程控制 \n    }\n    \n    // Go全面支持垃圾回收。Go有指针，但是不支持指针运算。\n    // 你会因为空指针而犯错，但是不会因为增加指针而犯错。\n    func learnMemory() (p, q *int) {\n        // 返回int型变量指针p和q\n        p = new(int)    // 内置函数new分配内存\n        // 自动将分配的int赋值0，p不再是空的了。\n        s := make([]int, 20)    // 给20个int变量分配一块内存\n        s[3] = 7                // 赋值\n        r := -2                 // 声明另一个局部变量\n        return \u0026s[3], \u0026r        // \u0026 取地址\n    }\n    \n    func expensiveComputation() int {\n        return 1e6\n    }\n    \n    func learnFlowControl() {\n        // If需要花括号，括号就免了\n        if true {\n            fmt.Println(\"told ya\")\n        }\n        // 用go fmt 命令可以帮你格式化代码，所以不用怕被人吐槽代码风格了，\n        // 也不用容忍被人的代码风格。\n        if false {\n            // pout\n        } else {\n            // gloat\n        }\n        // 如果太多嵌套的if语句，推荐使用switch\n        x := 1\n        switch x {\n        case 0:\n        case 1:\n            // 隐式调用break语句，匹配上一个即停止\n        case 2:\n            // 不会运行\n        }\n        // 和if一样，for也不用括号\n        for x := 0; x \u003c 3; x++ { // ++ 自增\n            fmt.Println(\"iteration\", x)\n        }\n        // x在这里还是1。为什么？\n    \n        // for 是go里唯一的循环关键字，不过它有很多变种\n        for { // 死循环\n            break    // 骗你的 \n            continue // 不会运行的\n        }\n        // 和for一样，if中的:=先给y赋值，然后再和x作比较。\n        if y := expensiveComputation(); y \u003e x {\n            x = y\n        }\n        // 闭包函数\n        xBig := func() bool {\n            return x \u003e 100 // x是上面声明的变量引用\n        }\n        fmt.Println(\"xBig:\", xBig()) // true （上面把y赋给x了） \n        x /= 1e5                     // x变成10\n        fmt.Println(\"xBig:\", xBig()) // 现在是false\n    \n        // 当你需要goto的时候，你会爱死它的！\n        goto love\n    love:\n    \n        learnInterfaces() // 好东西来了！\n    }\n    \n    // 定义Stringer为一个接口类型，有一个方法String\n    type Stringer interface {\n        String() string\n    }\n    \n    // 定义pair为一个结构体，有x和y两个int型变量。\n    type pair struct {\n        x, y int\n    }\n    \n    // 定义pair类型的方法，实现Stringer接口。\n    func (p pair) String() string { // p被叫做“接收器”\n        // Sprintf是fmt包中的另一个公有函数。\n        // 用 . 调用p中的元素。\n        return fmt.Sprintf(\"(%d, %d)\", p.x, p.y)\n    }\n    \n    func learnInterfaces() {\n        // 花括号用来定义结构体变量，:=在这里将一个结构体变量赋值给p。\n        p := pair{3, 4}\n        fmt.Println(p.String()) // 调用pair类型p的String方法 \n        var i Stringer          // 声明i为Stringer接口类型 \n        i = p                   // 有效！因为p实现了Stringer接口（类似java中的塑型） \n        // 调用i的String方法，输出和上面一样\n        fmt.Println(i.String())\n    \n        // fmt包中的Println函数向对象要它们的string输出，实现了String方法就可以这样使用了。\n        // （类似java中的序列化）\n        fmt.Println(p) // 输出和上面一样，自动调用String函数。\n        fmt.Println(i) // 输出和上面一样。\n    \n        learnErrorHandling()\n    }\n    \n    func learnErrorHandling() {\n        // \", ok\"用来判断有没有正常工作 \n        m := map[int]string{3: \"three\", 4: \"four\"}\n        if x, ok := m[1]; !ok { // ok 为false，因为m中没有1\n            fmt.Println(\"no one there\")\n        } else {\n            fmt.Print(x) // 如果x在map中的话，x就是那个值喽。\n        }\n        // 错误可不只是ok，它还可以给出关于问题的更多细节。\n        if _, err := strconv.Atoi(\"non-int\"); err != nil { // _ discards value\n            // 输出\"strconv.ParseInt: parsing \"non-int\": invalid syntax\"\n            fmt.Println(err)\n        }\n        // 待会再说接口吧。同时，\n        learnConcurrency()\n    }\n    \n    // c是channel类型，一个并发安全的通信对象。\n    func inc(i int, c chan int) {\n        c \u003c- i + 1 // \u003c-把右边的发送到左边的channel。\n    }\n    \n    // 我们将用inc函数来并发地增加一些数字。\n    func learnConcurrency() {\n        // 用make来声明一个slice，make会分配和初始化slice，map和channel。\n        c := make(chan int)\n        // 用go关键字开始三个并发的goroutine，如果机器支持的话，还可能是并行执行。\n        // 三个都被发送到同一个channel。\n        go inc(0, c) // go is a statement that starts a new goroutine.\n        go inc(10, c)\n        go inc(-805, c)\n        // 从channel中独处结果并打印。\n        // 打印出什么东西是不可预知的。\n        fmt.Println(\u003c-c, \u003c-c, \u003c-c) // channel在右边的时候，\u003c-是读操作。\n    \n        cs := make(chan string)       // 操作string的channel\n        cc := make(chan chan string)  // 操作channel的channel\n        go func() { c \u003c- 84 }()       // 开始一个goroutine来发送一个新的数字 \n        go func() { cs \u003c- \"wordy\" }() // 发送给cs\n        // Select类似于switch，但是每个case包括一个channel操作。\n        // 它随机选择一个准备好通讯的case。\n        select {\n        case i := \u003c-c: // 从channel接收的值可以赋给其他变量\n            fmt.Println(\"it's a\", i)\n        case \u003c-cs: // 或者直接丢弃\n            fmt.Println(\"it's a string\")\n        case \u003c-cc: // 空的，还没作好通讯的准备 \n            fmt.Println(\"didn't happen.\")\n        }\n        // 上面c或者cs的值被取到，其中一个goroutine结束，另外一个一直阻塞。\n    \n        learnWebProgramming() // Go很适合web编程，我知道你也想学！\n    }\n    \n    // http包中的一个简单的函数就可以开启web服务器。\n    func learnWebProgramming() {\n        // ListenAndServe第一个参数指定了监听端口，第二个参数是一个接口，特定是http.Handler。\n        err := http.ListenAndServe(\":8080\", pair{})\n        fmt.Println(err) // 不要无视错误。\n    }\n    \n    // 使pair实现http.Handler接口的ServeHTTP方法。\n    func (p pair) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n        // 使用http.ResponseWriter返回数据\n        w.Write([]byte(\"You learned Go in Y minutes!\"))\n    }\n","Tags":["learnxinyminutes"," golang"],"CreateTime":1414472325,"EditTime":1414472325,"UpdateTime":1414472325,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":265}