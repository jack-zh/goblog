{"Id":246,"Title":"Python的优雅技巧(不断添加)","Slug":"2015-10-30-1","Text":"\u003cdiv id=\"ztoc\"\u003e\u003c/div\u003e\n\n## 枚举\n\n不要这么做：\n\n\ti = 0 \n\tfor item in iterable: \n\t    print i, item \n\t    i += 1\n\n而是这样：\n\n\tfor i, item in enumerate(iterable):    \n\t    print i, item\n\nEnumerate可以接受第二个参数，例如：\n\n\t\u003e\u003e\u003e list(enumerate('abc')) \n\t[(0, 'a'), (1, 'b'), (2, 'c')]\n\t\u003e\u003e\u003e list(enumerate('abc', 1)) \n\t[(1, 'a'), (2, 'b'), (3, 'c')]\n\n## 字典/集合 解析\n\n你可能知道列表解析，但不知道字典/集合解析。字典/集合解析简单而且高效，例如：\n\n\tmy_dict = {i: i * i for i in xrange(100)} \n\tmy_set = {i * 15 for i in xrange(100)}\n\n\t#There is only a difference of ':' in both\n\n## 浮点数除法\n\n如果我们除以一个整数，即使结果是一个浮点数，Python（2） 依旧会给我们一个整数。为了规避这个问题，我们需要这样做：\n\n\tresult = 1.0/2\n\n但是现在有一种别的方法可以解决这个问题，甚至在之前我都没有意识到有这种方法存在。你可以进行如下操作：\n\n\tfrom __future__ import division \n\tresult = 1/2\n\n\t#print(result)\n\t#0.5\n\n需要注意的是这个窍门只适用于Python 2。在Python 3 中就不需要进行import 操作了，因为它已经默认进行import了。\n\n## 简单的服务器\n\n你想快速简单的分享目录下的文件吗？可以这样做：\n\n\t#Python2\n\tpython -m SimpleHTTPServer\n\n\t#Python 3\n\tpython3 -m http.server\n\n这回启动一个服务器\n\n## Python表达式求值\n\n我们都知道`eval`,但也许并不是所有人都知道`literal_eval`.可以这么做：\n\n\timport ast \n\tmy_list = ast.literal_eval(expr)\n\n而不是这样：\n\n\texpr = \"[1, 2, 3]\" \n\tmy_list = eval(expr)\n\n我相信对于大多数人来说这种形式是第一次看见，但是实际上这个在Python中已经存在很长时间了。\n\n## 分析脚本\n\n按下面的方式运行脚本，可以很简单的对其进行分析：\n\n\tpython -m cProfile my_script.py\n\n## 对象自检\n\n在Python中，可以通过dir()来检查对象，例如：\n\n\t\u003e\u003e\u003e foo = [1, 2, 3, 4]\n\t\u003e\u003e\u003e dir(foo) \n\t['__add__', '__class__', '__contains__', \n\t'__delattr__', '__delitem__', '__delslice__', ... , \n\t'extend', 'index', 'insert', 'pop', 'remove', \n\t'reverse', 'sort']\n\n## 调试脚本\n\n你可以使用pdb模块在脚本中设置断点来调试脚本，就像这样：\n\n\timport pdb\n\tpdb.set_trace()\n\n你可以在脚本的任何地方加入`pdb.set_trace()`，该函数会在那个位置设置一个断点。超级方便。你应该多阅读pdb 函数的相关内容，因为在它里面还有很多鲜为人知的功能。\n\n## 简化if结构\n\n如果必须检查一些值，可以用\n\n\tif n in [1,4,5,6]:\n\n而不是用复杂的if结构：\n\n\tif n==1 or n==4 or n==5 or n==6:\n\n## 字符串/数列 逆序\n\n下面的方式可以快速反转一个列表：\n\n\t\u003e\u003e\u003e a = [1,2,3,4]\n\t\u003e\u003e\u003e a[::-1]\n\t[4, 3, 2, 1]\n\n\t#This creates a new reversed list. \n\t#If you want to reverse a list in place you can do:\n\n\ta.reverse()\n\n这种方式同样适用于字符串：\n\n\t\u003e\u003e\u003e foo = \"yasoob\"\n\t\u003e\u003e\u003e foo[::-1]\n\t'boosay'\n\n## 优雅地打印\n\n下面的方式可以用优雅的方式打印字典和列表：\n\n\tfrom pprint import pprint \n\tpprint(my_dict)\n\n这用于字典打印是非常高效的，如果你想从文件中快速优雅的打印出json，可以这样做：\n\n\tcat file.json | python -m json.tools\n\n## 三元运算\n\n三元运算是if-else 语句的快捷操作，也被称为条件运算。这里有几个例子可以供你参考:\n\n\t[on_true] if [expression] else [on_false]\n\tx, y = 50, 25\n\tsmall = x if x \u003c y else y\n\n## 优化算法时间复杂度\n\n算法的时间复杂度对程序的执行效率影响最大，在Python中可以通过选择合适的数据结构来优化时间复杂度，如list和set查找某一个元素的时间复杂度分别是O(n)和O(1)。不同的场景有不同的优化方式，总得来说，一般有分治，分支界限，贪心，动态规划等思想。\n\n## 减少冗余数据\n\n如用上三角或下三角的方式去保存一个大的对称矩阵。在0元素占大多数的矩阵里使用稀疏矩阵表示。\n\n## 合理使用copy与deepcopy\n\n对于dict和list等数据结构的对象，直接赋值使用的是引用的方式。而有些情况下需要复制整个对象，这时可以使用copy包里的copy和deepcopy，这两个函数的不同之处在于后者是递归复制的。效率也不一样：（以下程序在ipython中运行）\n\n    import copy\n    a = range(100000)\n    %timeit -n 10 copy.copy(a) # 运行10次 copy.copy(a)\n    %timeit -n 10 copy.deepcopy(a)\n    10 loops, best of 3: 1.55 ms per loop\n    10 loops, best of 3: 151 ms per loop\n\ntimeit后面的-n表示运行的次数，后两行对应的是两个timeit的输出，下同。由此可见后者慢一个数量级。\n\n\n## 使用dict或set查找元素\n\npython dict和set都是使用hash表来实现(类似c++11标准库中unordered_map)，查找元素的时间复杂度是O(1)\n\n    a = range(1000)\n    s = set(a)\n    d = dict((i,1) for i in a)\n    %timeit -n 10000 100 in d\n    %timeit -n 10000 100 in s\n    10000 loops, best of 3: 43.5 ns per loop\n    10000 loops, best of 3: 49.6 ns per loop\n\ndict`的效率略高(占用的空间也多一些)。\n\n\n## 合理使用生成器（generator）和yield\n\n    %timeit -n 100 a = (i for i in range(100000))\n    %timeit -n 100 b = [i for i in range(100000)]\n    100 loops, best of 3: 1.54 ms per loop\n    100 loops, best of 3: 4.56 ms per loop\n\n使用`()`得到的是一个generator对象，所需要的内存空间与列表的大小无关，所以效率会高一些。在具体应用上，比如set(i for i in range(100000))会比set([i for i in range(100000)])快。\n\n但是对于需要循环遍历的情况：\n\n    %timeit -n 10 for x in (i for i in range(100000)): pass\n    %timeit -n 10 for x in [i for i in range(100000)]: pass\n    10 loops, best of 3: 6.51 ms per loop\n    10 loops, best of 3: 5.54 ms per loop\n\n后者的效率反而更高，但是如果循环里有break,用generator的好处是显而易见的。`yield`也是用于创建generator：\n\n    def yield_func(ls):\n        for i in ls:\n            yield i+1\n\n    def not_yield_func(ls):\n        return [i+1 for i in ls]\n\n    ls = range(1000000)\n    %timeit -n 10 for i in yield_func(ls):pass\n    %timeit -n 10 for i in not_yield_func(ls):pass\n    10 loops, best of 3: 63.8 ms per loop\n    10 loops, best of 3: 62.9 ms per loop\n\n对于内存不是非常大的list，可以直接返回一个list，但是可读性`yield`更佳(人个喜好)。\n\npython2.x内置generator功能的有xrange函数、itertools包等。\n\n\n## 优化循环\n\n循环之外能做的事不要放在循环内，比如下面的优化可以快一倍：\n\n    a = range(10000)\n    size_a = len(a)\n    %timeit -n 1000 for i in a: k = len(a)\n    %timeit -n 1000 for i in a: k = size_a\n    1000 loops, best of 3: 569 µs per loop\n    1000 loops, best of 3: 256 µs per loop\n\n## 优化包含多个判断表达式的顺序\n\n对于and，应该把满足条件少的放在前面，对于or，把满足条件多的放在前面。如：\n\n    a = range(2000)  \n    %timeit -n 100 [i for i in a if 10 \u0026lt; i \u0026lt; 20 or 1000 \u0026lt; i \u0026lt; 2000]\n    %timeit -n 100 [i for i in a if 1000 \u0026lt; i \u0026lt; 2000 or 100 \u0026lt; i \u0026lt; 20]     \n    %timeit -n 100 [i for i in a if i % 2 == 0 and i \u0026gt; 1900]\n    %timeit -n 100 [i for i in a if i \u0026gt; 1900 and i % 2 == 0]\n    100 loops, best of 3: 287 µs per loop\n    100 loops, best of 3: 214 µs per loop\n    100 loops, best of 3: 128 µs per loop\n    100 loops, best of 3: 56.1 µs per loop\n\n## 使用join合并迭代器中的字符串\n\n    In [1]: %%timeit\n       ...: s = ''\n       ...: for i in a:\n       ...:         s += i\n       ...:\n    10000 loops, best of 3: 59.8 µs per loop\n\n    In [2]: %%timeit\n    s = ''.join(a)\n       ...:\n    100000 loops, best of 3: 11.8 µs per loop\n\n`join`对于累加的方式，有大约5倍的提升。\n\n## 选择合适的格式化字符方式\n\n    s1, s2 = 'ax', 'bx'\n    %timeit -n 100000 'abc%s%s' % (s1, s2)\n    %timeit -n 100000 'abc{0}{1}'.format(s1, s2)\n    %timeit -n 100000 'abc' + s1 + s2\n    100000 loops, best of 3: 183 ns per loop\n    100000 loops, best of 3: 169 ns per loop\n    100000 loops, best of 3: 103 ns per loop\n\n三种情况中，`%`的方式是最慢的，但是三者的差距并不大（都非常快）。(个人觉得`%`的可读性最好)\n\n\n## 不借助中间变量交换两个变量的值\n\n    In [3]: %%timeit -n 10000\n        a,b=1,2\n       ....: c=a;a=b;b=c;\n       ....:\n    10000 loops, best of 3: 172 ns per loop\n\n    In [4]: %%timeit -n 10000\n    a,b=1,2\n    a,b=b,a\n       ....:\n    10000 loops, best of 3: 86 ns per loop\n\n使用`a,b=b,a`而不是`c=a;a=b;b=c;`来交换a,b的值，可以快1倍以上。\n\n\n## 使用`if is`\n\n    a = range(10000)\n    %timeit -n 100 [i for i in a if i == True]\n    %timeit -n 100 [i for i in a if i is True]\n    100 loops, best of 3: 531 µs per loop\n    100 loops, best of 3: 362 µs per loop\n\n使用 `if is True` 比 `if == True` 将近快一倍。\n\n\n## 使用级联比较`x \u0026lt; y \u0026lt; z`\n\n    x, y, z = 1,2,3\n    %timeit -n 1000000 if x \u0026lt; y \u0026lt; z:pass\n    %timeit -n 1000000 if x \u0026lt; y and y \u0026lt; z:pass\n    1000000 loops, best of 3: 101 ns per loop\n    1000000 loops, best of 3: 121 ns per loop\n\n`x \u003e y \u003e z`效率略高，而且可读性更好。\n\n\n##    `while 1` 比 `while True` 更快\n\n    def while_1():\n        n = 100000\n        while 1:\n            n -= 1\n            if n \u0026lt;= 0: break\n    def while_true():\n        n = 100000\n        while True:\n            n -= 1\n            if n \u0026lt;= 0: break    \n\n    m, n = 1000000, 1000000 \n    %timeit -n 100 while_1()\n    %timeit -n 100 while_true()\n    100 loops, best of 3: 3.69 ms per loop\n    100 loops, best of 3: 5.61 ms per loop\n\nwhile 1 比 while true快很多，原因是在python2.x中，True是一个全局变量，而非关键字。\n\n\n## 使用`**`而不是pow\n\n    %timeit -n 10000 c = pow(2,20)\n    %timeit -n 10000 c = 2**20\n    10000 loops, best of 3: 284 ns per loop\n    10000 loops, best of 3: 16.9 ns per loop\n\n `**`就是快10倍以上！\n\n\n    ## 使用 cProfile, cStringIO 和 cPickle等用c实现相同功能（分别对应profile, StringIO, pickle）的包\n\n    import cPickle\n    import pickle\n    a = range(10000)\n    %timeit -n 100 x = cPickle.dumps(a)\n    %timeit -n 100 x = pickle.dumps(a)\n    100 loops, best of 3: 1.58 ms per loop\n    100 loops, best of 3: 17 ms per loop\n\n由c实现的包，速度快10倍以上！\n\n## 使用最佳的反序列化方式\n\n下面比较了eval, cPickle, json方式三种对相应字符串反序列化的效率：\n\n    import json\n    import cPickle\n    a = range(10000)\n    s1 = str(a)\n    s2 = cPickle.dumps(a)\n    s3 = json.dumps(a)\n    %timeit -n 100 x = eval(s1)\n    %timeit -n 100 x = cPickle.loads(s2)\n    %timeit -n 100 x = json.loads(s3)\n    100 loops, best of 3: 16.8 ms per loop\n    100 loops, best of 3: 2.02 ms per loop\n    100 loops, best of 3: 798 µs per loop\n\n可见json比cPickle快近3倍，比eval快20多倍。\n\n## 使用C扩展(Extension)\n\n目前主要有CPython(python最常见的实现的方式)原生API, ctypes,Cython，cffi三种方式，它们的作用是使得Python程序可以调用由C编译成的动态链接库，其特点分别是：\n\n**CPython原生API**: 通过引入`Python.h`头文件，对应的C程序中可以直接使用Python的数据结构。实现过程相对繁琐，但是有比较大的适用范围。\n\n**ctypes**: 通常用于封装(wrap)C程序，让纯Python程序调用动态链接库（Windows中的dll或Unix中的so文件）中的函数。如果想要在python中使用已经有C类库，使用ctypes是很好的选择，有一些基准测试下，python2+ctypes是性能最好的方式。\n\n**Cython**: Cython是CPython的超集，用于简化编写C扩展的过程。Cython的优点是语法简洁，可以很好地兼容numpy等包含大量C扩展的库。Cython的使得场景一般是针对项目中某个算法或过程的优化。在[某些测试](http://docs.cython.org/src/tutorial/numpy.html)中，可以有几百倍的性能提升。\n\n**cffi**: cffi的就是ctypes在pypy（详见下文）中的实现，同进也兼容CPython。cffi提供了在python使用C类库的方式，可以直接在python代码中编写C代码，同时支持链接到已有的C类库。\n\n使用这些优化方式一般是针对已有项目性能瓶颈模块的优化，可以在少量改动原有项目的情况下大幅度地提高整个程序的运行效率。\n\n## 并行编程\n\n因为GIL的存在，Python很难充分利用多核CPU的优势。但是，可以通过内置的模块multiprocessing实现下面几种并行模式：\n\n**多进程**：对于CPU密集型的程序，可以使用multiprocessing的Process,Pool等封装好的类，通过多进程的方式实现并行计算。但是因为进程中的通信成本比较大，对于进程之间需要大量数据交互的程序效率未必有大的提高。\n\n**多线程**：对于IO密集型的程序，multiprocessing.dummy模块使用multiprocessing的接口封装threading，使得多线程编程也变得非常轻松(比如可以使用Pool的map接口，简洁高效)。\n\n**分布式**：multiprocessing中的Managers类提供了可以在不同进程之共享数据的方式，可以在此基础上开发出分布式的程序。\n\n不同的业务场景可以选择其中的一种或几种的组合实现程序性能的优化。\n\n## 终级大杀器：PyPy\n\nPyPy是用RPython(CPython的子集)实现的Python，根据官网的基准测试数据，它比CPython实现的Python要快6倍以上。快的原因是使用了Just-in-Time(JIT)编译器，即动态编译器，与静态编译器(如gcc,javac等)不同，它是利用程序运行的过程的数据进行优化。由于历史原因，目前pypy中还保留着GIL，不过正在进行的STM项目试图将PyPy变成没有GIL的Python。\n\n如果python程序中含有C扩展(非cffi的方式)，JIT的优化效果会大打折扣，甚至比CPython慢（比Numpy）。所以在PyPy中最好用纯Python或使用cffi扩展。\n\n随着STM，Numpy等项目的完善，相信PyPy将会替代CPython。\n\n## 使用性能分析工具\n\n除了上面在ipython使用到的timeit模块，还有cProfile。cProfile的使用方式也非常简单： `python -m cProfile filename.py`，`filename.py` 是要运行程序的文件名，可以在标准输出中看到每一个函数被调用的次数和运行的时间，从而找到程序的性能瓶颈，然后可以有针对性地优化。","Tags":["Python"],"CreateTime":1446194300,"EditTime":1469180517,"UpdateTime":1446194300,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[{"Id":3,"Author":"xiaotie","Email":"sayxiaotei@163.com","Url":"http://www.163.com/1111","Avatar":"http://1.gravatar.com/avatar/b5f8650d58f177baf55ff1bb11b4ad98?s=50","Content":"flask框架吗","CreateTime":1456582654,"Cid":246,"Pid":0,"Status":"approved","Ip":"222.71.165.188","UserAgent":"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36","IsAdmin":false},{"Id":4,"Author":"jack.zh","Email":"zzh.coder@qq.com","Url":"http://www.link-pub.cn","Avatar":"http://1.gravatar.com/avatar/af7b33d280e5f9372ebb9c9095af3118?s=50","Content":"你是指什么？","CreateTime":1456812648,"Cid":246,"Pid":3,"Status":"approved","Ip":"119.97.214.138","UserAgent":"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36","IsAdmin":true},{"Id":11,"Author":"xiaotie","Email":"123123@1231.com","Url":"http://www.baidu.com","Avatar":"http://1.gravatar.com/avatar/abfb602fb8e4830a4388a9e4f8e71227?s=50","Content":"你的这个web是flask开发的吗","CreateTime":1456992350,"Cid":246,"Pid":0,"Status":"approved","Ip":"140.207.16.210","UserAgent":"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.106 Safari/537.36","IsAdmin":false},{"Id":12,"Author":"jack.zh","Email":"zzh.coder@qq.com","Url":"http://www.link-pub.cn","Avatar":"http://1.gravatar.com/avatar/af7b33d280e5f9372ebb9c9095af3118?s=50","Content":"不是，Golang开发的","CreateTime":1457313424,"Cid":246,"Pid":11,"Status":"approved","Ip":"119.97.214.138","UserAgent":"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/48.0.2564.116 Safari/537.36","IsAdmin":true}],"Hits":1808}