{"Id":50,"Title":"Simple-Lua","Slug":"2014-10-28-2","Text":"    -- 单行注释以两个连字符开头 \n    \n    --[[ \n         多行注释\n    --]]\n    \n    ---------------------------------------------------- \n    -- 1. 变量和流程控制\n    ---------------------------------------------------- \n    \n    num = 42  -- 所有的数字都是双精度浮点型。\n    -- 别害怕，64位的双精度浮点型数字中有52位用于 \n    -- 保存精确的整型值; 对于52位以内的整型值， \n    -- 不用担心精度问题。\n    \n    s = 'walternate'  -- 和Python一样，字符串不可变。 \n    t = \"也可以用双引号\" \n    u = [[ 多行的字符串\n           以两个方括号\n           开始和结尾。]] \n    t = nil  -- 撤销t的定义; Lua 支持垃圾回收。 \n    \n    -- 块使用do/end之类的关键字标识： \n    while num \u003c 50 do \n      num = num + 1  -- 不支持 ++ 或 += 运算符。 \n    end \n    \n    -- If语句： \n    if num \u003e 40 then \n      print('over 40') \n    elseif s ~= 'walternate' then  -- ~= 表示不等于。 \n      -- 像Python一样，用 == 检查是否相等 ；字符串同样适用。 \n      io.write('not over 40\\n')  -- 默认标准输出。\n    else \n      -- 默认全局变量。 \n      thisIsGlobal = 5  -- 通常使用驼峰。\n    \n      -- 如何定义局部变量： \n      local line = io.read()  -- 读取标准输入的下一行。 \n    \n      -- ..操作符用于连接字符串： \n      print('Winter is coming, ' .. line) \n    end \n    \n    -- 未定义的变量返回nil。 \n    -- 这不是错误： \n    foo = anUnknownVariable  -- 现在 foo = nil. \n    \n    aBoolValue = false \n    \n    --只有nil和false为假; 0和 ''都均为真！ \n    if not aBoolValue then print('twas false') end \n    \n    -- 'or'和 'and'短路 \n    -- 类似于C/js里的 a?b:c 操作符： \n    ans = aBoolValue and 'yes' or 'no'  --\u003e 'no' \n    \n    karlSum = 0 \n    for i = 1, 100 do  -- 范围包含两端 \n      karlSum = karlSum + i \n    end \n    \n    -- 使用 \"100, 1, -1\" 表示递减的范围： \n    fredSum = 0 \n    for j = 100, 1, -1 do fredSum = fredSum + j end \n    \n    -- 通常，范围表达式为begin, end[, step]. \n    \n    -- 循环的另一种结构： \n    repeat \n      print('the way of the future') \n      num = num - 1 \n    until num == 0 \n    \n    ---------------------------------------------------- \n    -- 2. 函数。 \n    ---------------------------------------------------- \n    \n    function fib(n) \n      if n \u003c 2 then return 1 end \n      return fib(n - 2) + fib(n - 1) \n    end \n    \n    -- 支持闭包及匿名函数： \n    function adder(x) \n      -- 调用adder时，会创建返回的函数，\n      -- 并且会记住x的值： \n      return function (y) return x + y end \n    end \n    a1 = adder(9) \n    a2 = adder(36) \n    print(a1(16))  --\u003e 25 \n    print(a2(64))  --\u003e 100 \n    \n    -- 返回值、函数调用和赋值都可以\n    -- 使用长度不匹配的list。 \n    -- 不匹配的接收方会被赋值nil； \n    -- 不匹配的发送方会被丢弃。 \n    \n    x, y, z = 1, 2, 3, 4 \n    -- x = 1、y = 2、z = 3, 而 4 会被丢弃。 \n    \n    function bar(a, b, c) \n      print(a, b, c) \n      return 4, 8, 15, 16, 23, 42 \n    end \n    \n    x, y = bar('zaphod')  --\u003e 打印 \"zaphod  nil nil\" \n    -- 现在 x = 4, y = 8, 而值15..42被丢弃。 \n    \n    -- 函数是一等公民，可以是局部的，也可以是全局的。 \n    -- 以下表达式等价： \n    function f(x) return x * x end \n    f = function (x) return x * x end \n    \n    -- 这些也是等价的： \n    local function g(x) return math.sin(x) end \n    local g; g  = function (x) return math.sin(x) end \n    -- 'local g'使得g可以自引用。 \n    \n    -- 顺便提下，三角函数以弧度为单位。 \n    \n    -- 用一个字符串参数调用函数，可以省略括号： \n    print 'hello'  --可以工作。 \n    \n    -- 调用函数时，如果只有一个table参数，\n    -- 同样可以省略括号（table详情见下）：\n    print {} -- 一样可以工作。\n    \n    ---------------------------------------------------- \n    -- 3. Table。 \n    ---------------------------------------------------- \n    \n    -- Table = Lua唯一的组合数据结构; \n    --         它们是关联数组。 \n    -- 类似于PHP的数组或者js的对象， \n    -- 它们是哈希表或者字典，也可以当初列表使用。 \n    \n    -- 按字典/map的方式使用Table： \n    \n    -- Dict字面量默认使用字符串类型的key： \n    t = {key1 = 'value1', key2 = false} \n    \n    -- 字符串key可以使用类似js的点标记： \n    print(t.key1)  -- 打印 'value1'. \n    t.newKey = {}  -- 添加新的键值对。 \n    t.key2 = nil   -- 从table删除 key2。 \n    \n    -- 使用任何非nil的值作为key： \n    u = {['@!#'] = 'qbert', [{}] = 1729, [6.28] = 'tau'} \n    print(u[6.28])  -- 打印 \"tau\" \n    \n    -- 数字和字符串的key按值匹配的\n    -- table按id匹配。 \n    a = u['@!#']  -- 现在 a = 'qbert'. \n    b = u[{}]     -- 我们或许期待的是 1729,  但是得到的是nil: \n    -- b = nil ，因为没有找到。 \n    -- 之所以没找到，是因为我们用的key与保存数据时用的不是同\n    -- 一个对象。 \n    -- 所以字符串和数字是移植性更好的key。 \n    \n    -- 只需要一个table参数的函数调用不需要括号： \n    function h(x) print(x.key1) end \n    h{key1 = 'Sonmi~451'}  -- 打印'Sonmi~451'. \n    \n    for key, val in pairs(u) do  -- 遍历Table\n      print(key, val) \n    end \n    \n    -- _G 是一个特殊的table，用于保存所有的全局变量 \n    print(_G['_G'] == _G)  -- 打印'true'. \n    \n    -- 按列表/数组的方式使用： \n    \n    -- 列表字面量隐式添加整数键： \n    v = {'value1', 'value2', 1.21, 'gigawatts'} \n    for i = 1, #v do  -- #v 是列表的大小\n      print(v[i])  -- 索引从 1 开始!! 太疯狂了！ \n    end\n    -- 'list'并非真正的类型，v 其实是一个table， \n    -- 只不过它用连续的整数作为key，可以像list那样去使用。 \n    \n    ---------------------------------------------------- \n    -- 3.1 元表（metatable） 和元方法（metamethod）。 \n    ---------------------------------------------------- \n    \n    -- table的元表提供了一种机制，支持类似操作符重载的行为。\n    -- 稍后我们会看到元表如何支持类似js prototype的行为。 \n    \n    f1 = {a = 1, b = 2}  -- 表示一个分数 a/b. \n    f2 = {a = 2, b = 3} \n    \n    -- 这会失败：\n    -- s = f1 + f2 \n    \n    metafraction = {} \n    function metafraction.__add(f1, f2) \n      sum = {} \n      sum.b = f1.b * f2.b \n      sum.a = f1.a * f2.b + f2.a * f1.b \n      return sum\n    end\n    \n    setmetatable(f1, metafraction) \n    setmetatable(f2, metafraction) \n    \n    s = f1 + f2  -- 调用在f1的元表上的__add(f1, f2) 方法 \n    \n    -- f1, f2 没有关于元表的key，这点和js的prototype不一样。 \n    -- 因此你必须用getmetatable(f1)获取元表。\n    -- 元表是一个普通的table， \n    -- 元表的key是普通的Lua中的key，例如__add。 \n    \n    -- 但是下面一行代码会失败，因为s没有元表： \n    -- t = s + s \n    -- 下面提供的与类相似的模式可以解决这个问题： \n    \n    -- 元表的__index 可以重载用于查找的点操作符： \n    defaultFavs = {animal = 'gru', food = 'donuts'} \n    myFavs = {food = 'pizza'} \n    setmetatable(myFavs, {__index = defaultFavs}) \n    eatenBy = myFavs.animal  -- 可以工作！感谢元表 \n    \n    -- 如果在table中直接查找key失败，会使用\n    -- 元表的__index 递归地重试。\n    \n    -- __index的值也可以是function(tbl, key)\n    -- 这样可以支持自定义查找。 \n    \n    -- __index、__add等的值，被称为元方法。 \n    -- 这里是一个table元方法的清单： \n    \n    -- __add(a, b)                     for a + b \n    -- __sub(a, b)                     for a - b \n    -- __mul(a, b)                     for a * b \n    -- __div(a, b)                     for a / b \n    -- __mod(a, b)                     for a % b \n    -- __pow(a, b)                     for a ^ b \n    -- __unm(a)                        for -a \n    -- __concat(a, b)                  for a .. b \n    -- __len(a)                        for #a \n    -- __eq(a, b)                      for a == b \n    -- __lt(a, b)                      for a \u003c b \n    -- __le(a, b)                      for a \u003c= b \n    -- __index(a, b)  \u003cfn or a table\u003e  for a.b \n    -- __newindex(a, b, c)             for a.b = c \n    -- __call(a, ...)                  for a(...) \n    \n    ---------------------------------------------------- \n    -- 3.2 与类相似的table和继承。 \n    ---------------------------------------------------- \n    \n    -- Lua没有内建的类；可以通过不同的方法，利用表和元表\n    -- 来实现类。 \n    \n    -- 下面是一个例子，解释在后面： \n    \n    Dog = {}                                   -- 1. \n    \n    function Dog:new()                         -- 2. \n      newObj = {sound = 'woof'}                -- 3. \n      self.__index = self                      -- 4. \n      return setmetatable(newObj, self)        -- 5. \n    end \n    \n    function Dog:makeSound()                   -- 6. \n      print('I say ' .. self.sound) \n    end \n    \n    mrDog = Dog:new()                          -- 7. \n    mrDog:makeSound()  -- 'I say woof'         -- 8. \n    \n    -- 1. Dog看上去像一个类；其实它是一个table。 \n    -- 2. 函数tablename:fn(...) 等价于\n    --    函数tablename.fn(self, ...)\n    --    冒号（:）只是添加了self作为第一个参数。 \n    --    阅读7 \u0026 8条 了解self变量是如何得到其值的。 \n    -- 3. newObj是类Dog的一个实例。 \n    -- 4. self = 被继承的类。通常self = Dog，不过继承可以改变它。 \n    --    如果把newObj的元表和__index都设置为self， \n    --    newObj就可以得到self的函数。 \n    -- 5. 备忘：setmetatable返回其第一个参数。 \n    -- 6. 冒号（：）的作用和第2条一样，不过这里 \n    --    self是一个实例，而不是类 \n    -- 7. 等价于Dog.new(Dog)，所以在new()中，self = Dog。 \n    -- 8. 等价于mrDog.makeSound(mrDog); self = mrDog。 \n    \n    ---------------------------------------------------- \n    \n    -- 继承的例子： \n    \n    LoudDog = Dog:new()                           -- 1. \n    \n    function LoudDog:makeSound() \n      s = self.sound .. ' '                       -- 2. \n      print(s .. s .. s) \n    end \n    \n    seymour = LoudDog:new()                       -- 3. \n    seymour:makeSound()  -- 'woof woof woof'      -- 4. \n    \n    -- 1. LoudDog获得Dog的方法和变量列表。 \n    -- 2. 因为new()的缘故，self拥有了一个'sound' key，参见第3条。 \n    -- 3. 等价于LoudDog.new(LoudDog)，转换一下就是 \n    --    Dog.new(LoudDog)，这是因为LoudDog没有'new' key， \n    --    但是它的元表中有 __index = Dog。 \n    --    结果: seymour的元表是LoudDog，并且 \n    --    LoudDog.__index = Dog。所以有seymour.key \n    --    = seymour.key, LoudDog.key, Dog.key \n    --    从其中第一个有指定key的table获取。 \n    -- 4. 在LoudDog可以找到'makeSound'的key； \n    --    等价于LoudDog.makeSound(seymour)。 \n    \n    -- 如果有必要，子类也可以有new()，与基类相似： \n    function LoudDog:new() \n      newObj = {} \n      -- 初始化newObj \n      self.__index = self \n      return setmetatable(newObj, self) \n    end \n    \n    ---------------------------------------------------- \n    -- 4. 模块 \n    ---------------------------------------------------- \n    \n    \n    --[[ 我把这部分给注释了，这样脚本剩下的部分可以运行 \n    \n    -- 假设文件mod.lua的内容类似这样： \n    local M = {} \n    \n    local function sayMyName() \n      print('Hrunkner') \n    end \n    \n    function M.sayHello() \n      print('Why hello there') \n      sayMyName() \n    end \n    \n    return M \n    \n    -- 另一个文件可以使用mod.lua的功能： \n    local mod = require('mod')  -- 运行文件mod.lua. \n    \n    -- require是包含模块的标准做法。 \n    -- require等价于:     (针对没有被缓存的情况；参见后面的内容) \n    local mod = (function () \n      \u003ccontents of mod.lua\u003e \n    end)() \n    -- mod.lua被包在一个函数体中，因此mod.lua的局部变量\n    -- 对外不可见。 \n    \n    -- 下面的代码可以工作，因为在这里mod = mod.lua 中的 M： \n    mod.sayHello()  -- Says hello to Hrunkner. \n    \n    -- 这是错误的；sayMyName只在mod.lua中存在： \n    mod.sayMyName()  -- 错误 \n    \n    -- require返回的值会被缓存，所以一个文件只会被运行一次， \n    -- 即使它被require了多次。 \n    \n    -- 假设mod2.lua包含代码\"print('Hi!')\"。 \n    local a = require('mod2')  -- 打印Hi! \n    local b = require('mod2')  -- 不再打印; a=b. \n    \n    -- dofile与require类似，但是不缓存： \n    dofile('mod2')  --\u003e Hi! \n    dofile('mod2')  --\u003e Hi! (再次运行，与require不同) \n    \n    -- loadfile加载一个lua文件，但是并不运行它。 \n    f = loadfile('mod2')  -- Calling f() runs mod2.lua. \n    \n    -- loadstring是loadfile的字符串版本。 \n    g = loadstring('print(343)')  --返回一个函数。 \n    g()  -- 打印343; 在此之前什么也不打印。 \n    \n    --]] \n","Tags":["lua"," learnxinyminutes"],"CreateTime":1414471972,"EditTime":1414471972,"UpdateTime":1414471972,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":54}