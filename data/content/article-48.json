{"Id":48,"Title":"Simple-C","Slug":"2014-10-28-1","Text":"    // 单行注释以//开始。（仅适用于C99或更新的版本。）\n    \n    /*\n    多行注释是这个样子的。（C89也适用。）\n    */\n    \n    // 常数： #define 关键词\n    #define DAYS_IN_YEAR 365\n    \n    // 以枚举的方式定义常数\n    enum days {SUN = 1, MON, TUE, WED, THU, FRI, SAT};\n    // MON自动被定义为2，TUE被定义为3，以此类推。\n    \n    // 用#include来导入头文件\n    #include \u003cstdlib.h\u003e\n    #include \u003cstdio.h\u003e\n    #include \u003cstring.h\u003e\n    \n    // \u003c尖括号\u003e间的文件名是C标准库的头文件。\n    // 标准库以外的头文件，使用双引号代替尖括号。\n    #include \"my_header.h\"\n    \n    // 函数的签名可以事先在.h文件中定义，\n    // 也可以直接在.c文件的头部定义。\n    void function_1(char c);\n    void function_2(void);\n    \n    // 如果函数出现在main()之后，那么必须在main()之前\n    // 先声明一个函数原型\n    int add_two_ints(int x1, int x2); // 函数原型\n    \n    // 你的程序的入口是一个返回值为整型的main函数\n    int main() {\n    \n    // 用printf打印到标准输出，可以设定格式，\n    // %d 代表整数, \\n 代表换行\n    printf(\"%d\\n\", 0); // =\u003e 打印 0\n    // 所有的语句都要以分号结束\n    \n    ///////////////////////////////////////\n    // 类型\n    ///////////////////////////////////////\n    \n    // 在使用变量之前我们必须先声明它们。\n    // 变量在声明时需要指明其类型，而类型能够告诉系统这个变量所占用的空间\n    \n    // int型（整型）变量一般占用4个字节\n    int x_int = 0;\n    \n    // short型（短整型）变量一般占用2个字节\n    short x_short = 0;\n    \n    // char型（字符型）变量会占用1个字节\n    char x_char = 0;\n    char y_char = 'y'; // 字符变量的字面值需要用单引号包住\n    \n    // long型（长整型）一般需要4个字节到8个字节; 而long long型则至少需要8个字节（64位）\n    \n    long x_long = 0;\n    long long x_long_long = 0; \n    \n    // float一般是用32位表示的浮点数字\n    float x_float = 0.0;\n    \n    // double一般是用64位表示的浮点数字\n    double x_double = 0.0;\n    \n    // 整数类型也可以有无符号的类型表示。这样这些变量就无法表示负数\n    // 但是无符号整数所能表示的范围就可以比原来的整数大一些\n    \n    unsigned short ux_short;\n    unsigned int ux_int;\n    unsigned long long ux_long_long;\n    \n    // 单引号内的字符是机器的字符集中的整数。\n    '0' // =\u003e 在ASCII字符集中是48\n    'A' // =\u003e 在ASCII字符集中是65\n    \n    // char类型一定会占用1个字节，但是其他的类型却会因具体机器的不同而各异\n    // sizeof(T) 可以返回T类型在运行的机器上占用多少个字节 \n    // 这样你的代码就可以在各处正确运行了\n    // sizeof(obj)返回表达式（变量、字面量等）的尺寸\n    printf(\"%zu\\n\", sizeof(int)); // =\u003e 4 (大多数的机器字长为4)\n    \n    // 如果`sizeof`的参数是一个表达式，那么这个参数不会被演算（VLA例外，见下）\n    // 它产生的值是编译期的常数\n    int a = 1;\n    // size_t是一个无符号整型，表示对象的尺寸，至少2个字节\n    size_t size = sizeof(a++); // a++ 不会被演算\n    printf(\"sizeof(a++) = %zu where a = %d\\n\", size, a);\n    // 打印 \"sizeof(a++) = 4 where a = 1\" （在32位架构上）\n    \n    // 数组必须要被初始化为具体的长度\n    char my_char_array[20]; // 这个数组占据 1 * 20 = 20 个字节\n    int my_int_array[20]; // 这个数组占据 4 * 20 = 80 个字节\n                          // (这里我们假设字长为4)\n    \n    \n    // 可以用下面的方法把数组初始化为0:\n    char my_array[20] = {0};\n    \n    // 索引数组和其他语言类似 -- 好吧，其实是其他的语言像C\n    my_array[0]; // =\u003e 0\n    \n    // 数组是可变的，其实就是内存的映射！\n    my_array[1] = 2;\n    printf(\"%d\\n\", my_array[1]); // =\u003e 2\n    \n    // 在C99 （C11中是可选特性），变长数组（VLA）也可以声明长度。\n    // 其长度不用是编译期常量。\n    printf(\"Enter the array size: \"); // 询问用户数组长度\n    char buf[0x100];\n    fgets(buf, sizeof buf, stdin);\n    \n    // stroul 将字符串解析为无符号整数\n    size_t size = strtoul(buf, NULL, 10);\n    int var_length_array[size]; // 声明VLA\n    printf(\"sizeof array = %zu\\n\", sizeof var_length_array);\n    \n    // 上述程序可能的输出为：\n    // \u003e Enter the array size: 10\n    // \u003e sizeof array = 40\n    \n    // 字符串就是以 NUL (0x00) 这个字符结尾的字符数组,\n    // NUL可以用'\\0'来表示.\n    // (在字符串字面量中我们不必输入这个字符，编译器会自动添加的)\n    char a_string[20] = \"This is a string\";\n    printf(\"%s\\n\", a_string); // %s 可以对字符串进行格式化\n    /*\n    也许你会注意到 a_string 实际上只有16个字节长.\n    第17个字节是一个空字符(NUL) \n    而第18, 19 和 20 个字符的值是未定义。\n    */\n    \n    printf(\"%d\\n\", a_string[16]); // =\u003e 0\n    //  byte #17值为0（18，19，20同样为0）\n    \n    // 单引号间的字符是字符字面量\n    // 它的类型是`int`，而 *不是* `char`\n    // （由于历史原因）\n    int cha = 'a'; // 合法\n    char chb = 'a'; // 同样合法 (隐式类型转换\n    \n    // 多维数组\n    int multi_array[2][5] = {\n            {1, 2, 3, 4, 5},\n            {6, 7, 8, 9, 0}\n        }\n    // 获取元素\n    int array_int = multi_array[0][2]; // =\u003e 3\n    \n    ///////////////////////////////////////\n    // 操作符\n    ///////////////////////////////////////\n    \n    // 多个变量声明的简写\n    int i1 = 1, i2 = 2;\n    float f1 = 1.0, f2 = 2.0;\n    \n    int a, b, c;\n    a = b = c = 0;\n    \n    // 算数运算直截了当\n    i1 + i2; // =\u003e 3\n    i2 - i1; // =\u003e 1\n    i2 * i1; // =\u003e 2\n    i1 / i2; // =\u003e 0 (0.5，但会被化整为 0)\n    \n    f1 / f2; // =\u003e 0.5, 也许会有很小的误差\n    // 浮点数和浮点数运算都是近似值\n    \n    // 取余运算\n    11 % 3; // =\u003e 2\n    \n    // 你多半会觉得比较操作符很熟悉, 不过C中没有布尔类型\n    // 而是用整形替代\n    // (C99中有_Bool或bool。)\n    // 0为假, 其他均为真. (比较操作符的返回值总是返回0或1)\n    3 == 2; // =\u003e 0 (false)\n    3 != 2; // =\u003e 1 (true)\n    3 \u003e 2; // =\u003e 1\n    3 \u003c 2; // =\u003e 0\n    2 \u003c= 2; // =\u003e 1\n    2 \u003e= 2; // =\u003e 1\n    \n    // C不是Python —— 连续比较不合法\n    int a = 1;\n    // 错误\n    int between_0_and_2 = 0 \u003c a \u003c 2;\n    // 正确\n    int between_0_and_2 = 0 \u003c a \u0026\u0026 a \u003c 2;\n    \n    // 逻辑运算符适用于整数\n    !3; // =\u003e 0 (非)\n    !0; // =\u003e 1\n    1 \u0026\u0026 1; // =\u003e 1 (且)\n    0 \u0026\u0026 1; // =\u003e 0\n    0 || 1; // =\u003e 1 (或)\n    0 || 0; // =\u003e 0\n    \n    // 条件表达式 （ ? : ）\n    int a = 5;\n    int b = 10;\n    int z;\n    z = (a \u003e b) ? a : b; //  10 “若a \u003e b返回a，否则返回b。”\n    \n    // 增、减\n    char *s = \"iLoveC\"\n    int j = 0;\n    s[j++]; // \"i\" 返回s的第j项，然后增加j的值。\n    j = 0;\n    s[++j]; // =\u003e \"L\"  增加j的值，然后返回s的第j项。\n    // j-- 和 --j 同理\n    \n    // 位运算\n    ~0x0F; // =\u003e 0xF0 (取反)\n    0x0F \u0026 0xF0; // =\u003e 0x00 (和)\n    0x0F | 0xF0; // =\u003e 0xFF (或)\n    0x04 ^ 0x0F; // =\u003e 0x0B (异或)\n    0x01 \u003c\u003c 1; // =\u003e 0x02 (左移1位)\n    0x02 \u003e\u003e 1; // =\u003e 0x01 (右移1位)\n    \n    // 对有符号整数进行移位操作要小心 —— 以下未定义：\n    // 有符号整数位移至符号位 int a = 1 \u003c\u003c 32\n    // 左移位一个负数 int a = -1 \u003c\u003c 2\n    // 移位超过或等于该类型数值的长度\n    // int a = 1 \u003c\u003c 32; // 假定int32位\n    \n    \n    ///////////////////////////////////////\n    // 控制结构\n    ///////////////////////////////////////\n    \n    if (0) {\n      printf(\"I am never run\\n\");\n    } else if (0) {\n      printf(\"I am also never run\\n\");\n    } else {\n      printf(\"I print\\n\");\n    }\n    \n    // While循环\n    int ii = 0;\n    while (ii \u003c 10) { // 任何非0的值均为真\n        printf(\"%d, \", ii++); // ii++ 在取值过后自增\n    } // =\u003e  打印 \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \"\n    \n    printf(\"\\n\");\n    \n    int kk = 0;\n    do {\n        printf(\"%d, \", kk);\n    } while (++kk \u003c 10); // ++kk 先自增，再被取值\n    // =\u003e 打印 \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \"\n    \n    printf(\"\\n\");\n    \n    // For 循环\n    int jj;\n    for (jj=0; jj \u003c 10; jj++) {\n        printf(\"%d, \", jj);\n    } // =\u003e 打印 \"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \"\n    \n    printf(\"\\n\");\n    \n    // *****注意*****:\n    // 循环和函数必须有主体部分，如果不需要主体部分：\n    int i;\n        for (i = 0; i \u003c= 5; i++) {\n        ; // 使用分号表达主体（null语句）\n    }\n    \n    // 多重分支：switch()\n    switch (some_integral_expression) {\n    case 0: // 标签必须是整数常量表达式\n        do_stuff();\n        break; // 如果不使用break，控制结构会继续执行下面的标签\n    case 1:\n        do_something_else();\n        break;\n    default:\n        // 假设 `some_integral_expression` 不匹配任何标签\n        fputs(\"error!\\n\", stderr);\n        exit(-1);\n        break;\n        }\n    \n    ///////////////////////////////////////\n    // 类型转换\n    ///////////////////////////////////////\n    \n    // 在C中每个变量都有类型，你可以将变量的类型进行转换\n    // (有一定限制)\n    \n    int x_hex = 0x01; // 可以用16进制字面量赋值\n    \n    // 在类型转换时，数字本身的值会被保留下来\n    printf(\"%d\\n\", x_hex); // =\u003e 打印 1\n    printf(\"%d\\n\", (short) x_hex); // =\u003e 打印 1\n    printf(\"%d\\n\", (char) x_hex); // =\u003e 打印 1\n    \n    // 类型转换时可能会造成溢出，而且不会抛出警告\n    printf(\"%d\\n\", (char) 257); // =\u003e 1 (char的最大值为255，假定char为8位长)\n    \n    // 使用\u003climits.h\u003e提供的CHAR_MAX、SCHAR_MAX和UCHAR_MAX宏可以确定`char`、`signed_char`和`unisigned char`的最大值。\n    \n    \n    // 整数型和浮点型可以互相转换\n    printf(\"%f\\n\", (float)100); // %f 格式化单精度浮点\n    printf(\"%lf\\n\", (double)100); // %lf 格式化双精度浮点\n    printf(\"%d\\n\", (char)100.0);\n    \n    ///////////////////////////////////////\n    // 指针\n    ///////////////////////////////////////\n    \n    // 指针变量是用来储存内存地址的变量\n    // 指针变量的声明也会告诉它所指向的数据的类型\n    // 你可以使用得到你的变量的地址，并把它们搞乱，;-)\n    \n    int x = 0;\n    printf(\"%p\\n\", \u0026x); // 用 \u0026 来获取变量的地址\n    // (%p 格式化一个类型为 void *的指针)\n    // =\u003e 打印某个内存地址\n    \n    // 指针类型在声明中以*开头\n    int* px, not_a_pointer; // px是一个指向int型的指针\n    px = \u0026x; // 把x的地址保存到px中\n    printf(\"%p\\n\", (void *)px); // =\u003e 输出内存中的某个地址\n    printf(\"%zu, %zu\\n\", sizeof(px), sizeof(not_a_pointer));\n    // =\u003e 在64位系统上打印“8， 4”。\n    \n    // 要得到某个指针指向的内容的值，可以在指针前加一个*来取得（取消引用）\n    // 注意： 是的，这可能让人困惑，'*'在用来声明一个指针的同时取消引用它。\n    printf(\"%d\\n\", *px); // =\u003e 输出 0, 即x的值\n    \n    // 你也可以改变指针所指向的值\n    // 此时你需要取消引用上添加括号，因为++比*的优先级更高\n    (*px)++; // 把px所指向的值增加1\n    printf(\"%d\\n\", *px); // =\u003e 输出 1\n    printf(\"%d\\n\", x); // =\u003e 输出 1\n    \n    // 数组是分配一系列连续空间的常用方式\n    int x_array[20];\n    int xx;\n    for (xx=0; xx\u003c20; xx++) {\n        x_array[xx] = 20 - xx;\n    } // 初始化 x_array 为 20, 19, 18,... 2, 1\n    \n    // 声明一个整型的指针，并初始化为指向x_array\n    int* x_ptr = x_array;\n    // x_ptr现在指向了数组的第一个元素(即整数20). \n    // 这是因为数组通常衰减为指向它们的第一个元素的指针。\n    // 例如，当一个数组被传递给一个函数或者绑定到一个指针时，\n    //它衰减为(隐式转化为）一个指针。\n    // 例外： 当数组是`\u0026`操作符的参数：\n    int arr[10];\n    int (*ptr_to_arr)[10] = \u0026arr; // \u0026arr的类型不是`int *`！\n                                  // 它的类型是指向数组的指针（数组由10个int组成）\n    // 或者当数组是字符串字面量（初始化字符数组）\n    char arr[] = \"foobarbazquirk\";\n    // 或者当它是`sizeof`或`alignof`操作符的参数时：\n    int arr[10];\n    int *ptr = arr; // 等价于 int *ptr = \u0026arr[0];\n    printf(\"%zu, %zu\\n\", sizeof arr, sizeof ptr); // 应该会输出\"40, 4\"或\"40, 8\"\n    \n    // 指针的增减多少是依据它本身的类型而定的\n    // （这被称为指针算术）\n    printf(\"%d\\n\", *(x_ptr + 1)); // =\u003e 打印 19\n    printf(\"%d\\n\", x_array[1]); // =\u003e 打印 19\n    \n    // 你也可以通过标准库函数malloc来实现动态分配\n    // 这个函数接受一个代表容量的参数，参数类型为`size_t`\n    // 系统一般会从堆区分配指定容量字节大小的空间\n    // （在一些系统，例如嵌入式系统中这点不一定成立\n    // C标准对此未置一词。）\n    int *my_ptr = malloc(sizeof(*my_ptr) * 20);\n    for (xx=0; xx\u003c20; xx++) {\n        *(my_ptr + xx) = 20 - xx; // my_ptr[xx] = 20-xx\n    } // 初始化内存为 20, 19, 18, 17... 2, 1 (类型为int）\n    \n    // 对未分配的内存进行取消引用会产生未定义的结果\n    printf(\"%d\\n\", *(my_ptr + 21)); // =\u003e 谁知道会输出什么\n    \n    // malloc分配的区域需要手动释放\n    // 否则没人能够再次使用这块内存，直到程序结束为止\n    free(my_ptr);\n    \n    // 字符串通常是字符数组，但是经常用字符指针表示\n    // (它是指向数组的第一个元素的指针)\n    // 一个优良的实践是使用`const char *`来引用一个字符串字面量，\n    // 因为字符串字面量不应当被修改（即\"foo\"[0] = 'a'犯了大忌）\n    const char* my_str = \"This is my very own string\";\n    printf(\"%c\\n\", *my_str); // =\u003e 'T'\n    \n    // 如果字符串是数组，（多半是用字符串字面量初始化的）\n    // 情况就不一样了，字符串位于可写的内存中\n    char foo[] = \"foo\";\n    foo[0] = 'a'; // 这是合法的，foo现在包含\"aoo\"\n    \n    function_1();\n    } // main函数结束\n    \n    ///////////////////////////////////////\n    // 函数\n    ///////////////////////////////////////\n    \n    // 函数声明语法:\n    // \u003c返回值类型\u003e \u003c函数名称\u003e(\u003c参数\u003e)\n    \n    int add_two_ints(int x1, int x2){\n        return x1 + x2; // 用return来返回一个值\n    }\n    \n    /*\n    函数是按值传递的。当调用一个函数的时候，传递给函数的参数\n    是原有值的拷贝（数组除外）。你在函数内对参数所进行的操作\n    不会改变该参数原有的值。\n    \n    但是你可以通过指针来传递引用，这样函数就可以更改值\n    \n    例子：字符串本身翻转\n    */\n    \n    // 类型为void的函数没有返回值\n    void str_reverse(char *str_in){\n        char tmp;\n        int ii = 0;\n        size_t len = strlen(str_in); // `strlen()`` 是C标准库函数\n        for(ii = 0; ii \u003c len / 2; ii++){\n            tmp = str_in[ii];\n            str_in[ii] = str_in[len - ii - 1]; // 从倒数第ii个开始\n            str_in[len - ii - 1] = tmp;\n        }\n    }\n    \n    /*\n    char c[] = \"This is a test.\";\n    str_reverse(c);\n    printf(\"%s\\n\", c); // =\u003e \".tset a si sihT\"\n    */\n    \n    // 如果引用函数之外的变量，必须使用extern关键字\n    int i = 0;\n    void testFunc() {\n        extern int i; // 使用外部变量 i\n    }\n    \n    // 使用static确保external变量为源文件私有\n    static int i = 0; // 其他使用 testFunc()的文件无法访问变量i\n    void testFunc() {\n        extern int i;\n    }\n    //**你同样可以声明函数为static**\n    \n    \n    ///////////////////////////////////////\n    // 用户自定义类型和结构\n    ///////////////////////////////////////\n    \n    // Typedefs可以创建类型别名\n    typedef int my_type;\n    my_type my_type_var = 0;\n    \n    // struct是数据的集合，成员依序分配，按照\n    // 编写的顺序\n    struct rectangle {\n        int width;\n        int height;\n    };\n    \n    // 一般而言，以下断言不成立：\n    // sizeof(struct rectangle) == sizeof(int) + sizeof(int)\n    //这是因为structure成员之间可能存在潜在的间隙（为了对齐）[1]\n    \n    void function_1(){\n    \n        struct rectangle my_rec;\n    \n        // 通过 . 来访问结构中的数据\n        my_rec.width = 10;\n        my_rec.height = 20;\n    \n        // 你也可以声明指向结构体的指针\n        struct rectangle *my_rec_ptr = \u0026my_rec;\n    \n        // 通过取消引用来改变结构体的成员...\n        (*my_rec_ptr).width = 30;\n    \n        // ... 或者用 -\u003e 操作符作为简写提高可读性\n        my_rec_ptr-\u003eheight = 10; // Same as (*my_rec_ptr).height = 10;\n    }\n    \n    // 你也可以用typedef来给一个结构体起一个别名\n    typedef struct rectangle rect;\n    \n    int area(rect r){\n        return r.width * r.height;\n    }\n    \n    // 如果struct较大，你可以通过指针传递，避免\n    // 复制整个struct。\n    int area(const rect *r)\n    {\n        return r-\u003ewidth * r-\u003eheight;\n    }\n    \n    ///////////////////////////////////////\n    // 函数指针\n    ///////////////////////////////////////\n    /*\n    在运行时，函数本身也被存放到某块内存区域当中\n    函数指针就像其他指针一样（不过是存储一个内存地址） 但却可以被用来直接调用函数,\n    并且可以四处传递回调函数\n    但是，定义的语法初看令人有些迷惑\n    \n    例子：通过指针调用str_reverse\n    */\n    void str_reverse_through_pointer(char *str_in) {\n        // 定义一个函数指针 f. \n        void (*f)(char *); // 签名一定要与目标函数相同\n        f = \u0026str_reverse; // 将函数的地址在运行时赋给指针\n        (*f)(str_in); // 通过指针调用函数\n        // f(str_in); // 等价于这种调用方式\n    }\n    \n    /*\n    只要函数签名是正确的，任何时候都能将任何函数赋给某个函数指针\n    为了可读性和简洁性，函数指针经常和typedef搭配使用：\n    */\n    \n    typedef void (*my_fnp_type)(char *);\n    \n    // 实际声明函数指针会这么用:\n    // ...\n    // my_fnp_type f; \n    \n    // 特殊字符\n    '\\a' // bell\n    '\\n' // 换行\n    '\\t' // tab\n    '\\v' // vertical tab\n    '\\f' // formfeed\n    '\\r' // 回车\n    '\\b' // 退格\n    '\\0' // null，通常置于字符串的最后。\n         //   hello\\n\\0. 按照惯例，\\0用于标记字符串的末尾。\n    '\\\\' // 反斜杠\n    '\\?' // 问号\n    '\\'' // 单引号\n    '\\\"' // 双引号\n    '\\xhh' // 十六进制数字. 例子: '\\xb' = vertical tab\n    '\\ooo' // 八进制数字. 例子: '\\013' = vertical tab\n    \n    // 打印格式：\n    \"%d\"    // 整数\n    \"%3d\"   // 3位以上整数 （右对齐文本）\n    \"%s\"    // 字符串\n    \"%f\"    // float\n    \"%ld\"   // long\n    \"%3.2f\" // 左3位以上、右2位以上十进制浮\n    \"%7.4s\" // (字符串同样适用)\n    \"%c\"    // 字母\n    \"%p\"    // 指针\n    \"%x\"    // 十六进制\n    \"%o\"    // 八进制\n    \"%%\"    // 打印 %\n    \n    ///////////////////////////////////////\n    // 演算优先级\n    ///////////////////////////////////////\n    //---------------------------------------------------//\n    //        操作符                     | 组合          //\n    //---------------------------------------------------//\n    // () [] -\u003e .                        | 从左到右      //\n    // ! ~ ++ -- + = *(type)sizeof       | 从右到左      //\n    // * / %                             | 从左到右      //\n    // + -                               | 从左到右      //\n    // \u003c\u003c \u003e\u003e                             | 从左到右      //\n    // \u003c \u003c= \u003e \u003e=                         | 从左到右      //\n    // == !=                             | 从左到右      //\n    // \u0026                                 | 从左到右      //\n    // ^                                 | 从左到右      //\n    // |                                 | 从左到右      //\n    // \u0026\u0026                                | 从左到右      //\n    // ||                                | 从左到右      //\n    // ?:                                | 从右到左      //\n    // = += -= *= /= %= \u0026= ^= |= \u003c\u003c= \u003e\u003e= | 从右到左      //\n    // ,                                 | 从左到右      //\n    //---------------------------------------------------//","Tags":["C"," learnxinyminutes"],"CreateTime":1414471879,"EditTime":1414471879,"UpdateTime":1414471879,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":313}