{"Id":250,"Title":"Tomorrow is another day","Slug":"2016-01-22-1","Text":"偶然看见一个好玩的异步代码提供了神奇的装饰器的Python第三方库[Tomorrow](https://github.com/madisonmay/Tomorrow),查了下他的代码，短小精悍，却包含了很多有意思的特性，这篇文章就是从这个库说开去的。\n\n## 来个使用的例子：\n\n##### 不使用tomorrow的\n\n    import time\n    import requests\n\n    urls = [\n        'http://sina.com.cn',\n        'http://163.com',\n        'http://oschina.net',\n        'http://baidu.com',\n        'http://csdn.net',\n    ]\n\n    def download(url):\n        return requests.get(url)\n\n    if __name__ == \"__main__\":\n\n        start = time.time()\n        responses = [download(url) for url in urls]\n        html = [response.text for response in responses]\n        end = time.time()\n        print (\"Time: %f seconds\" % (end - start))\n\n    # Time: 2.059337 seconds\n\n##### tomorrow一下\n\n    import time\n    import requests\n\n    from tomorrow import threads\n\n    urls = [\n        'http://sina.com.cn',\n        'http://163.com',\n        'http://oschina.net',\n        'http://baidu.com',\n        'http://csdn.net',\n    ]\n\n    @threads(5)\n    def download(url):\n        return requests.get(url)\n\n    if __name__ == \"__main__\":\n        start = time.time()\n        responses = [download(url) for url in urls]\n        html = [response.text for response in responses]\n        end = time.time()\n        print (\"Time: %f seconds\" % (end - start))\n    # Time: 0.303633 seconds\n\n\n** 2.059337 seconds VS 0.303633 seconds ** 你看的没错，就是这么神奇\n\n为了探明究竟，自古华山一条路，查代码，OMG，代码只有42行，全贴：\n\n    from functools import wraps\n\n    from concurrent.futures import ThreadPoolExecutor\n\n\n    class Tomorrow():\n\n        def __init__(self, future, timeout):\n            self._future = future\n            self._timeout = timeout\n\n        def __getattr__(self, name):\n            result = self._wait()\n            return result.__getattribute__(name)\n\n        def _wait(self):\n            return self._future.result(self._timeout)\n\n\n    def async(n, base_type, timeout=None):\n        def decorator(f):\n            if isinstance(n, int):\n                pool = base_type(n)\n            elif isinstance(n, base_type):\n                pool = n\n            else:\n                raise TypeError(\n                    \"Invalid type: %s\"\n                    % type(base_type)\n                )\n            @wraps(f)\n            def wrapped(*args, **kwargs):\n                return Tomorrow(\n                    pool.submit(f, *args, **kwargs),\n                    timeout=timeout\n                )\n            return wrapped\n        return decorator\n\n\n    def threads(n, timeout=None):\n        return async(n, ThreadPoolExecutor, timeout)\n\n\n这里面主要包含了几个方面\n\n + 第三方库`Requests`\n + Python装饰器\n + Python的几个基本的Metaclasses() `__getattr__`  `__getattribute__`\n + 异步杀器 `concurrent.futures`\n\n[`Requests`](http://www.python-requests.org/en/latest/) 是使用 Apache2 Licensed 许可证的 HTTP 库。用 Python 编写，真正的为人类着想。在大部分第三方库的推荐中名列前茅。这里不做过多的说明。\n\nPython装饰器是Python编程中的重要组成部分，也是函数式编程的重要概念，我相信我不会比[coolshell](http://coolshell.cn)的[Python修饰器的函数式编程](http://coolshell.cn/articles/11265.html)写的更好，所以想了解的去看这篇文章吧。\n\nPython的Metaclasses是Python编程的重要概念，推荐你去看[Python Pocket Reference](http://www.amazon.com/Python-Pocket-Reference-OReilly/dp/1449357016/ref=sr_1_1?ie=UTF8\u0026qid=1453434921\u0026sr=8-1\u0026keywords=Python+Pocket+Reference)的Operator Overloading Methods章节，另外说一下，作为手册，就应该像这本书这样写。\n\n我们今天主要说的是`concurrent.futures`\n\n \n在Python2里面，[`concurrent.futures`](http://pythonhosted.org//futures/)是一个第三方库，在Python3里面已经作为标准库提供了，Python3相关的文档看[这里](https://docs.python.org/dev/library/concurrent.futures.html)\n\n\n#### 准备\n\n在Python2环境里，需要安装的依赖库\n\n    pip2 install futures\n    pip2 install requests\n\n\nPython3环境 \n\n    pip3 install requests\n\n对于python来说，作为解释型语言，Python的解释器必须做到既安全又高效。我们都知道多线程编程会遇到的问题，解释器要留意的是避免在不同的线程操作内部共享的数据，同时它还要保证在管理用户线程时保证总是有最大化的计算资源。而python是通过使用全局解释器锁来保护数据的安全性：\npython代码的执行由python虚拟机来控制，即Python先把代码（.py文件）编译成字节码（字节码在Python虚拟机程序里对应的是PyCodeObject对象，.pyc文件是字节码在磁盘上的表现形式），交给字节码虚拟机，然后虚拟机一条一条执行字节码指令，从而完成程序的执行。python在设计的时候在虚拟机中，同时只能有一个线程执行。同样地，虽然python解释器中可以运行多个线程，但在任意时刻，只有一个线程在解释器中运行。而对python虚拟机的访问由全局解释器锁来控制，正是这个锁能保证同一时刻只有一个线程在运行。在多线程的环境中，python虚拟机按一下方式执行：\n\n + 1，设置GIL(global interpreter lock).\n + 2，切换到一个线程执行。\n + 3，运行：\n   + a，指定数量的字节码指令。\n   + b，线程主动让出控制（可以调用time.sleep(0)）。\n + 4，把线程设置为睡眠状态。\n + 5，解锁GIL.\n + 6，再次重复以上步骤。\n\nGIL的特性，也就导致了python不能充分利用多核cpu。而对面向I/O的（会调用内建操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果线程并为使用很多I/O操作，它会在自己的时间片一直占用处理器和GIL。这也就是所说的：I/O密集型python程序比计算密集型的程序更能充分利用多线程的好处。\n\n总之，不要使用python多线程，使用python多进程进行并发编程，就不会有GIL这种问题存在，并且也能充分利用多核cpu。\n\nGIL的特性，也就导致了python不能充分利用多核cpu。而对面向I/O的（会调用内建操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果线程并为使用很多I/O操作，它会在自己的时间片一直占用处理器和GIL。这也就是所说的：I/O密集型python程序比计算密集型的程序更能充分利用多线程的好处。\n总之，不要使用python多线程，使用python多进程进行并发编程，就不会有GIL这种问题存在，并且也能充分利用多核cpu。\n\n##### concurrent.futures提供的功能:\n\n   提供了多线程(ThreadPoolExecutor)和多进程(ProcessPoolExecutor)的并发功能\n\nconcurrent.futures基本方法：\n\n    class   concurrent.futures.Executor\n    #Executor为ThreadPoolExecutor或者ProcessPoolExecutor\n\n##### concurrent.futures提供的方法如下：\n    \n#### 1. `submit(fn, *args, **kwargs)`\n\n\u003e fn：为需要异步执行的函数\n\n\u003e args，kwargs：为给函数传递的参数\n    \n例：\n\n    #!/bin/env python\n    #coding:utf-8\n    import time,re\n    import os,datetime\n    from concurrent import futures\n    \n    def wait_on_b():\n        print 5\n        time.sleep(2)\n    \n    def wait_on_a():\n        print 6\n        time.sleep(2)\n    \n    ex = futures.ThreadPoolExecutor(max_workers=2)\n    ex.submit(wait_on_b)\n    ex.submit(wait_on_a)\n    #wait_on_a和wait_on_b函数会同时执行，因为使用了2个worker\n\n\n#### 2. `map(func, *iterables, timeout=None)`\n    \n此map函数和python自带的map函数功能类似，只不过concurrent模块的map函数从迭代器获得参数后异步执行。并且，每一个异步操作，能用timeout参数来设置超时时间，timeout的值可以是int或float型，如果操作timeout的话，会raisesTimeoutError。如果timeout参数不指定的话，则不设置超时间。\n\n\u003e func：为需要异步执行的函数\n\n\u003e iterables：可以是一个能迭代的对象，例如列表等。每一次func执行，会从iterables中取参数。\n\n\u003e timeout：设置每次异步操作的超时时间\n\n例：\n\n    #!/bin/env python\n    #coding:utf-8\n    import time,re\n    import os,datetime\n    from concurrent import futures\n    data = ['1','2']\n    \n    def wait_on(argument):\n        print argument\n        time.sleep(2)\n        return 'ok'\n    \n    ex = futures.ThreadPoolExecutor(max_workers=2)\n    for i in ex.map(wait_on,data):\n        print i\n\nmap函数异步执行完成之后，结果也是list，数据需要从list中取出\n\nsubmit函数和map函数，根据需要，选一个使用即可。\n\n#### 3. `shutdown(wait=True)`\n\n此函数用于释放异步执行操作后的系统资源。\n\n### 一个完整的concurrent例子\n\n    #!/bin/env python\n    #coding:utf-8\n\n    import time,re,fcntl\n    import os,datetime\n\n    from concurrent import futures\n\n    count_list = list()\n    minute_num = 1\n    start_time = datetime.datetime(2016, 1, 22, 13, 30, 0, 484870)\n    now = datetime.datetime.now()\n    os.system(':\u003enew.txt')\n    f_new = open('new.txt','a')\n    \n    def test(count_time_format):\n        f = open('push_slave.stdout','r')\n        for line in f.readlines():\n            if re.search(count_time_format,line):\n                #获得文件专用锁\n                fcntl.flock(f_new, fcntl.LOCK_EX)\n                f_new.writelines(line)\n                f_new.flush()\n                \n                #释放文件锁\n                fcntl.flock(f_new, fcntl.LOCK_UN)\n                break\n    \n    while 1:\n        after_one_minute = datetime.timedelta(minutes=minute_num)\n        count_time = after_one_minute + start_time\n        count_time_format = count_time.strftime('%Y-%m-%d %H:%M')\n        minute_num = minute_num+1\n        count_list.append(count_time_format)\n        if count_time_format == \"2014-04-23 16:00\":\n            break\n    \n    def exec_cmd():\n        with futures.ProcessPoolExecutor(max_workers=24) as executor:\n            dict((executor.submit(test, times), times) for times in count_list)\n    \n    if __name__ == '__main__':\n        exec_cmd()\n        f_new.close()\n\n收工，有时间比较一下 `futures` 和 `multiprocessing`\n","Tags":["Python"],"CreateTime":1453441118,"EditTime":1453441118,"UpdateTime":1453441118,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":449}