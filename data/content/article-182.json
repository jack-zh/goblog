{"Id":182,"Title":" Golang Internals, Part 2: Diving Into the Go Compiler ","Slug":"2015-03-19-2","Text":"![](/static/upload/201503191232034.png)\n\nDo you know what exactly happens in the Go runtime, when you use a variable via interface reference? This is not a trivial question, because in Go a type that implements an interface does not contain any references to this interface whatsoever. Still, we can try answering it, using our knowledge of the Go compiler, which was discussed in the previous blog post.\n\nSo, let’s take a deep dive into the Go compiler: create a basic Go program and see the internal workings of the Go typecasting. Using it as an example, I’ll explain how a node tree is generated and utilized. So, you can further apply this knowledge to other Go compiler’s features.\n \n### Before you start\n\nTo perform the experiment, we will need to work directly with the Go compiler (not the Go tool). You can access it by using the command:\n\n    go tool 6g test.go\n\nIt will compile the test.go source file and create an object file. Here, 6g is the name of the compiler on my machine that has an AMD64 architecture. Note that you should use different compilers for different architectures.\n\nWhen we work directly with the compiler, we can use some handy command line arguments (more details [here](https://golang.org/cmd/gc/#hdr-Command_Line)). For the purposes of this experiment, we’ll need the -W flag that will print the layout of the node tree.\n\n### Creating a simple Go program\n\nFirst of all, we are going to create a sample Go program. My version is below:\n        \n     package main\n\n     type I interface {\n             DoSomeWork()\n     }\n\n     type T struct {\n             a int\n     }\n\n     func (t *T) DoSomeWork() {\n     }\n\n     func main() {\n             t := \u0026T{}\n             i := I(t)\n             print(i)\n     }\n\nReally simple, isn’t it? The only thing that might seem unnecessary is the 17th line, where we print the i variable. Nevertheless, without it, i will remain unused and the program will not be compiled. The next step is to compile our program using the -W switch:\n\n    go tool 6g -W test.go\n\n \nAfter doing this, you will see output that contains node trees for each method defined in the program. In our case, these are the main and init methods. The init method is here because it is implicitly defined for all programs, but we actually do not care about it right now.\n\nFor each method, the compiler prints two versions of the node tree. The first one is the original node tree that we get after parsing the source file. The second one is the version that we get after type checking and applying all the necessary modifications.\n\n### Understanding the node tree of the main method\n\nLet’s take a closer look at the original version of the node tree from the main method and try to understand what exactly is going on.\n\n    DCL l(15)\n    .   NAME-main.t u(1) a(1) g(1) l(15) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) PTR64-*main.T\n\n    AS l(15) colas(1) tc(1)\n    .   NAME-main.t u(1) a(1) g(1) l(15) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) PTR64-*main.T\n    .   PTRLIT l(15) esc(no) ld(1) tc(1) PTR64-*main.T\n    .   .   STRUCTLIT l(15) tc(1) main.T\n    .   .   .   TYPE \u003cS\u003e l(15) tc(1) implicit(1) type=PTR64-*main.T PTR64-*main.T\n\n    DCL l(16)\n    .   NAME-main.i u(1) a(1) g(2) l(16) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) main.I\n\n    AS l(16) tc(1)\n    .   NAME-main.autotmp_0000 u(1) a(1) l(16) x(0+0) class(PAUTO) esc(N) tc(1) used(1) PTR64-*main.T\n    .   NAME-main.t u(1) a(1) g(1) l(15) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) PTR64-*main.T\n\n    AS l(16) colas(1) tc(1)\n    .   NAME-main.i u(1) a(1) g(2) l(16) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) main.I\n    .   CONVIFACE l(16) tc(1) main.I\n    .   .   NAME-main.autotmp_0000 u(1) a(1) l(16) x(0+0) class(PAUTO) esc(N) tc(1) used(1) PTR64-*main.T\n\n    VARKILL l(16) tc(1)\n    .   NAME-main.autotmp_0000 u(1) a(1) l(16) x(0+0) class(PAUTO) esc(N) tc(1) used(1) PTR64-*main.T\n\n    PRINT l(17) tc(1)\n    PRINT-list\n    .   NAME-main.i u(1) a(1) g(2) l(16) x(0+0) class(PAUTO) f(1) ld(1) tc(1) used(1) main.I\n\nIn the explanation below, I will use an abridged version, from which I removed all the unnecessary details.\n\nThe first node is rather simple:\n\n    DCL l(15)\n    .   NAME-main.t l(15) PTR64-*main.T\n\nThe first node is a declaration node. l(15) tells us that this node is defined in line 15. The declaration node references the name node that represents the main.t variable. This variable is defined in the main package and is actually a 64-bit pointer to the main.T type. You can look at line 15 and easily understand what declaration is represented there.\n\nThe next one is a bit trickier.\n\n    AS l(15) \n    .   NAME-main.t l(15) PTR64-*main.T\n    .   PTRLIT l(15) PTR64-*main.T\n    .   .   STRUCTLIT l(15) main.T\n    .   .   .   TYPE l(15) type=PTR64-*main.T PTR64-*main.T\n\nThe root node is the assignment node. Its first child is the name node that represents the main.t variable. The second child is a node that we assign to main.t—a pointer literal node (\u0026). It has a child struct literal, which, in its turn, points to the type node that represents the actual type (main.T).\n\nThe next node is another declaration. This time, it is a declaration of the main.i variable that belongs to the main.I type.\n\n    DCL l(16)\n    .   NAME-main.i l(16) main.I\n\nThen, the compiler creates another variable, autotmp_0000, and assigns the main.t variable to it.\n\n    AS l(16) tc(1)\n    .   NAME-main.autotmp_0000 l(16) PTR64-*main.T\n    .   NAME-main.t l(15) PTR64-*main.T\n\nFinally, we came to the nodes that we are actually inetersted in.\n\n    AS l(16) \n    .   NAME-main.i l(16)main.I\n    .   CONVIFACE l(16) main.I\n    .   .   NAME-main.autotmp_0000 PTR64-*main.T\n\n Here, we can see that the compiler has assigned a special node called CONVIFACE to the main.i variable. But this does not give us much information about what’s happening under the hood. To find out what’s going on, we need to look into the node tree of the main method after all node tree modifications have been applied (you can find this information in the “after walk main” section of your output).\n\n### How the compiler translates the assignment node\n\nBelow, you can see how the compiler translates our assignment node:\n\n    AS-init\n    .   AS l(16) \n    .   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8\n    .   .   NAME-go.itab.*\"\".T.\"\".I l(16) PTR64-*uint8\n\n    .   IF l(16) \n    .   IF-test\n    .   .   EQ l(16) bool\n    .   .   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8\n    .   .   .   LITERAL-nil I(16) PTR64-*uint8\n    .   IF-body\n    .   .   AS l(16)\n    .   .   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8\n    .   .   .   CALLFUNC l(16) PTR64-*byte\n    .   .   .   .   NAME-runtime.typ2Itab l(2) FUNC-funcSTRUCT-(FIELD-\n    .   .   .   .   .   NAME-runtime.typ·2 l(2) PTR64-*byte, FIELD-\n    .   .   .   .   .   NAME-runtime.typ2·3 l(2) PTR64-*byte PTR64-*byte, FIELD-\n    .   .   .   .   .   NAME-runtime.cache·4 l(2) PTR64-*PTR64-*byte PTR64-*PTR64-*byte) PTR64-*byte\n    .   .   .   CALLFUNC-list\n    .   .   .   .   AS l(16) \n    .   .   .   .   .   INDREG-SP l(16) runtime.typ·2 G0 PTR64-*byte\n    .   .   .   .   .   ADDR l(16) PTR64-*uint8\n    .   .   .   .   .   .   NAME-type.*\"\".T l(11) uint8\n\n    .   .   .   .   AS l(16)\n    .   .   .   .   .   INDREG-SP l(16) runtime.typ2·3 G0 PTR64-*byte\n    .   .   .   .   .   ADDR l(16) PTR64-*uint8\n    .   .   .   .   .   .   NAME-type.\"\".I l(16) uint8\n\n    .   .   .   .   AS l(16) \n    .   .   .   .   .   INDREG-SP l(16) runtime.cache·4 G0 PTR64-*PTR64-*byte\n    .   .   .   .   .   ADDR l(16) PTR64-*PTR64-*uint8\n    .   .   .   .   .   .   NAME-go.itab.*\"\".T.\"\".I l(16) PTR64-*uint8\n    AS l(16) \n    .   NAME-main.i l(16) main.I\n    .   EFACE l(16) main.I\n    .   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8\n    .   .   NAME-main.autotmp_0000 l(16) PTR64-*main.T\n\nAs you can see from the output, the compiler first adds an initialization node list (AS-init) to the assignment node. Inside the AS-init node, it creates a new variable, main.autotmp_0003, and assigns the value of the go.itab.*”\".T.”\".I variable to it. After that, it checks whether this variable is nil. If the variable is nil, the compiler calls the runtime.typ2Itab function and passes the following to it:\n\na pointer to the main.T type ,\na pointer to the main.I interface type,\nand a pointer to the go.itab.*”\".T.”\".I variable.\n\nFrom this code, it is quite evident that this variable is for caching the result of type conversion from main.T to main.I.\n\n### Inside the getitab method\n\nThe next logical step is to find runtime.typ2Itab. Below is the listing of this function:\n \n     func typ2Itab(t *_type, inter *interfacetype, cache **itab) *itab {\n      tab := getitab(inter, t, false)\n      atomicstorep(unsafe.Pointer(cache), unsafe.Pointer(tab))\n      return tab\n    }\n\nIt is quite evident that the actual work is done inside the getitab method, because the second line simply stores the created tab variable in the cache. So, let’s look inside getitab. Since it is rather big, I only copied the most valuable part.\n\n    m = \n        (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*ptrSize, 0,\n        \u0026memstats.other_sys))\n        m.inter = interm._type = typ\n\n    ni := len(inter.mhdr)\n    nt := len(x.mhdr)\n    j := 0\n    for k := 0; k \u003c ni; k++ {\n      i := \u0026inter.mhdr[k]\n      iname := i.name\n      ipkgpath := i.pkgpath\n      itype := i._type\n      for ; j \u003c nt; j++ {\n        t := \u0026x.mhdr[j]\n        if t.mtyp == itype \u0026\u0026 t.name == iname \u0026\u0026 t.pkgpath == ipkgpath {\n          if m != nil {\n            *(*unsafe.Pointer)(add(unsafe.Pointer(\u0026m.fun[0]), uintptr(k)*ptrSize)) = t.ifn\n          }\n        }\n      }\n    }\n\nFirst, we allocate memory for the result:\n\n    (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*ptrSize, 0, \u0026memstats.other_sys))\n\nWhy should we allocate memory in Go and why is this done in such a strange way? To answer this question, we need to look at the itab struct definition.\n\n    type itab struct {\n      inter  *interfacetype\n      _type  *_type\n      link   *itab\n      bad    int32\n      unused int32\n      fun    [1]uintptr // variable sized\n    }\n\nThe last property, fun, is defined as an array of one element, but it is actually variable-sized. Later, we’ll see that this property contains an array of pointers to methods defined in a particular type. These methods correspond to the methods in the interface type. The authors of Go use dynamic memory allocation for this property (yes, such things are possible, when you use an unsafe package). The amount of memory to be allocated is calculated by adding the size of the struct itself to the number of methods in the interface multiplied by a pointer size.\n\n    unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*ptrSize\n\n \nNext, you can see two nested loops. First, we iterate through all interface methods. For each method in the interface, we try to find a corresponding method in a particular type (the methods are stored in the mhdr collection). The process of checking whether two methods are equal is quite self-explanatory.\n\n    if t.mtyp == itype \u0026\u0026 t.name == iname \u0026\u0026 t.pkgpath == ipkgpath\n\n \nIf we find a match, we store a pointer to the method in the fun property of the result:\n\n    *(*unsafe.Pointer)(add(unsafe.Pointer(\u0026m.fun[0]), uintptr(k)*ptrSize)) = t.ifn\n\n \nA small note on performance: since methods are sorted alphabetically for interface and pre-set type definitions, this nested loop can repeat O(n + m) times instead of O(n * m) times, where n and m correspond to the number of methods.\n\nFinally, do you remember the last part of the assignment?\n\n    AS l(16) \n    .   NAME-main.i l(16) main.I\n    .   EFACE l(16) main.I\n    .   .   NAME-main.autotmp_0003 l(16) PTR64-*uint8\n    .   .   NAME-main.autotmp_0000 l(16) PTR64-*main.T\n\n \nHere, we assign the EFACE node to the main.i variable. This node (EFACE) contains references to the main.autotmp_0003 variable—a pointer to the itab struct that was returned by the runtime.typ2Itab method—and to the autotmp_0000 variable that contains the same value as the main.t variable. This is all we need to call methods by interface references.\n\nSo, the main.i variable contains an instance of the iface struct defined in the runtime package:\n\n    type iface struct {\n\t    tab  *itab\n\t    data unsafe.Pointer\n    }\n\n \n### What’s next?\n\nI understand that I’ve only covered a very small part of the Go compiler and the Go runtime so far. There are still plenty of interesting things to talk about, such as object files, the linker, relocations, etc.—they will be overviewed in the upcoming blog posts.\n\n**About the author: **Sergey Matyukevich is a Cloud Engineer and Go Developer at Altoros. With 6+ years in software engineering, he is an expert in cloud automation and designing architectures for complex cloud-based systems. An active member of the Go community, Sergey is a frequent contributor to open-source projects, such as Ubuntu and Juju Charms.\n\nThe original address：http://blog.altoros.com/golang-internals-part-2-diving-into-the-go-compiler.html","Tags":["golang"],"CreateTime":1426739540,"EditTime":1426739540,"UpdateTime":1426739540,"IsComment":true,"IsLinked":false,"AuthorId":10,"Template":"blog.html","Type":"article","Status":"publish","Format":"markdown","Comments":[],"Hits":52}